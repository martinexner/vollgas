/*!
 * vollgas logic gate circuit simulator
 * Copyright (C) Martin Exner
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3
 * as published by the Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./out/js/Vollgas_global.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/nearley/lib/nearley.js":
/*!*********************************************!*\
  !*** ./node_modules/nearley/lib/nearley.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        function stringifySymbolSequence (e) {\n            return e.literal ? JSON.stringify(e.literal) :\n                   e.type ? '%' + e.type : e.toString();\n        }\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(stringifySymbolSequence).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var line = buffer.substring(this.lastLineBreak, nextLineBreak)\n            var col = this.index - this.lastLineBreak;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += \"  \" + line + \"\\n\"\n            message += \"  \" + Array(col).join(\" \") + \"^\"\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n    }\n\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (token = lexer.next()) {\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var message = this.lexer.formatError(token, \"invalid syntax\") + \"\\n\";\n                message += \"Unexpected \" + (token.type ? token.type + \" token: \" : \"\");\n                message += JSON.stringify(token.value !== undefined ? token.value : token) + \"\\n\";\n                var err = new Error(message);\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmVhcmxleS9saWIvbmVhcmxleS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZWFybGV5L2xpYi9uZWFybGV5LmpzP2FjNTUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5uZWFybGV5ID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBSdWxlKG5hbWUsIHN5bWJvbHMsIHBvc3Rwcm9jZXNzKSB7XG4gICAgICAgIHRoaXMuaWQgPSArK1J1bGUuaGlnaGVzdElkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBzeW1ib2xzOyAgICAgICAgLy8gYSBsaXN0IG9mIGxpdGVyYWwgfCByZWdleCBjbGFzcyB8IG5vbnRlcm1pbmFsXG4gICAgICAgIHRoaXMucG9zdHByb2Nlc3MgPSBwb3N0cHJvY2VzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIFJ1bGUuaGlnaGVzdElkID0gMDtcblxuICAgIFJ1bGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24od2l0aEN1cnNvckF0KSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVN5bWJvbFNlcXVlbmNlIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5saXRlcmFsID8gSlNPTi5zdHJpbmdpZnkoZS5saXRlcmFsKSA6XG4gICAgICAgICAgICAgICAgICAgZS50eXBlID8gJyUnICsgZS50eXBlIDogZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeW1ib2xTZXF1ZW5jZSA9ICh0eXBlb2Ygd2l0aEN1cnNvckF0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuc3ltYm9scy5tYXAoc3RyaW5naWZ5U3ltYm9sU2VxdWVuY2UpLmpvaW4oJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICggICB0aGlzLnN5bWJvbHMuc2xpY2UoMCwgd2l0aEN1cnNvckF0KS5tYXAoc3RyaW5naWZ5U3ltYm9sU2VxdWVuY2UpLmpvaW4oJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcIiDil48gXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgdGhpcy5zeW1ib2xzLnNsaWNlKHdpdGhDdXJzb3JBdCkubWFwKHN0cmluZ2lmeVN5bWJvbFNlcXVlbmNlKS5qb2luKCcgJykgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIiDihpIgXCIgKyBzeW1ib2xTZXF1ZW5jZTtcbiAgICB9XG5cblxuICAgIC8vIGEgU3RhdGUgaXMgYSBydWxlIGF0IGEgcG9zaXRpb24gZnJvbSBhIGdpdmVuIHN0YXJ0aW5nIHBvaW50IGluIHRoZSBpbnB1dCBzdHJlYW0gKHJlZmVyZW5jZSlcbiAgICBmdW5jdGlvbiBTdGF0ZShydWxlLCBkb3QsIHJlZmVyZW5jZSwgd2FudGVkQnkpIHtcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcbiAgICAgICAgdGhpcy5kb3QgPSBkb3Q7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy53YW50ZWRCeSA9IHdhbnRlZEJ5O1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0aGlzLmRvdCA9PT0gcnVsZS5zeW1ib2xzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgdGhpcy5ydWxlLnRvU3RyaW5nKHRoaXMuZG90KSArIFwifSwgZnJvbTogXCIgKyAodGhpcy5yZWZlcmVuY2UgfHwgMCk7XG4gICAgfTtcblxuICAgIFN0YXRlLnByb3RvdHlwZS5uZXh0U3RhdGUgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUodGhpcy5ydWxlLCB0aGlzLmRvdCArIDEsIHRoaXMucmVmZXJlbmNlLCB0aGlzLndhbnRlZEJ5KTtcbiAgICAgICAgc3RhdGUubGVmdCA9IHRoaXM7XG4gICAgICAgIHN0YXRlLnJpZ2h0ID0gY2hpbGQ7XG4gICAgICAgIGlmIChzdGF0ZS5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS5kYXRhID0gc3RhdGUuYnVpbGQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcblxuICAgIFN0YXRlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUucmlnaHQuZGF0YSk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICB9IHdoaWxlIChub2RlLmxlZnQpO1xuICAgICAgICBjaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuXG4gICAgU3RhdGUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ydWxlLnBvc3Rwcm9jZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnJ1bGUucG9zdHByb2Nlc3ModGhpcy5kYXRhLCB0aGlzLnJlZmVyZW5jZSwgUGFyc2VyLmZhaWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gQ29sdW1uKGdyYW1tYXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuZ3JhbW1hciA9IGdyYW1tYXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy53YW50cyA9IHt9OyAvLyBzdGF0ZXMgaW5kZXhlZCBieSB0aGUgbm9uLXRlcm1pbmFsIHRoZXkgZXhwZWN0XG4gICAgICAgIHRoaXMuc2Nhbm5hYmxlID0gW107IC8vIGxpc3Qgb2Ygc3RhdGVzIHRoYXQgZXhwZWN0IGEgdG9rZW5cbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB7fTsgLy8gc3RhdGVzIHRoYXQgYXJlIG51bGxhYmxlXG4gICAgfVxuXG5cbiAgICBDb2x1bW4ucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihuZXh0Q29sdW1uKSB7XG4gICAgICAgIHZhciBzdGF0ZXMgPSB0aGlzLnN0YXRlcztcbiAgICAgICAgdmFyIHdhbnRzID0gdGhpcy53YW50cztcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IHRoaXMuY29tcGxldGVkO1xuXG4gICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgc3RhdGVzLmxlbmd0aDsgdysrKSB7IC8vIG5iLiB3ZSBwdXNoKCkgZHVyaW5nIGl0ZXJhdGlvblxuICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVzW3ddO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5kYXRhICE9PSBQYXJzZXIuZmFpbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgd2FudGVkQnkgPSBzdGF0ZS53YW50ZWRCeTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHdhbnRlZEJ5Lmxlbmd0aDsgaS0tOyApIHsgLy8gdGhpcyBsaW5lIGlzIGhvdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSB3YW50ZWRCeVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUobGVmdCwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIG51bGxhYmxlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUucmVmZXJlbmNlID09PSB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgZnV0dXJlIHByZWRpY3RvcnMgb2YgdGhpcyBydWxlIGdldCBjb21wbGV0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwID0gc3RhdGUucnVsZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuY29tcGxldGVkW2V4cF0gPSB0aGlzLmNvbXBsZXRlZFtleHBdIHx8IFtdKS5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZSBzY2FubmFibGUgc3RhdGVzXG4gICAgICAgICAgICAgICAgdmFyIGV4cCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uYWJsZS5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcHJlZGljdFxuICAgICAgICAgICAgICAgIGlmICh3YW50c1tleHBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbnRzW2V4cF0ucHVzaChzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZC5oYXNPd25Qcm9wZXJ0eShleHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVsbHMgPSBjb21wbGV0ZWRbZXhwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBudWxsc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKHN0YXRlLCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YW50c1tleHBdID0gW3N0YXRlXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVkaWN0KGV4cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29sdW1uLnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24oZXhwKSB7XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMuZ3JhbW1hci5ieU5hbWVbZXhwXSB8fCBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgciA9IHJ1bGVzW2ldO1xuICAgICAgICAgICAgdmFyIHdhbnRlZEJ5ID0gdGhpcy53YW50c1tleHBdO1xuICAgICAgICAgICAgdmFyIHMgPSBuZXcgU3RhdGUociwgMCwgdGhpcy5pbmRleCwgd2FudGVkQnkpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaChzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbHVtbi5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgY29weSA9IGxlZnQubmV4dFN0YXRlKHJpZ2h0KTtcbiAgICAgICAgdGhpcy5zdGF0ZXMucHVzaChjb3B5KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIEdyYW1tYXIocnVsZXMsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0IHx8IHRoaXMucnVsZXNbMF0ubmFtZTtcbiAgICAgICAgdmFyIGJ5TmFtZSA9IHRoaXMuYnlOYW1lID0ge307XG4gICAgICAgIHRoaXMucnVsZXMuZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICBpZiAoIWJ5TmFtZS5oYXNPd25Qcm9wZXJ0eShydWxlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYnlOYW1lW3J1bGUubmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5TmFtZVtydWxlLm5hbWVdLnB1c2gocnVsZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNvIHdlIGNhbiBhbGxvdyBwYXNzaW5nIChydWxlcywgc3RhcnQpIGRpcmVjdGx5IHRvIFBhcnNlciBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBHcmFtbWFyLmZyb21Db21waWxlZCA9IGZ1bmN0aW9uKHJ1bGVzLCBzdGFydCkge1xuICAgICAgICB2YXIgbGV4ZXIgPSBydWxlcy5MZXhlcjtcbiAgICAgICAgaWYgKHJ1bGVzLlBhcnNlclN0YXJ0KSB7XG4gICAgICAgICAgc3RhcnQgPSBydWxlcy5QYXJzZXJTdGFydDtcbiAgICAgICAgICBydWxlcyA9IHJ1bGVzLlBhcnNlclJ1bGVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlcyA9IHJ1bGVzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gKG5ldyBSdWxlKHIubmFtZSwgci5zeW1ib2xzLCByLnBvc3Rwcm9jZXNzKSk7IH0pO1xuICAgICAgICB2YXIgZyA9IG5ldyBHcmFtbWFyKHJ1bGVzLCBzdGFydCk7XG4gICAgICAgIGcubGV4ZXIgPSBsZXhlcjsgLy8gbmIuIHN0b3JpbmcgbGV4ZXIgb24gR3JhbW1hciBpcyBpZmZ5LCBidXQgdW5hdm9pZGFibGVcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBTdHJlYW1MZXhlcigpIHtcbiAgICAgIHRoaXMucmVzZXQoXCJcIik7XG4gICAgfVxuXG4gICAgU3RyZWFtTGV4ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oZGF0YSwgc3RhdGUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBkYXRhO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5saW5lID0gc3RhdGUgPyBzdGF0ZS5saW5lIDogMTtcbiAgICAgICAgdGhpcy5sYXN0TGluZUJyZWFrID0gc3RhdGUgPyAtc3RhdGUuY29sIDogMDtcbiAgICB9XG5cbiAgICBTdHJlYW1MZXhlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5idWZmZXJbdGhpcy5pbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5saW5lICs9IDE7XG4gICAgICAgICAgICAgIHRoaXMubGFzdExpbmVCcmVhayA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlOiBjaH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTdHJlYW1MZXhlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICBjb2w6IHRoaXMuaW5kZXggLSB0aGlzLmxhc3RMaW5lQnJlYWssXG4gICAgICB9XG4gICAgfVxuXG4gICAgU3RyZWFtTGV4ZXIucHJvdG90eXBlLmZvcm1hdEVycm9yID0gZnVuY3Rpb24odG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gbmIuIHRoaXMgZ2V0cyBjYWxsZWQgYWZ0ZXIgY29uc3VtaW5nIHRoZSBvZmZlbmRpbmcgdG9rZW4sXG4gICAgICAgIC8vIHNvIHRoZSBjdWxwcml0IGlzIGluZGV4LTFcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGluZUJyZWFrID0gYnVmZmVyLmluZGV4T2YoJ1xcbicsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG5leHRMaW5lQnJlYWsgPT09IC0xKSBuZXh0TGluZUJyZWFrID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cmluZyh0aGlzLmxhc3RMaW5lQnJlYWssIG5leHRMaW5lQnJlYWspXG4gICAgICAgICAgICB2YXIgY29sID0gdGhpcy5pbmRleCAtIHRoaXMubGFzdExpbmVCcmVhaztcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgYXQgbGluZSBcIiArIHRoaXMubGluZSArIFwiIGNvbCBcIiArIGNvbCArIFwiOlxcblxcblwiO1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAgXCIgKyBsaW5lICsgXCJcXG5cIlxuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAgXCIgKyBBcnJheShjb2wpLmpvaW4oXCIgXCIpICsgXCJeXCJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UgKyBcIiBhdCBpbmRleCBcIiArICh0aGlzLmluZGV4IC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIFBhcnNlcihydWxlcywgc3RhcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHJ1bGVzIGluc3RhbmNlb2YgR3JhbW1hcikge1xuICAgICAgICAgICAgdmFyIGdyYW1tYXIgPSBydWxlcztcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ3JhbW1hciA9IEdyYW1tYXIuZnJvbUNvbXBpbGVkKHJ1bGVzLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFtbWFyID0gZ3JhbW1hcjtcblxuICAgICAgICAvLyBSZWFkIG9wdGlvbnNcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAga2VlcEhpc3Rvcnk6IGZhbHNlLFxuICAgICAgICAgICAgbGV4ZXI6IGdyYW1tYXIubGV4ZXIgfHwgbmV3IFN0cmVhbUxleGVyLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gKG9wdGlvbnMgfHwge30pKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHVwIGxleGVyXG4gICAgICAgIHRoaXMubGV4ZXIgPSB0aGlzLm9wdGlvbnMubGV4ZXI7XG4gICAgICAgIHRoaXMubGV4ZXJTdGF0ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBTZXR1cCBhIHRhYmxlXG4gICAgICAgIHZhciBjb2x1bW4gPSBuZXcgQ29sdW1uKGdyYW1tYXIsIDApO1xuICAgICAgICB2YXIgdGFibGUgPSB0aGlzLnRhYmxlID0gW2NvbHVtbl07XG5cbiAgICAgICAgLy8gSSBjb3VsZCBiZSBleHBlY3RpbmcgYW55dGhpbmcuXG4gICAgICAgIGNvbHVtbi53YW50c1tncmFtbWFyLnN0YXJ0XSA9IFtdO1xuICAgICAgICBjb2x1bW4ucHJlZGljdChncmFtbWFyLnN0YXJ0KTtcbiAgICAgICAgLy8gVE9ETyB3aGF0IGlmIHN0YXJ0IHJ1bGUgaXMgbnVsbGFibGU/XG4gICAgICAgIGNvbHVtbi5wcm9jZXNzKCk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IDA7IC8vIHRva2VuIGluZGV4XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgcmVzZXJ2ZWQgdG9rZW4gZm9yIGluZGljYXRpbmcgYSBwYXJzZSBmYWlsXG4gICAgUGFyc2VyLmZhaWwgPSB7fTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUuZmVlZCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHZhciBsZXhlciA9IHRoaXMubGV4ZXI7XG4gICAgICAgIGxleGVyLnJlc2V0KGNodW5rLCB0aGlzLmxleGVyU3RhdGUpO1xuXG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgd2hpbGUgKHRva2VuID0gbGV4ZXIubmV4dCgpKSB7XG4gICAgICAgICAgICAvLyBXZSBhZGQgbmV3IHN0YXRlcyB0byB0YWJsZVtjdXJyZW50KzFdXG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy50YWJsZVt0aGlzLmN1cnJlbnRdO1xuXG4gICAgICAgICAgICAvLyBHQyB1bnVzZWQgc3RhdGVzXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5rZWVwSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhYmxlW3RoaXMuY3VycmVudCAtIDFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuY3VycmVudCArIDE7XG4gICAgICAgICAgICB2YXIgbmV4dENvbHVtbiA9IG5ldyBDb2x1bW4odGhpcy5ncmFtbWFyLCBuKTtcbiAgICAgICAgICAgIHRoaXMudGFibGUucHVzaChuZXh0Q29sdW1uKTtcblxuICAgICAgICAgICAgLy8gQWR2YW5jZSBhbGwgdG9rZW5zIHRoYXQgZXhwZWN0IHRoZSBzeW1ib2xcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsZXhlci5jb25zdHJ1Y3RvciA9PT0gU3RyZWFtTGV4ZXIgPyB0b2tlbi52YWx1ZSA6IHRva2VuO1xuICAgICAgICAgICAgdmFyIHNjYW5uYWJsZSA9IGNvbHVtbi5zY2FubmFibGU7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gc2Nhbm5hYmxlLmxlbmd0aDsgdy0tOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzY2FubmFibGVbd107XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdCA9IHN0YXRlLnJ1bGUuc3ltYm9sc1tzdGF0ZS5kb3RdO1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjb25zdW1lIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgIC8vIGVpdGhlciByZWdleCBvciBsaXRlcmFsXG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdC50ZXN0ID8gZXhwZWN0LnRlc3QodmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0LnR5cGUgPyBleHBlY3QudHlwZSA9PT0gdG9rZW4udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV4cGVjdC5saXRlcmFsID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHN0YXRlLm5leHRTdGF0ZSh7ZGF0YTogdmFsdWUsIHRva2VuOiB0b2tlbiwgaXNUb2tlbjogdHJ1ZSwgcmVmZXJlbmNlOiBuIC0gMX0pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q29sdW1uLnN0YXRlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV4dCwgZm9yIGVhY2ggb2YgdGhlIHJ1bGVzLCB3ZSBlaXRoZXJcbiAgICAgICAgICAgIC8vIChhKSBjb21wbGV0ZSBpdCwgYW5kIHRyeSB0byBzZWUgaWYgdGhlIHJlZmVyZW5jZSByb3cgZXhwZWN0ZWQgdGhhdFxuICAgICAgICAgICAgLy8gICAgIHJ1bGVcbiAgICAgICAgICAgIC8vIChiKSBwcmVkaWN0IHRoZSBuZXh0IG5vbnRlcm1pbmFsIGl0IGV4cGVjdHMgYnkgYWRkaW5nIHRoYXRcbiAgICAgICAgICAgIC8vICAgICBub250ZXJtaW5hbCdzIHN0YXJ0IHN0YXRlXG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0aW9uLCB3ZSBhbHNvIGtlZXAgdHJhY2sgb2YgcnVsZXMgd2UgaGF2ZSBhbHJlYWR5XG4gICAgICAgICAgICAvLyBhZGRlZFxuXG4gICAgICAgICAgICBuZXh0Q29sdW1uLnByb2Nlc3MoKTtcblxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkLCB0aHJvdyBhbiBlcnJvcjpcbiAgICAgICAgICAgIGlmIChuZXh0Q29sdW1uLnN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzdGF0ZXMgYXQgYWxsISBUaGlzIGlzIG5vdCBnb29kLlxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sZXhlci5mb3JtYXRFcnJvcih0b2tlbiwgXCJpbnZhbGlkIHN5bnRheFwiKSArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIlVuZXhwZWN0ZWQgXCIgKyAodG9rZW4udHlwZSA/IHRva2VuLnR5cGUgKyBcIiB0b2tlbjogXCIgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IEpTT04uc3RyaW5naWZ5KHRva2VuLnZhbHVlICE9PSB1bmRlZmluZWQgPyB0b2tlbi52YWx1ZSA6IHRva2VuKSArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBlcnIub2Zmc2V0ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGVyci50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWF5YmUgc2F2ZSBsZXhlciBzdGF0ZVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwSGlzdG9yeSkge1xuICAgICAgICAgICAgICBjb2x1bW4ubGV4ZXJTdGF0ZSA9IGxleGVyLnNhdmUoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgdGhpcy5sZXhlclN0YXRlID0gbGV4ZXIuc2F2ZSgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmNyZW1lbnRhbGx5IGtlZXAgdHJhY2sgb2YgcmVzdWx0c1xuICAgICAgICB0aGlzLnJlc3VsdHMgPSB0aGlzLmZpbmlzaCgpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nLCBmb3Igd2hhdGV2ZXIgaXQncyB3b3J0aFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnRhYmxlW3RoaXMuY3VycmVudF07XG4gICAgICAgIGNvbHVtbi5sZXhlclN0YXRlID0gdGhpcy5sZXhlclN0YXRlO1xuICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY29sdW1uLmluZGV4O1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgICAgdGhpcy50YWJsZVtpbmRleF0gPSBjb2x1bW47XG4gICAgICAgIHRoaXMudGFibGUuc3BsaWNlKGluZGV4ICsgMSk7XG4gICAgICAgIHRoaXMubGV4ZXJTdGF0ZSA9IGNvbHVtbi5sZXhlclN0YXRlO1xuXG4gICAgICAgIC8vIEluY3JlbWVudGFsbHkga2VlcCB0cmFjayBvZiByZXN1bHRzXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMuZmluaXNoKCk7XG4gICAgfTtcblxuICAgIC8vIG5iLiBkZXByZWNhdGVkOiB1c2Ugc2F2ZS9yZXN0b3JlIGluc3RlYWQhXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXdpbmQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5rZWVwSGlzdG9yeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgb3B0aW9uIGBrZWVwSGlzdG9yeWAgdG8gZW5hYmxlIHJld2luZGluZycpXG4gICAgICAgIH1cbiAgICAgICAgLy8gbmIuIHJlY2FsbCBjb2x1bW4gKHRhYmxlKSBpbmRpY2llcyBmYWxsIGJldHdlZW4gdG9rZW4gaW5kaWNpZXMuXG4gICAgICAgIC8vICAgICAgICBjb2wgMCAgIC0tICAgdG9rZW4gMCAgIC0tICAgY29sIDFcbiAgICAgICAgdGhpcy5yZXN0b3JlKHRoaXMudGFibGVbaW5kZXhdKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwb3NzaWJsZSBwYXJzaW5nc1xuICAgICAgICB2YXIgY29uc2lkZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ncmFtbWFyLnN0YXJ0O1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy50YWJsZVt0aGlzLnRhYmxlLmxlbmd0aCAtIDFdXG4gICAgICAgIGNvbHVtbi5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgaWYgKHQucnVsZS5uYW1lID09PSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAmJiB0LmRvdCA9PT0gdC5ydWxlLnN5bWJvbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICYmIHQucmVmZXJlbmNlID09PSAwXG4gICAgICAgICAgICAgICAgICAgICYmIHQuZGF0YSAhPT0gUGFyc2VyLmZhaWwpIHtcbiAgICAgICAgICAgICAgICBjb25zaWRlcmF0aW9ucy5wdXNoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnNpZGVyYXRpb25zLm1hcChmdW5jdGlvbihjKSB7cmV0dXJuIGMuZGF0YTsgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIFBhcnNlcjogUGFyc2VyLFxuICAgICAgICBHcmFtbWFyOiBHcmFtbWFyLFxuICAgICAgICBSdWxlOiBSdWxlLFxuICAgIH07XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nearley/lib/nearley.js\n");

/***/ }),

/***/ "./out/grammar/grammar.js":
/*!********************************!*\
  !*** ./out/grammar/grammar.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated automatically by nearley, version 2.13.0\n// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\nvar grammar = {\n    Lexer: undefined,\n    ParserRules: [\n    {\"name\": \"MAIN\", \"symbols\": [\"description\"], \"postprocess\": id},\n    {\"name\": \"description$ebnf$1$subexpression$1\", \"symbols\": [\"config\", \"whsp\"]},\n    {\"name\": \"description$ebnf$1\", \"symbols\": [\"description$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"description$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"description\", \"symbols\": [\"description$ebnf$1\", \"elements\"], \"postprocess\": function(d) { return {config: d[0] !== null ? d[0][0] : [], elements: d[1]}; }},\n    {\"name\": \"config$ebnf$1$subexpression$1\", \"symbols\": [\"sep\", \"config\"]},\n    {\"name\": \"config$ebnf$1\", \"symbols\": [\"config$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"config$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"config\", \"symbols\": [\"config_entry\", \"config$ebnf$1\"], \"postprocess\": function(d) { return [d[0]].concat(d[1] !== null ? d[1][1] : []); }},\n    {\"name\": \"config_entry\", \"symbols\": [\"name\", {\"literal\":\"=\"}, \"minus_string\"], \"postprocess\": function(d) { return {key: d[0], value: d[2]}; }},\n    {\"name\": \"elements$ebnf$1$subexpression$1\", \"symbols\": [\"whsp\", \"elements\"]},\n    {\"name\": \"elements$ebnf$1\", \"symbols\": [\"elements$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"elements$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"elements\", \"symbols\": [\"element\", \"elements$ebnf$1\"], \"postprocess\": function(d) { return [d[0]].concat(d[1] ? d[1][1] : []); }},\n    {\"name\": \"sep\", \"symbols\": [{\"literal\":\" \"}]},\n    {\"name\": \"sep\", \"symbols\": [{\"literal\":\"\\t\"}]},\n    {\"name\": \"sep\", \"symbols\": [{\"literal\":\"*\"}]},\n    {\"name\": \"sep\", \"symbols\": [{\"literal\":\"\\n\"}]},\n    {\"name\": \"optsep\", \"symbols\": []},\n    {\"name\": \"optsep\", \"symbols\": [\"sep\"]},\n    {\"name\": \"whsp$string$1\", \"symbols\": [{\"literal\":\" \"}, {\"literal\":\" \"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"whsp\", \"symbols\": [\"whsp$string$1\"]},\n    {\"name\": \"whsp$string$2\", \"symbols\": [{\"literal\":\"*\"}, {\"literal\":\"*\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"whsp\", \"symbols\": [\"whsp$string$2\"]},\n    {\"name\": \"whsp$string$3\", \"symbols\": [{\"literal\":\"\\t\"}, {\"literal\":\"\\t\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"whsp\", \"symbols\": [\"whsp$string$3\"]},\n    {\"name\": \"whsp$string$4\", \"symbols\": [{\"literal\":\"\\n\"}, {\"literal\":\"\\n\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"whsp\", \"symbols\": [\"whsp$string$4\"]},\n    {\"name\": \"element\", \"symbols\": [\"name\", \"sep\", \"type\", \"params\", \"sep\", \"base\", \"outside_inputs\", \"outside_outputs\", \"wires\"], \"postprocess\":  function(d) {\n        \treturn {\n        \t\tname: d[0],\n        \t\ttype: d[2],\n        \t\tparameters: d[3],\n        \t\tbase: d[5],\n        \t\toutsideInputs: d[6],\n        \t\texternalOutputs: d[7],\n        \t\twires: d[8]\n        \t};\n        } },\n    {\"name\": \"name$ebnf$1\", \"symbols\": [\"string\"], \"postprocess\": id},\n    {\"name\": \"name$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"name\", \"symbols\": [/[a-z]/, \"name$ebnf$1\"], \"postprocess\": function(d) { return d[0] + (d[1] || \"\"); }},\n    {\"name\": \"type\", \"symbols\": [\"name\"], \"postprocess\": id},\n    {\"name\": \"string$ebnf$1\", \"symbols\": [/[a-zA-Z0-9_]/]},\n    {\"name\": \"string$ebnf$1\", \"symbols\": [\"string$ebnf$1\", /[a-zA-Z0-9_]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"string\", \"symbols\": [\"string$ebnf$1\"], \"postprocess\": function(d) { return d[0].join(\"\"); }},\n    {\"name\": \"minus_string$ebnf$1\", \"symbols\": [/[a-zA-Z0-9_-]/]},\n    {\"name\": \"minus_string$ebnf$1\", \"symbols\": [\"minus_string$ebnf$1\", /[a-zA-Z0-9_-]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"minus_string\", \"symbols\": [\"minus_string$ebnf$1\"], \"postprocess\": function(d) { return d[0].join(\"\"); }},\n    {\"name\": \"params$ebnf$1\", \"symbols\": []},\n    {\"name\": \"params$ebnf$1$subexpression$1\", \"symbols\": [\"sep\", \"params_init\"], \"postprocess\": function(d) { return d[1]; }},\n    {\"name\": \"params$ebnf$1\", \"symbols\": [\"params$ebnf$1\", \"params$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"params\", \"symbols\": [\"params$ebnf$1\"], \"postprocess\": id},\n    {\"name\": \"params_init\", \"symbols\": [\"name\", \"optsep\", {\"literal\":\"=\"}, \"optsep\", \"string\"], \"postprocess\": function(d) { return {key: d[0], value: d[4]}; }},\n    {\"name\": \"base$ebnf$1\", \"symbols\": [\"local_connector\"], \"postprocess\": id},\n    {\"name\": \"base$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"base\", \"symbols\": [\"base$ebnf$1\", {\"literal\":\"@\"}, \"coordinates_remote\"], \"postprocess\": function(d) { return d[0] ? {base: d[0], coordinates: d[2]} : d[2]; }},\n    {\"name\": \"connector_type$subexpression$1\", \"symbols\": [{\"literal\":\"i\"}]},\n    {\"name\": \"connector_type$subexpression$1\", \"symbols\": [{\"literal\":\"o\"}]},\n    {\"name\": \"connector_type\", \"symbols\": [\"connector_type$subexpression$1\"], \"postprocess\": function(d) { return d[0][0] === \"i\" ? \"input\" : \"output\"; }},\n    {\"name\": \"local_connector\", \"symbols\": [\"connector_type\", \"uint\"], \"postprocess\": function(d) { return {connector: d[0], index: d[1] }; }},\n    {\"name\": \"remote_connector\", \"symbols\": [\"name\", {\"literal\":\"/\"}, \"local_connector\"], \"postprocess\": function(d) { return {name: d[0], connector: d[2].connector, index: d[2].index}; }},\n    {\"name\": \"coordinates_remote$subexpression$1\", \"symbols\": [\"coordinates_remote_separate\"]},\n    {\"name\": \"coordinates_remote$subexpression$1\", \"symbols\": [\"remote_connector\"]},\n    {\"name\": \"coordinates_remote\", \"symbols\": [\"coordinates_remote$subexpression$1\"], \"postprocess\": function(d) { return d[0][0]; }},\n    {\"name\": \"coordinates_remote_separate$subexpression$1\", \"symbols\": [\"coordinate_remote\", {\"literal\":\":\"}, \"coordinate_remote\"]},\n    {\"name\": \"coordinates_remote_separate\", \"symbols\": [\"coordinates_remote_separate$subexpression$1\"], \"postprocess\": function(d) { return {x: d[0][0], y: d[0][2]}; }},\n    {\"name\": \"coordinate_remote$subexpression$1\", \"symbols\": [\"coordinate\"]},\n    {\"name\": \"coordinate_remote$subexpression$1\", \"symbols\": [\"remote_connector\"]},\n    {\"name\": \"coordinate_remote$subexpression$1\", \"symbols\": [\"remote_connector_delta\"]},\n    {\"name\": \"coordinate_remote\", \"symbols\": [\"coordinate_remote$subexpression$1\"], \"postprocess\": function(d) { return d[0][0]; }},\n    {\"name\": \"remote_connector_delta\", \"symbols\": [\"remote_connector\", \"coordinate_delta\"], \"postprocess\": function(d) { return {delta: d[1], from: d[0]}; }},\n    {\"name\": \"coordinates_reference$subexpression$1\", \"symbols\": [\"coordinates_reference_separate\"]},\n    {\"name\": \"coordinates_reference$subexpression$1\", \"symbols\": [\"remote_connector\"]},\n    {\"name\": \"coordinates_reference\", \"symbols\": [\"coordinates_reference$subexpression$1\"], \"postprocess\": function(d) { return d[0][0]; }},\n    {\"name\": \"coordinates_reference_separate$subexpression$1\", \"symbols\": [\"coordinate_reference\", {\"literal\":\":\"}, \"coordinate_reference\"]},\n    {\"name\": \"coordinates_reference_separate\", \"symbols\": [\"coordinates_reference_separate$subexpression$1\"], \"postprocess\": function(d) { return {x: d[0][0], y: d[0][2]}; }},\n    {\"name\": \"coordinate_reference$subexpression$1\", \"symbols\": [\"coordinate_remote\"]},\n    {\"name\": \"coordinate_reference$subexpression$1\", \"symbols\": [\"coordinate_reference_base\"]},\n    {\"name\": \"coordinate_reference$subexpression$1\", \"symbols\": [\"coordinate_reference_base_delta\"]},\n    {\"name\": \"coordinate_reference\", \"symbols\": [\"coordinate_reference$subexpression$1\"], \"postprocess\": function(d) { return d[0][0]; }},\n    {\"name\": \"coordinate_reference_base_delta\", \"symbols\": [\"coordinate_reference_base\", \"coordinate_delta\"], \"postprocess\": function(d) { return {delta: d[1], from: d[0]}; }},\n    {\"name\": \"coordinate_reference_base$subexpression$1\", \"symbols\": [{\"literal\":\"p\"}]},\n    {\"name\": \"coordinate_reference_base$subexpression$1\", \"symbols\": [{\"literal\":\"n\"}]},\n    {\"name\": \"coordinate_reference_base\", \"symbols\": [\"coordinate_reference_base$subexpression$1\"], \"postprocess\": function(d) { return d[0][0] === \"n\" ? \"next\" : \"prev\"; }},\n    {\"name\": \"coordinate_delta$subexpression$1\", \"symbols\": [{\"literal\":\"+\"}]},\n    {\"name\": \"coordinate_delta$subexpression$1\", \"symbols\": [{\"literal\":\"-\"}]},\n    {\"name\": \"coordinate_delta\", \"symbols\": [\"coordinate_delta$subexpression$1\", \"uint\"], \"postprocess\": function(d) { return d[0][0] === \"-\" ? -1*d[1] : d[1]; }},\n    {\"name\": \"coordinate\", \"symbols\": [\"uint\"], \"postprocess\": id},\n    {\"name\": \"outside_inputs$ebnf$1\", \"symbols\": []},\n    {\"name\": \"outside_inputs$ebnf$1$subexpression$1\", \"symbols\": [\"sep\", \"outside_input_init\"], \"postprocess\": function(d) { return d[1]; }},\n    {\"name\": \"outside_inputs$ebnf$1\", \"symbols\": [\"outside_inputs$ebnf$1\", \"outside_inputs$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"outside_inputs\", \"symbols\": [\"outside_inputs$ebnf$1\"], \"postprocess\": id},\n    {\"name\": \"outside_input_init$ebnf$1$subexpression$1\", \"symbols\": [\"uint\", \"optsep\"]},\n    {\"name\": \"outside_input_init$ebnf$1\", \"symbols\": [\"outside_input_init$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"outside_input_init$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"outside_input_init$ebnf$2$subexpression$1\", \"symbols\": [{\"literal\":\"+\"}, \"uint\"]},\n    {\"name\": \"outside_input_init$ebnf$2\", \"symbols\": [\"outside_input_init$ebnf$2$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"outside_input_init$ebnf$2\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"outside_input_init\", \"symbols\": [\"outside_input_init$ebnf$1\", {\"literal\":\"<\"}, \"optsep\", \"uint\", \"outside_input_init$ebnf$2\"], \"postprocess\": function(d) { return {inputIndex: d[0] !== null ? d[0][0] : null, outputIndex: d[3], more: d[4] !== null ? d[4][1] : 0}; }},\n    {\"name\": \"outside_outputs$ebnf$1\", \"symbols\": []},\n    {\"name\": \"outside_outputs$ebnf$1$subexpression$1\", \"symbols\": [\"sep\", \"outside_output_init\"], \"postprocess\": function(d) { return d[1]; }},\n    {\"name\": \"outside_outputs$ebnf$1\", \"symbols\": [\"outside_outputs$ebnf$1\", \"outside_outputs$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"outside_outputs\", \"symbols\": [\"outside_outputs$ebnf$1\"], \"postprocess\": id},\n    {\"name\": \"outside_output_init$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"+\"}, \"uint\"]},\n    {\"name\": \"outside_output_init$ebnf$1\", \"symbols\": [\"outside_output_init$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"outside_output_init$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"outside_output_init$string$1\", \"symbols\": [{\"literal\":\">\"}, {\"literal\":\">\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"outside_output_init\", \"symbols\": [\"uint\", \"outside_output_init$ebnf$1\", \"optsep\", \"outside_output_init$string$1\"], \"postprocess\": function(d) { return {outputIndex: d[0], more: d[1] !== null ? d[1][1] : 0}; }},\n    {\"name\": \"wires$ebnf$1\", \"symbols\": []},\n    {\"name\": \"wires$ebnf$1$subexpression$1\", \"symbols\": [\"sep\", \"wire_init\"], \"postprocess\": function(d) { return d[1]; }},\n    {\"name\": \"wires$ebnf$1\", \"symbols\": [\"wires$ebnf$1\", \"wires$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"wires\", \"symbols\": [\"wires$ebnf$1\"], \"postprocess\": id},\n    {\"name\": \"wire_init$ebnf$1\", \"symbols\": [\"wire_output\"], \"postprocess\": id},\n    {\"name\": \"wire_init$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"wire_init$ebnf$2$subexpression$1$subexpression$1$string$1\", \"symbols\": [{\"literal\":\"t\"}, {\"literal\":\"r\"}, {\"literal\":\"u\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"wire_init$ebnf$2$subexpression$1$subexpression$1\", \"symbols\": [\"wire_init$ebnf$2$subexpression$1$subexpression$1$string$1\"]},\n    {\"name\": \"wire_init$ebnf$2$subexpression$1$subexpression$1$string$2\", \"symbols\": [{\"literal\":\"f\"}, {\"literal\":\"a\"}, {\"literal\":\"l\"}, {\"literal\":\"s\"}, {\"literal\":\"e\"}], \"postprocess\": function joiner(d) {return d.join('');}},\n    {\"name\": \"wire_init$ebnf$2$subexpression$1$subexpression$1\", \"symbols\": [\"wire_init$ebnf$2$subexpression$1$subexpression$1$string$2\"]},\n    {\"name\": \"wire_init$ebnf$2$subexpression$1\", \"symbols\": [{\"literal\":\"=\"}, \"wire_init$ebnf$2$subexpression$1$subexpression$1\"]},\n    {\"name\": \"wire_init$ebnf$2\", \"symbols\": [\"wire_init$ebnf$2$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"wire_init$ebnf$2\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"wire_init\", \"symbols\": [\"wire_init$ebnf$1\", \"wire\", \"wire_init$ebnf$2\"], \"postprocess\": function(d) { return {outputIndex: d[0] && d[0].outputIndex, more: d[0] && d[0].more, coordinates: d[1], initialValue: d[2] && d[2][1][0] === \"true\"}; }},\n    {\"name\": \"wire_output$ebnf$1$subexpression$1$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"+\"}, \"uint\"]},\n    {\"name\": \"wire_output$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [\"wire_output$ebnf$1$subexpression$1$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"wire_output$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"wire_output$ebnf$1$subexpression$1\", \"symbols\": [\"uint\", \"wire_output$ebnf$1$subexpression$1$ebnf$1\"]},\n    {\"name\": \"wire_output$ebnf$1\", \"symbols\": [\"wire_output$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"wire_output$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"wire_output$subexpression$1\", \"symbols\": [{\"literal\":\">\"}]},\n    {\"name\": \"wire_output$subexpression$1\", \"symbols\": [{\"literal\":\"~\"}]},\n    {\"name\": \"wire_output\", \"symbols\": [\"wire_output$ebnf$1\", \"wire_output$subexpression$1\"], \"postprocess\": function(d) { return {outputIndex: d[0] && d[0][0], more: d[0] && d[0][1] !== null ? d[0][1][1] : 0}; }},\n    {\"name\": \"wire$subexpression$1\", \"symbols\": [\"wire_point\"]},\n    {\"name\": \"wire$subexpression$1\", \"symbols\": [\"wire_terminal\"]},\n    {\"name\": \"wire\", \"symbols\": [\"wire$subexpression$1\"], \"postprocess\": function(d) { return d[0][0]; }},\n    {\"name\": \"wire_point$ebnf$1$subexpression$1\", \"symbols\": [{\"literal\":\"~\"}, \"wire\"]},\n    {\"name\": \"wire_point$ebnf$1\", \"symbols\": [\"wire_point$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"wire_point$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"wire_point\", \"symbols\": [\"coordinates_reference\", \"wire_point$ebnf$1\"], \"postprocess\": function(d) { return [d[0]].concat(d[1] ? d[1][1] : []); }},\n    {\"name\": \"wire_terminal\", \"symbols\": [\"name\"], \"postprocess\": function(d) { return [{name: d[0], connector: \"input\", index: null}]; }},\n    {\"name\": \"uint$ebnf$1\", \"symbols\": [/[0-9]/]},\n    {\"name\": \"uint$ebnf$1\", \"symbols\": [\"uint$ebnf$1\", /[0-9]/], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"uint\", \"symbols\": [\"uint$ebnf$1\"], \"postprocess\": function(d) { return parseInt(d[0].join(\"\")); }}\n]\n  , ParserStart: \"MAIN\"\n}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window.grammar = grammar;\n}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvZ3JhbW1hci9ncmFtbWFyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2dyYW1tYXIvZ3JhbW1hci5qcz80YTY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGJ5IG5lYXJsZXksIHZlcnNpb24gMi4xMy4wXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9IYXJkbWF0aDEyMy9uZWFybGV5XG4oZnVuY3Rpb24gKCkge1xuZnVuY3Rpb24gaWQoeCkgeyByZXR1cm4geFswXTsgfVxudmFyIGdyYW1tYXIgPSB7XG4gICAgTGV4ZXI6IHVuZGVmaW5lZCxcbiAgICBQYXJzZXJSdWxlczogW1xuICAgIHtcIm5hbWVcIjogXCJNQUlOXCIsIFwic3ltYm9sc1wiOiBbXCJkZXNjcmlwdGlvblwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImRlc2NyaXB0aW9uJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcImNvbmZpZ1wiLCBcIndoc3BcIl19LFxuICAgIHtcIm5hbWVcIjogXCJkZXNjcmlwdGlvbiRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcImRlc2NyaXB0aW9uJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJkZXNjcmlwdGlvbiRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHtyZXR1cm4gbnVsbDt9fSxcbiAgICB7XCJuYW1lXCI6IFwiZGVzY3JpcHRpb25cIiwgXCJzeW1ib2xzXCI6IFtcImRlc2NyaXB0aW9uJGVibmYkMVwiLCBcImVsZW1lbnRzXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHtjb25maWc6IGRbMF0gIT09IG51bGwgPyBkWzBdWzBdIDogW10sIGVsZW1lbnRzOiBkWzFdfTsgfX0sXG4gICAge1wibmFtZVwiOiBcImNvbmZpZyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJzZXBcIiwgXCJjb25maWdcIl19LFxuICAgIHtcIm5hbWVcIjogXCJjb25maWckZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJjb25maWckZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImNvbmZpZyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHtyZXR1cm4gbnVsbDt9fSxcbiAgICB7XCJuYW1lXCI6IFwiY29uZmlnXCIsIFwic3ltYm9sc1wiOiBbXCJjb25maWdfZW50cnlcIiwgXCJjb25maWckZWJuZiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFtkWzBdXS5jb25jYXQoZFsxXSAhPT0gbnVsbCA/IGRbMV1bMV0gOiBbXSk7IH19LFxuICAgIHtcIm5hbWVcIjogXCJjb25maWdfZW50cnlcIiwgXCJzeW1ib2xzXCI6IFtcIm5hbWVcIiwge1wibGl0ZXJhbFwiOlwiPVwifSwgXCJtaW51c19zdHJpbmdcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4ge2tleTogZFswXSwgdmFsdWU6IGRbMl19OyB9fSxcbiAgICB7XCJuYW1lXCI6IFwiZWxlbWVudHMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wid2hzcFwiLCBcImVsZW1lbnRzXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwiZWxlbWVudHMkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJlbGVtZW50cyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwiZWxlbWVudHMkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7cmV0dXJuIG51bGw7fX0sXG4gICAge1wibmFtZVwiOiBcImVsZW1lbnRzXCIsIFwic3ltYm9sc1wiOiBbXCJlbGVtZW50XCIsIFwiZWxlbWVudHMkZWJuZiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFtkWzBdXS5jb25jYXQoZFsxXSA/IGRbMV1bMV0gOiBbXSk7IH19LFxuICAgIHtcIm5hbWVcIjogXCJzZXBcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIgXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInNlcFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIlxcdFwifV19LFxuICAgIHtcIm5hbWVcIjogXCJzZXBcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIqXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcInNlcFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIlxcblwifV19LFxuICAgIHtcIm5hbWVcIjogXCJvcHRzZXBcIiwgXCJzeW1ib2xzXCI6IFtdfSxcbiAgICB7XCJuYW1lXCI6IFwib3B0c2VwXCIsIFwic3ltYm9sc1wiOiBbXCJzZXBcIl19LFxuICAgIHtcIm5hbWVcIjogXCJ3aHNwJHN0cmluZyQxXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiIFwifSwge1wibGl0ZXJhbFwiOlwiIFwifV0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24gam9pbmVyKGQpIHtyZXR1cm4gZC5qb2luKCcnKTt9fSxcbiAgICB7XCJuYW1lXCI6IFwid2hzcFwiLCBcInN5bWJvbHNcIjogW1wid2hzcCRzdHJpbmckMVwiXX0sXG4gICAge1wibmFtZVwiOiBcIndoc3Akc3RyaW5nJDJcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIqXCJ9LCB7XCJsaXRlcmFsXCI6XCIqXCJ9XSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiBqb2luZXIoZCkge3JldHVybiBkLmpvaW4oJycpO319LFxuICAgIHtcIm5hbWVcIjogXCJ3aHNwXCIsIFwic3ltYm9sc1wiOiBbXCJ3aHNwJHN0cmluZyQyXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwid2hzcCRzdHJpbmckM1wiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIlxcdFwifSwge1wibGl0ZXJhbFwiOlwiXFx0XCJ9XSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiBqb2luZXIoZCkge3JldHVybiBkLmpvaW4oJycpO319LFxuICAgIHtcIm5hbWVcIjogXCJ3aHNwXCIsIFwic3ltYm9sc1wiOiBbXCJ3aHNwJHN0cmluZyQzXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwid2hzcCRzdHJpbmckNFwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIlxcblwifSwge1wibGl0ZXJhbFwiOlwiXFxuXCJ9XSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiBqb2luZXIoZCkge3JldHVybiBkLmpvaW4oJycpO319LFxuICAgIHtcIm5hbWVcIjogXCJ3aHNwXCIsIFwic3ltYm9sc1wiOiBbXCJ3aHNwJHN0cmluZyQ0XCJdfSxcbiAgICB7XCJuYW1lXCI6IFwiZWxlbWVudFwiLCBcInN5bWJvbHNcIjogW1wibmFtZVwiLCBcInNlcFwiLCBcInR5cGVcIiwgXCJwYXJhbXNcIiwgXCJzZXBcIiwgXCJiYXNlXCIsIFwib3V0c2lkZV9pbnB1dHNcIiwgXCJvdXRzaWRlX291dHB1dHNcIiwgXCJ3aXJlc1wiXSwgXCJwb3N0cHJvY2Vzc1wiOiAgZnVuY3Rpb24oZCkge1xuICAgICAgICBcdHJldHVybiB7XG4gICAgICAgIFx0XHRuYW1lOiBkWzBdLFxuICAgICAgICBcdFx0dHlwZTogZFsyXSxcbiAgICAgICAgXHRcdHBhcmFtZXRlcnM6IGRbM10sXG4gICAgICAgIFx0XHRiYXNlOiBkWzVdLFxuICAgICAgICBcdFx0b3V0c2lkZUlucHV0czogZFs2XSxcbiAgICAgICAgXHRcdGV4dGVybmFsT3V0cHV0czogZFs3XSxcbiAgICAgICAgXHRcdHdpcmVzOiBkWzhdXG4gICAgICAgIFx0fTtcbiAgICAgICAgfSB9LFxuICAgIHtcIm5hbWVcIjogXCJuYW1lJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wic3RyaW5nXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwibmFtZSRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHtyZXR1cm4gbnVsbDt9fSxcbiAgICB7XCJuYW1lXCI6IFwibmFtZVwiLCBcInN5bWJvbHNcIjogWy9bYS16XS8sIFwibmFtZSRlYm5mJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4gZFswXSArIChkWzFdIHx8IFwiXCIpOyB9fSxcbiAgICB7XCJuYW1lXCI6IFwidHlwZVwiLCBcInN5bWJvbHNcIjogW1wibmFtZVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcInN0cmluZyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFsvW2EtekEtWjAtOV9dL119LFxuICAgIHtcIm5hbWVcIjogXCJzdHJpbmckZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJzdHJpbmckZWJuZiQxXCIsIC9bYS16QS1aMC05X10vXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiBhcnJwdXNoKGQpIHtyZXR1cm4gZFswXS5jb25jYXQoW2RbMV1dKTt9fSxcbiAgICB7XCJuYW1lXCI6IFwic3RyaW5nXCIsIFwic3ltYm9sc1wiOiBbXCJzdHJpbmckZWJuZiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF0uam9pbihcIlwiKTsgfX0sXG4gICAge1wibmFtZVwiOiBcIm1pbnVzX3N0cmluZyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFsvW2EtekEtWjAtOV8tXS9dfSxcbiAgICB7XCJuYW1lXCI6IFwibWludXNfc3RyaW5nJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wibWludXNfc3RyaW5nJGVibmYkMVwiLCAvW2EtekEtWjAtOV8tXS9dLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIGFycnB1c2goZCkge3JldHVybiBkWzBdLmNvbmNhdChbZFsxXV0pO319LFxuICAgIHtcIm5hbWVcIjogXCJtaW51c19zdHJpbmdcIiwgXCJzeW1ib2xzXCI6IFtcIm1pbnVzX3N0cmluZyRlYm5mJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4gZFswXS5qb2luKFwiXCIpOyB9fSxcbiAgICB7XCJuYW1lXCI6IFwicGFyYW1zJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW119LFxuICAgIHtcIm5hbWVcIjogXCJwYXJhbXMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wic2VwXCIsIFwicGFyYW1zX2luaXRcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4gZFsxXTsgfX0sXG4gICAge1wibmFtZVwiOiBcInBhcmFtcyRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcInBhcmFtcyRlYm5mJDFcIiwgXCJwYXJhbXMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiBhcnJwdXNoKGQpIHtyZXR1cm4gZFswXS5jb25jYXQoW2RbMV1dKTt9fSxcbiAgICB7XCJuYW1lXCI6IFwicGFyYW1zXCIsIFwic3ltYm9sc1wiOiBbXCJwYXJhbXMkZWJuZiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwicGFyYW1zX2luaXRcIiwgXCJzeW1ib2xzXCI6IFtcIm5hbWVcIiwgXCJvcHRzZXBcIiwge1wibGl0ZXJhbFwiOlwiPVwifSwgXCJvcHRzZXBcIiwgXCJzdHJpbmdcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4ge2tleTogZFswXSwgdmFsdWU6IGRbNF19OyB9fSxcbiAgICB7XCJuYW1lXCI6IFwiYmFzZSRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtcImxvY2FsX2Nvbm5lY3RvclwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcImJhc2UkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7cmV0dXJuIG51bGw7fX0sXG4gICAge1wibmFtZVwiOiBcImJhc2VcIiwgXCJzeW1ib2xzXCI6IFtcImJhc2UkZWJuZiQxXCIsIHtcImxpdGVyYWxcIjpcIkBcIn0sIFwiY29vcmRpbmF0ZXNfcmVtb3RlXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF0gPyB7YmFzZTogZFswXSwgY29vcmRpbmF0ZXM6IGRbMl19IDogZFsyXTsgfX0sXG4gICAge1wibmFtZVwiOiBcImNvbm5lY3Rvcl90eXBlJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcImlcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiY29ubmVjdG9yX3R5cGUkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwib1wifV19LFxuICAgIHtcIm5hbWVcIjogXCJjb25uZWN0b3JfdHlwZVwiLCBcInN5bWJvbHNcIjogW1wiY29ubmVjdG9yX3R5cGUkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF1bMF0gPT09IFwiaVwiID8gXCJpbnB1dFwiIDogXCJvdXRwdXRcIjsgfX0sXG4gICAge1wibmFtZVwiOiBcImxvY2FsX2Nvbm5lY3RvclwiLCBcInN5bWJvbHNcIjogW1wiY29ubmVjdG9yX3R5cGVcIiwgXCJ1aW50XCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHtjb25uZWN0b3I6IGRbMF0sIGluZGV4OiBkWzFdIH07IH19LFxuICAgIHtcIm5hbWVcIjogXCJyZW1vdGVfY29ubmVjdG9yXCIsIFwic3ltYm9sc1wiOiBbXCJuYW1lXCIsIHtcImxpdGVyYWxcIjpcIi9cIn0sIFwibG9jYWxfY29ubmVjdG9yXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHtuYW1lOiBkWzBdLCBjb25uZWN0b3I6IGRbMl0uY29ubmVjdG9yLCBpbmRleDogZFsyXS5pbmRleH07IH19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlc19yZW1vdGUkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlc19yZW1vdGVfc2VwYXJhdGVcIl19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlc19yZW1vdGUkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJyZW1vdGVfY29ubmVjdG9yXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwiY29vcmRpbmF0ZXNfcmVtb3RlXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlc19yZW1vdGUkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF1bMF07IH19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlc19yZW1vdGVfc2VwYXJhdGUkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlX3JlbW90ZVwiLCB7XCJsaXRlcmFsXCI6XCI6XCJ9LCBcImNvb3JkaW5hdGVfcmVtb3RlXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwiY29vcmRpbmF0ZXNfcmVtb3RlX3NlcGFyYXRlXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlc19yZW1vdGVfc2VwYXJhdGUkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHt4OiBkWzBdWzBdLCB5OiBkWzBdWzJdfTsgfX0sXG4gICAge1wibmFtZVwiOiBcImNvb3JkaW5hdGVfcmVtb3RlJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wiY29vcmRpbmF0ZVwiXX0sXG4gICAge1wibmFtZVwiOiBcImNvb3JkaW5hdGVfcmVtb3RlJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wicmVtb3RlX2Nvbm5lY3RvclwiXX0sXG4gICAge1wibmFtZVwiOiBcImNvb3JkaW5hdGVfcmVtb3RlJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wicmVtb3RlX2Nvbm5lY3Rvcl9kZWx0YVwiXX0sXG4gICAge1wibmFtZVwiOiBcImNvb3JkaW5hdGVfcmVtb3RlXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlX3JlbW90ZSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4gZFswXVswXTsgfX0sXG4gICAge1wibmFtZVwiOiBcInJlbW90ZV9jb25uZWN0b3JfZGVsdGFcIiwgXCJzeW1ib2xzXCI6IFtcInJlbW90ZV9jb25uZWN0b3JcIiwgXCJjb29yZGluYXRlX2RlbHRhXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHtkZWx0YTogZFsxXSwgZnJvbTogZFswXX07IH19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlc19yZWZlcmVuY2Ukc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlc19yZWZlcmVuY2Vfc2VwYXJhdGVcIl19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlc19yZWZlcmVuY2Ukc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJyZW1vdGVfY29ubmVjdG9yXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwiY29vcmRpbmF0ZXNfcmVmZXJlbmNlXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlc19yZWZlcmVuY2Ukc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF1bMF07IH19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlc19yZWZlcmVuY2Vfc2VwYXJhdGUkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlX3JlZmVyZW5jZVwiLCB7XCJsaXRlcmFsXCI6XCI6XCJ9LCBcImNvb3JkaW5hdGVfcmVmZXJlbmNlXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwiY29vcmRpbmF0ZXNfcmVmZXJlbmNlX3NlcGFyYXRlXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlc19yZWZlcmVuY2Vfc2VwYXJhdGUkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHt4OiBkWzBdWzBdLCB5OiBkWzBdWzJdfTsgfX0sXG4gICAge1wibmFtZVwiOiBcImNvb3JkaW5hdGVfcmVmZXJlbmNlJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wiY29vcmRpbmF0ZV9yZW1vdGVcIl19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlX3JlZmVyZW5jZSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcImNvb3JkaW5hdGVfcmVmZXJlbmNlX2Jhc2VcIl19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlX3JlZmVyZW5jZSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcImNvb3JkaW5hdGVfcmVmZXJlbmNlX2Jhc2VfZGVsdGFcIl19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlX3JlZmVyZW5jZVwiLCBcInN5bWJvbHNcIjogW1wiY29vcmRpbmF0ZV9yZWZlcmVuY2Ukc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF1bMF07IH19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlX3JlZmVyZW5jZV9iYXNlX2RlbHRhXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlX3JlZmVyZW5jZV9iYXNlXCIsIFwiY29vcmRpbmF0ZV9kZWx0YVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7IHJldHVybiB7ZGVsdGE6IGRbMV0sIGZyb206IGRbMF19OyB9fSxcbiAgICB7XCJuYW1lXCI6IFwiY29vcmRpbmF0ZV9yZWZlcmVuY2VfYmFzZSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCJwXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImNvb3JkaW5hdGVfcmVmZXJlbmNlX2Jhc2Ukc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiblwifV19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlX3JlZmVyZW5jZV9iYXNlXCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlX3JlZmVyZW5jZV9iYXNlJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdWzBdID09PSBcIm5cIiA/IFwibmV4dFwiIDogXCJwcmV2XCI7IH19LFxuICAgIHtcIm5hbWVcIjogXCJjb29yZGluYXRlX2RlbHRhJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIitcIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwiY29vcmRpbmF0ZV9kZWx0YSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCItXCJ9XX0sXG4gICAge1wibmFtZVwiOiBcImNvb3JkaW5hdGVfZGVsdGFcIiwgXCJzeW1ib2xzXCI6IFtcImNvb3JkaW5hdGVfZGVsdGEkc3ViZXhwcmVzc2lvbiQxXCIsIFwidWludFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdWzBdID09PSBcIi1cIiA/IC0xKmRbMV0gOiBkWzFdOyB9fSxcbiAgICB7XCJuYW1lXCI6IFwiY29vcmRpbmF0ZVwiLCBcInN5bWJvbHNcIjogW1widWludFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIm91dHNpZGVfaW5wdXRzJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW119LFxuICAgIHtcIm5hbWVcIjogXCJvdXRzaWRlX2lucHV0cyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJzZXBcIiwgXCJvdXRzaWRlX2lucHV0X2luaXRcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4gZFsxXTsgfX0sXG4gICAge1wibmFtZVwiOiBcIm91dHNpZGVfaW5wdXRzJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wib3V0c2lkZV9pbnB1dHMkZWJuZiQxXCIsIFwib3V0c2lkZV9pbnB1dHMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiBhcnJwdXNoKGQpIHtyZXR1cm4gZFswXS5jb25jYXQoW2RbMV1dKTt9fSxcbiAgICB7XCJuYW1lXCI6IFwib3V0c2lkZV9pbnB1dHNcIiwgXCJzeW1ib2xzXCI6IFtcIm91dHNpZGVfaW5wdXRzJGVibmYkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBpZH0sXG4gICAge1wibmFtZVwiOiBcIm91dHNpZGVfaW5wdXRfaW5pdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ1aW50XCIsIFwib3B0c2VwXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwib3V0c2lkZV9pbnB1dF9pbml0JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wib3V0c2lkZV9pbnB1dF9pbml0JGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJvdXRzaWRlX2lucHV0X2luaXQkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7cmV0dXJuIG51bGw7fX0sXG4gICAge1wibmFtZVwiOiBcIm91dHNpZGVfaW5wdXRfaW5pdCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiK1wifSwgXCJ1aW50XCJdfSxcbiAgICB7XCJuYW1lXCI6IFwib3V0c2lkZV9pbnB1dF9pbml0JGVibmYkMlwiLCBcInN5bWJvbHNcIjogW1wib3V0c2lkZV9pbnB1dF9pbml0JGVibmYkMiRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJvdXRzaWRlX2lucHV0X2luaXQkZWJuZiQyXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7cmV0dXJuIG51bGw7fX0sXG4gICAge1wibmFtZVwiOiBcIm91dHNpZGVfaW5wdXRfaW5pdFwiLCBcInN5bWJvbHNcIjogW1wib3V0c2lkZV9pbnB1dF9pbml0JGVibmYkMVwiLCB7XCJsaXRlcmFsXCI6XCI8XCJ9LCBcIm9wdHNlcFwiLCBcInVpbnRcIiwgXCJvdXRzaWRlX2lucHV0X2luaXQkZWJuZiQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHtpbnB1dEluZGV4OiBkWzBdICE9PSBudWxsID8gZFswXVswXSA6IG51bGwsIG91dHB1dEluZGV4OiBkWzNdLCBtb3JlOiBkWzRdICE9PSBudWxsID8gZFs0XVsxXSA6IDB9OyB9fSxcbiAgICB7XCJuYW1lXCI6IFwib3V0c2lkZV9vdXRwdXRzJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW119LFxuICAgIHtcIm5hbWVcIjogXCJvdXRzaWRlX291dHB1dHMkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wic2VwXCIsIFwib3V0c2lkZV9vdXRwdXRfaW5pdFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7IHJldHVybiBkWzFdOyB9fSxcbiAgICB7XCJuYW1lXCI6IFwib3V0c2lkZV9vdXRwdXRzJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wib3V0c2lkZV9vdXRwdXRzJGVibmYkMVwiLCBcIm91dHNpZGVfb3V0cHV0cyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIGFycnB1c2goZCkge3JldHVybiBkWzBdLmNvbmNhdChbZFsxXV0pO319LFxuICAgIHtcIm5hbWVcIjogXCJvdXRzaWRlX291dHB1dHNcIiwgXCJzeW1ib2xzXCI6IFtcIm91dHNpZGVfb3V0cHV0cyRlYm5mJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJvdXRzaWRlX291dHB1dF9pbml0JGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIrXCJ9LCBcInVpbnRcIl19LFxuICAgIHtcIm5hbWVcIjogXCJvdXRzaWRlX291dHB1dF9pbml0JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wib3V0c2lkZV9vdXRwdXRfaW5pdCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwib3V0c2lkZV9vdXRwdXRfaW5pdCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHtyZXR1cm4gbnVsbDt9fSxcbiAgICB7XCJuYW1lXCI6IFwib3V0c2lkZV9vdXRwdXRfaW5pdCRzdHJpbmckMVwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIj5cIn0sIHtcImxpdGVyYWxcIjpcIj5cIn1dLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIGpvaW5lcihkKSB7cmV0dXJuIGQuam9pbignJyk7fX0sXG4gICAge1wibmFtZVwiOiBcIm91dHNpZGVfb3V0cHV0X2luaXRcIiwgXCJzeW1ib2xzXCI6IFtcInVpbnRcIiwgXCJvdXRzaWRlX291dHB1dF9pbml0JGVibmYkMVwiLCBcIm9wdHNlcFwiLCBcIm91dHNpZGVfb3V0cHV0X2luaXQkc3RyaW5nJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4ge291dHB1dEluZGV4OiBkWzBdLCBtb3JlOiBkWzFdICE9PSBudWxsID8gZFsxXVsxXSA6IDB9OyB9fSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZXMkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXX0sXG4gICAge1wibmFtZVwiOiBcIndpcmVzJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFtcInNlcFwiLCBcIndpcmVfaW5pdFwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7IHJldHVybiBkWzFdOyB9fSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZXMkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ3aXJlcyRlYm5mJDFcIiwgXCJ3aXJlcyRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIGFycnB1c2goZCkge3JldHVybiBkWzBdLmNvbmNhdChbZFsxXV0pO319LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlc1wiLCBcInN5bWJvbHNcIjogW1wid2lyZXMkZWJuZiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9pbml0JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wid2lyZV9vdXRwdXRcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlX2luaXQkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7cmV0dXJuIG51bGw7fX0sXG4gICAge1wibmFtZVwiOiBcIndpcmVfaW5pdCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJHN1YmV4cHJlc3Npb24kMSRzdHJpbmckMVwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcInRcIn0sIHtcImxpdGVyYWxcIjpcInJcIn0sIHtcImxpdGVyYWxcIjpcInVcIn0sIHtcImxpdGVyYWxcIjpcImVcIn1dLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uIGpvaW5lcihkKSB7cmV0dXJuIGQuam9pbignJyk7fX0sXG4gICAge1wibmFtZVwiOiBcIndpcmVfaW5pdCRlYm5mJDIkc3ViZXhwcmVzc2lvbiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wid2lyZV9pbml0JGVibmYkMiRzdWJleHByZXNzaW9uJDEkc3ViZXhwcmVzc2lvbiQxJHN0cmluZyQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9pbml0JGVibmYkMiRzdWJleHByZXNzaW9uJDEkc3ViZXhwcmVzc2lvbiQxJHN0cmluZyQyXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiZlwifSwge1wibGl0ZXJhbFwiOlwiYVwifSwge1wibGl0ZXJhbFwiOlwibFwifSwge1wibGl0ZXJhbFwiOlwic1wifSwge1wibGl0ZXJhbFwiOlwiZVwifV0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24gam9pbmVyKGQpIHtyZXR1cm4gZC5qb2luKCcnKTt9fSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9pbml0JGVibmYkMiRzdWJleHByZXNzaW9uJDEkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ3aXJlX2luaXQkZWJuZiQyJHN1YmV4cHJlc3Npb24kMSRzdWJleHByZXNzaW9uJDEkc3RyaW5nJDJcIl19LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlX2luaXQkZWJuZiQyJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIj1cIn0sIFwid2lyZV9pbml0JGVibmYkMiRzdWJleHByZXNzaW9uJDEkc3ViZXhwcmVzc2lvbiQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9pbml0JGVibmYkMlwiLCBcInN5bWJvbHNcIjogW1wid2lyZV9pbml0JGVibmYkMiRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlX2luaXQkZWJuZiQyXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7cmV0dXJuIG51bGw7fX0sXG4gICAge1wibmFtZVwiOiBcIndpcmVfaW5pdFwiLCBcInN5bWJvbHNcIjogW1wid2lyZV9pbml0JGVibmYkMVwiLCBcIndpcmVcIiwgXCJ3aXJlX2luaXQkZWJuZiQyXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHtvdXRwdXRJbmRleDogZFswXSAmJiBkWzBdLm91dHB1dEluZGV4LCBtb3JlOiBkWzBdICYmIGRbMF0ubW9yZSwgY29vcmRpbmF0ZXM6IGRbMV0sIGluaXRpYWxWYWx1ZTogZFsyXSAmJiBkWzJdWzFdWzBdID09PSBcInRydWVcIn07IH19LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlX291dHB1dCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJGVibmYkMSRzdWJleHByZXNzaW9uJDFcIiwgXCJzeW1ib2xzXCI6IFt7XCJsaXRlcmFsXCI6XCIrXCJ9LCBcInVpbnRcIl19LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlX291dHB1dCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxJGVibmYkMVwiLCBcInN5bWJvbHNcIjogW1wid2lyZV9vdXRwdXQkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9vdXRwdXQkZWJuZiQxJHN1YmV4cHJlc3Npb24kMSRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFtdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHtyZXR1cm4gbnVsbDt9fSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9vdXRwdXQkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1widWludFwiLCBcIndpcmVfb3V0cHV0JGVibmYkMSRzdWJleHByZXNzaW9uJDEkZWJuZiQxXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9vdXRwdXQkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ3aXJlX291dHB1dCRlYm5mJDEkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGlkfSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9vdXRwdXQkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7cmV0dXJuIG51bGw7fX0sXG4gICAge1wibmFtZVwiOiBcIndpcmVfb3V0cHV0JHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIj5cIn1dfSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV9vdXRwdXQkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbe1wibGl0ZXJhbFwiOlwiflwifV19LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlX291dHB1dFwiLCBcInN5bWJvbHNcIjogW1wid2lyZV9vdXRwdXQkZWJuZiQxXCIsIFwid2lyZV9vdXRwdXQkc3ViZXhwcmVzc2lvbiQxXCJdLCBcInBvc3Rwcm9jZXNzXCI6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHtvdXRwdXRJbmRleDogZFswXSAmJiBkWzBdWzBdLCBtb3JlOiBkWzBdICYmIGRbMF1bMV0gIT09IG51bGwgPyBkWzBdWzFdWzFdIDogMH07IH19LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW1wid2lyZV9wb2ludFwiXX0sXG4gICAge1wibmFtZVwiOiBcIndpcmUkc3ViZXhwcmVzc2lvbiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ3aXJlX3Rlcm1pbmFsXCJdfSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZVwiLCBcInN5bWJvbHNcIjogW1wid2lyZSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4gZFswXVswXTsgfX0sXG4gICAge1wibmFtZVwiOiBcIndpcmVfcG9pbnQkZWJuZiQxJHN1YmV4cHJlc3Npb24kMVwiLCBcInN5bWJvbHNcIjogW3tcImxpdGVyYWxcIjpcIn5cIn0sIFwid2lyZVwiXX0sXG4gICAge1wibmFtZVwiOiBcIndpcmVfcG9pbnQkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ3aXJlX3BvaW50JGVibmYkMSRzdWJleHByZXNzaW9uJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogaWR9LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlX3BvaW50JGVibmYkMVwiLCBcInN5bWJvbHNcIjogW10sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkge3JldHVybiBudWxsO319LFxuICAgIHtcIm5hbWVcIjogXCJ3aXJlX3BvaW50XCIsIFwic3ltYm9sc1wiOiBbXCJjb29yZGluYXRlc19yZWZlcmVuY2VcIiwgXCJ3aXJlX3BvaW50JGVibmYkMVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7IHJldHVybiBbZFswXV0uY29uY2F0KGRbMV0gPyBkWzFdWzFdIDogW10pOyB9fSxcbiAgICB7XCJuYW1lXCI6IFwid2lyZV90ZXJtaW5hbFwiLCBcInN5bWJvbHNcIjogW1wibmFtZVwiXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbihkKSB7IHJldHVybiBbe25hbWU6IGRbMF0sIGNvbm5lY3RvcjogXCJpbnB1dFwiLCBpbmRleDogbnVsbH1dOyB9fSxcbiAgICB7XCJuYW1lXCI6IFwidWludCRlYm5mJDFcIiwgXCJzeW1ib2xzXCI6IFsvWzAtOV0vXX0sXG4gICAge1wibmFtZVwiOiBcInVpbnQkZWJuZiQxXCIsIFwic3ltYm9sc1wiOiBbXCJ1aW50JGVibmYkMVwiLCAvWzAtOV0vXSwgXCJwb3N0cHJvY2Vzc1wiOiBmdW5jdGlvbiBhcnJwdXNoKGQpIHtyZXR1cm4gZFswXS5jb25jYXQoW2RbMV1dKTt9fSxcbiAgICB7XCJuYW1lXCI6IFwidWludFwiLCBcInN5bWJvbHNcIjogW1widWludCRlYm5mJDFcIl0sIFwicG9zdHByb2Nlc3NcIjogZnVuY3Rpb24oZCkgeyByZXR1cm4gcGFyc2VJbnQoZFswXS5qb2luKFwiXCIpKTsgfX1cbl1cbiAgLCBQYXJzZXJTdGFydDogXCJNQUlOXCJcbn1cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgIG1vZHVsZS5leHBvcnRzID0gZ3JhbW1hcjtcbn0gZWxzZSB7XG4gICB3aW5kb3cuZ3JhbW1hciA9IGdyYW1tYXI7XG59XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/grammar/grammar.js\n");

/***/ }),

/***/ "./out/js/Circuit.js":
/*!***************************!*\
  !*** ./out/js/Circuit.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ConnectedElement_1 = __webpack_require__(/*! ./ConnectedElement */ \"./out/js/ConnectedElement.js\");\nconst DataSource_1 = __webpack_require__(/*! ./DataSource */ \"./out/js/DataSource.js\");\nconst NeverError_1 = __webpack_require__(/*! ./NeverError */ \"./out/js/NeverError.js\");\nconst WasmInstance_1 = __webpack_require__(/*! ./WasmInstance */ \"./out/js/WasmInstance.js\");\nclass Circuit {\n    constructor(element) {\n        this.element = element;\n    }\n    init(echoFunctions = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let space = new ConnectedElement_1.ConnectedElement.Space();\n            this.writeOutputsCalculations = this.element.getWriteOutputsCalculations(space);\n            this.readInputsCalculations = this.element.getReadInputsCalculations();\n            let updateFunctions = this.element.getUpdateFunctions();\n            this.initiallyTrueAddresses = this.element.getInitiallyTrueAddresses();\n            let moduloOperationsMap = {};\n            let moduloOperations = [];\n            let readInputsFunctionProvider = this.makeFunctionProvider(this.readInputsCalculations, moduloOperations, moduloOperationsMap);\n            let writeOutputsFunctionProvider = this.makeFunctionProvider(this.writeOutputsCalculations, moduloOperations, moduloOperationsMap);\n            let currentSpace = space;\n            while (currentSpace) {\n                for (let address of currentSpace.addresses) {\n                    this.makeValueSourceAccessor(address, moduloOperations, moduloOperationsMap, true);\n                }\n                currentSpace = currentSpace.next;\n            }\n            space.offset = 8 + 4 * moduloOperations.length;\n            for (;;) {\n                space.calculateSizeAndOffsetNext();\n                if (!space.next) {\n                    break;\n                }\n                space = space.next;\n            }\n            this.updateModulosFunction = this.makeModulosUpdateFunction(moduloOperations);\n            this.readInputsFunction = readInputsFunctionProvider();\n            this.writeOutputsFunction = writeOutputsFunctionProvider();\n            if (echoFunctions) {\n                console.log(\"updateModulosFunction\", this.updateModulosFunction.toString());\n                console.log(\"readInputsFunction\", this.readInputsFunction.toString());\n                console.log(\"writeOutputsFunction\", this.writeOutputsFunction.toString());\n            }\n            let calculations = [\n                ...this.readInputsCalculations,\n                ...this.writeOutputsCalculations\n            ];\n            this.dataSource = new DataSource_1.DataSource(space.offset + space.size, moduloOperations, moduloOperationsMap);\n            try {\n                this.wasmInstance = new WasmInstance_1.WasmInstance(this.dataSource, moduloOperations, moduloOperationsMap, calculations);\n                yield this.wasmInstance.instantiate();\n                console.log(\"using wasm\");\n            }\n            catch (e) {\n                console.log(`wasm failed, falling back to javascript function; error:`);\n                console.log(e.stack);\n                this.wasmInstance = undefined;\n                this.dataSource.setBuffer(new ArrayBuffer(this.dataSource.getTargetNumBytes()));\n            }\n            for (let i = 0; i < 8; i++) {\n                this.dataSource.array[i] = 0xFF;\n            }\n            for (let address of this.initiallyTrueAddresses) {\n                this.dataSource.array[address.info.address] = 1;\n            }\n            this.updateFunctionInstances = new Array(updateFunctions.length);\n            for (let i = 0; i < updateFunctions.length; i++) {\n                let updateFunction = updateFunctions[i];\n                let addressReaders = new Array(updateFunction.inputAddresses.length);\n                for (let j = 0; j < updateFunction.inputAddresses.length; j++) {\n                    addressReaders[j] = this.dataSource.getAddressValueReader(updateFunction.inputAddresses[j]);\n                }\n                let addressWriters = new Array(updateFunction.outputAddresses.length);\n                for (let j = 0; j < updateFunction.outputAddresses.length; j++) {\n                    addressWriters[j] = this.dataSource.getAddressValueWriter(updateFunction.outputAddresses[j]);\n                }\n                this.updateFunctionInstances[i] = {\n                    updateFunction,\n                    addressReaders,\n                    addressWriters,\n                    stepsLeft: 0\n                };\n            }\n            if (this.wasmInstance) {\n                this.doSteps = (numSteps) => this.wasmInstance.step(numSteps);\n            }\n            else {\n                this.doSteps = (numSteps) => {\n                    for (let i = 0; i < numSteps; i++) {\n                        this.dataSource.n++;\n                        this.updateModulosFunction(this.dataSource.addressArray, this.dataSource.n);\n                        this.readInputsFunction(this.dataSource.array, this.dataSource.addressArray, this.dataSource.n);\n                        this.writeOutputsFunction(this.dataSource.array, this.dataSource.addressArray, this.dataSource.n);\n                    }\n                };\n            }\n        });\n    }\n    getModuloOperationIndex(moduloOperations, moduloOperationsMap, mod, startOffset) {\n        if (!moduloOperationsMap[mod]) {\n            moduloOperationsMap[mod] = {};\n        }\n        if (moduloOperationsMap[mod][startOffset] === undefined) {\n            let index = moduloOperations.length + 2;\n            moduloOperationsMap[mod][startOffset] = index;\n            moduloOperations.push({\n                space: undefined,\n                startOffset: startOffset,\n                mod: mod,\n                address: index,\n                hint: `modulo operation ${index}: ((n + ${startOffset}) % ${mod})`\n            });\n        }\n        return moduloOperationsMap[mod][startOffset];\n    }\n    makeFunctionProvider(calculations, moduloOperations, moduloOperationsMap) {\n        let lines = [];\n        for (let calculation of calculations) {\n            let line = this.makeLine(calculation, moduloOperations, moduloOperationsMap);\n            lines.push(line);\n        }\n        return () => new Function(\"d\", \"a\", \"n\", lines.map((f) => f()).join(\"\\n\"));\n    }\n    makeLine(calculation, moduloOperations, moduloOperationsMap) {\n        let targetAccessor = undefined;\n        if (calculation.target) {\n            targetAccessor = this.makeValueSourceAccessor(calculation.target, moduloOperations, moduloOperationsMap);\n        }\n        let sourceAccessor = this.makeValueSourceAccessor(calculation.value, moduloOperations, moduloOperationsMap, true);\n        return () => {\n            let line = \"\";\n            if (targetAccessor) {\n                line += `${targetAccessor()} = ((`;\n            }\n            line += `${sourceAccessor()}`;\n            if (targetAccessor) {\n                line += `) ? 1 : 0)`;\n            }\n            line += \";\";\n            return line;\n        };\n    }\n    makeValueSourceAccessor(valueSource, moduloOperations, moduloOperationsMap, read = false) {\n        switch (valueSource.type) {\n            case \"StaticAddress\": {\n                return this.makeStaticAddressAccessor(valueSource, read);\n            }\n            case \"RotatingAddress\": {\n                return this.makeRotatingAddressAccessor(valueSource, moduloOperations, moduloOperationsMap, read);\n            }\n            case \"AndRule\": {\n                return this.makeAndRuleAccessor(valueSource, moduloOperations, moduloOperationsMap);\n            }\n            case \"OrRule\": {\n                return this.makeOrRuleAccessor(valueSource, moduloOperations, moduloOperationsMap);\n            }\n            case \"NotRule\": {\n                return this.makeNotRuleAccessor(valueSource, moduloOperations, moduloOperationsMap);\n            }\n            case \"AlternatingValue\": {\n                return this.makeAlternatingValueAccessor(valueSource, moduloOperations, moduloOperationsMap);\n            }\n            default: {\n                throw new NeverError_1.NeverError(valueSource, \"unexpected value source type\");\n            }\n        }\n    }\n    makeStaticAddressAccessor(address, read = false) {\n        return () => `d[${address.info.address}] /*${address.info.hint}*/` + (read ? \" === 1\" : \"\");\n    }\n    makeRotatingAddressAccessor(address, moduloOperations, moduloOperationsMap, read = false) {\n        let moduloOperationIndex = this.getModuloOperationIndex(moduloOperations, moduloOperationsMap, address.info.mod, address.info.startOffset);\n        return () => `d[${address.info.address} + a[${moduloOperationIndex}]] /*${address.info.hint}*/` + (read ? \" === 1\" : \"\");\n    }\n    makeAndRuleAccessor(rule, moduloOperations, moduloOperationsMap) {\n        let accessors = rule.value.map((subValueSource) => this.makeValueSourceAccessor(subValueSource, moduloOperations, moduloOperationsMap, true));\n        return () => accessors.map((accessor) => `(${accessor()})`).join(\" && \");\n    }\n    makeOrRuleAccessor(rule, moduloOperations, moduloOperationsMap) {\n        let accessors = rule.value.map((subValueSource) => this.makeValueSourceAccessor(subValueSource, moduloOperations, moduloOperationsMap, true));\n        return () => accessors.map((accessor) => `(${accessor()})`).join(\" || \");\n    }\n    makeNotRuleAccessor(rule, moduloOperations, moduloOperationsMap) {\n        let accessor = this.makeValueSourceAccessor(rule.value, moduloOperations, moduloOperationsMap, true);\n        return () => `!(${accessor()})`;\n    }\n    makeAlternatingValueAccessor(value, moduloOperations, moduloOperationsMap) {\n        let mod = value.offDuration + value.onDuration;\n        let moduloOperationIndex = this.getModuloOperationIndex(moduloOperations, moduloOperationsMap, mod, value.startOffset);\n        return () => `a[${moduloOperationIndex}] < ${value.onDuration}`;\n    }\n    makeModulosUpdateFunction(moduloOperations) {\n        let lines = [];\n        for (let operation of moduloOperations) {\n            lines.push(`a[${operation.address}] = ((n + ${operation.startOffset}) % ${operation.mod}); /*${operation.hint}*/`);\n        }\n        return new Function(\"a\", \"n\", lines.join(\"\\n\"));\n    }\n    step(numCycles = 1) {\n        for (let updateFunctionInstance of this.updateFunctionInstances) {\n            if (updateFunctionInstance.stepsLeft <= 0) {\n                for (let i = 0; i < updateFunctionInstance.addressReaders.length; i++) {\n                    updateFunctionInstance.updateFunction.inputValues[i] = updateFunctionInstance.addressReaders[i]();\n                }\n                let updated = updateFunctionInstance.updateFunction.function();\n                if (updated) {\n                    for (let i = 0; i < updateFunctionInstance.addressWriters.length; i++) {\n                        updateFunctionInstance.addressWriters[i](updateFunctionInstance.updateFunction.outputValues[i]);\n                    }\n                }\n                updateFunctionInstance.stepsLeft = updateFunctionInstance.updateFunction.interval;\n            }\n            updateFunctionInstance.stepsLeft -= numCycles;\n        }\n        this.doSteps(numCycles);\n    }\n}\nexports.Circuit = Circuit;\n//# sourceMappingURL=Circuit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvQ2lyY3VpdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9DaXJjdWl0LmpzPzgzYjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbm5lY3RlZEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0Nvbm5lY3RlZEVsZW1lbnRcIik7XG5jb25zdCBEYXRhU291cmNlXzEgPSByZXF1aXJlKFwiLi9EYXRhU291cmNlXCIpO1xuY29uc3QgTmV2ZXJFcnJvcl8xID0gcmVxdWlyZShcIi4vTmV2ZXJFcnJvclwiKTtcbmNvbnN0IFdhc21JbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vV2FzbUluc3RhbmNlXCIpO1xuY2xhc3MgQ2lyY3VpdCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgICBpbml0KGVjaG9GdW5jdGlvbnMgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHNwYWNlID0gbmV3IENvbm5lY3RlZEVsZW1lbnRfMS5Db25uZWN0ZWRFbGVtZW50LlNwYWNlKCk7XG4gICAgICAgICAgICB0aGlzLndyaXRlT3V0cHV0c0NhbGN1bGF0aW9ucyA9IHRoaXMuZWxlbWVudC5nZXRXcml0ZU91dHB1dHNDYWxjdWxhdGlvbnMoc3BhY2UpO1xuICAgICAgICAgICAgdGhpcy5yZWFkSW5wdXRzQ2FsY3VsYXRpb25zID0gdGhpcy5lbGVtZW50LmdldFJlYWRJbnB1dHNDYWxjdWxhdGlvbnMoKTtcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jdGlvbnMgPSB0aGlzLmVsZW1lbnQuZ2V0VXBkYXRlRnVuY3Rpb25zKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxseVRydWVBZGRyZXNzZXMgPSB0aGlzLmVsZW1lbnQuZ2V0SW5pdGlhbGx5VHJ1ZUFkZHJlc3NlcygpO1xuICAgICAgICAgICAgbGV0IG1vZHVsb09wZXJhdGlvbnNNYXAgPSB7fTtcbiAgICAgICAgICAgIGxldCBtb2R1bG9PcGVyYXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgcmVhZElucHV0c0Z1bmN0aW9uUHJvdmlkZXIgPSB0aGlzLm1ha2VGdW5jdGlvblByb3ZpZGVyKHRoaXMucmVhZElucHV0c0NhbGN1bGF0aW9ucywgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCk7XG4gICAgICAgICAgICBsZXQgd3JpdGVPdXRwdXRzRnVuY3Rpb25Qcm92aWRlciA9IHRoaXMubWFrZUZ1bmN0aW9uUHJvdmlkZXIodGhpcy53cml0ZU91dHB1dHNDYWxjdWxhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXApO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTcGFjZSA9IHNwYWNlO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRTcGFjZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGFkZHJlc3Mgb2YgY3VycmVudFNwYWNlLmFkZHJlc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VWYWx1ZVNvdXJjZUFjY2Vzc29yKGFkZHJlc3MsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXAsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U3BhY2UgPSBjdXJyZW50U3BhY2UubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwYWNlLm9mZnNldCA9IDggKyA0ICogbW9kdWxvT3BlcmF0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgc3BhY2UuY2FsY3VsYXRlU2l6ZUFuZE9mZnNldE5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNwYWNlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYWNlID0gc3BhY2UubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kdWxvc0Z1bmN0aW9uID0gdGhpcy5tYWtlTW9kdWxvc1VwZGF0ZUZ1bmN0aW9uKG1vZHVsb09wZXJhdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5yZWFkSW5wdXRzRnVuY3Rpb24gPSByZWFkSW5wdXRzRnVuY3Rpb25Qcm92aWRlcigpO1xuICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dHNGdW5jdGlvbiA9IHdyaXRlT3V0cHV0c0Z1bmN0aW9uUHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmIChlY2hvRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1cGRhdGVNb2R1bG9zRnVuY3Rpb25cIiwgdGhpcy51cGRhdGVNb2R1bG9zRnVuY3Rpb24udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZWFkSW5wdXRzRnVuY3Rpb25cIiwgdGhpcy5yZWFkSW5wdXRzRnVuY3Rpb24udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ3cml0ZU91dHB1dHNGdW5jdGlvblwiLCB0aGlzLndyaXRlT3V0cHV0c0Z1bmN0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhbGN1bGF0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnJlYWRJbnB1dHNDYWxjdWxhdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4udGhpcy53cml0ZU91dHB1dHNDYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBuZXcgRGF0YVNvdXJjZV8xLkRhdGFTb3VyY2Uoc3BhY2Uub2Zmc2V0ICsgc3BhY2Uuc2l6ZSwgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FzbUluc3RhbmNlID0gbmV3IFdhc21JbnN0YW5jZV8xLldhc21JbnN0YW5jZSh0aGlzLmRhdGFTb3VyY2UsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXAsIGNhbGN1bGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy53YXNtSW5zdGFuY2UuaW5zdGFudGlhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVzaW5nIHdhc21cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB3YXNtIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGphdmFzY3JpcHQgZnVuY3Rpb247IGVycm9yOmApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuc3RhY2spO1xuICAgICAgICAgICAgICAgIHRoaXMud2FzbUluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRCdWZmZXIobmV3IEFycmF5QnVmZmVyKHRoaXMuZGF0YVNvdXJjZS5nZXRUYXJnZXROdW1CeXRlcygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5hcnJheVtpXSA9IDB4RkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBhZGRyZXNzIG9mIHRoaXMuaW5pdGlhbGx5VHJ1ZUFkZHJlc3Nlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5hcnJheVthZGRyZXNzLmluZm8uYWRkcmVzc10gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVGdW5jdGlvbkluc3RhbmNlcyA9IG5ldyBBcnJheSh1cGRhdGVGdW5jdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXBkYXRlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmN0aW9uID0gdXBkYXRlRnVuY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIGxldCBhZGRyZXNzUmVhZGVycyA9IG5ldyBBcnJheSh1cGRhdGVGdW5jdGlvbi5pbnB1dEFkZHJlc3Nlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdXBkYXRlRnVuY3Rpb24uaW5wdXRBZGRyZXNzZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1JlYWRlcnNbal0gPSB0aGlzLmRhdGFTb3VyY2UuZ2V0QWRkcmVzc1ZhbHVlUmVhZGVyKHVwZGF0ZUZ1bmN0aW9uLmlucHV0QWRkcmVzc2VzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGFkZHJlc3NXcml0ZXJzID0gbmV3IEFycmF5KHVwZGF0ZUZ1bmN0aW9uLm91dHB1dEFkZHJlc3Nlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdXBkYXRlRnVuY3Rpb24ub3V0cHV0QWRkcmVzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NXcml0ZXJzW2pdID0gdGhpcy5kYXRhU291cmNlLmdldEFkZHJlc3NWYWx1ZVdyaXRlcih1cGRhdGVGdW5jdGlvbi5vdXRwdXRBZGRyZXNzZXNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZ1bmN0aW9uSW5zdGFuY2VzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVGdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1JlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NXcml0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBzdGVwc0xlZnQ6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMud2FzbUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb1N0ZXBzID0gKG51bVN0ZXBzKSA9PiB0aGlzLndhc21JbnN0YW5jZS5zdGVwKG51bVN0ZXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9TdGVwcyA9IChudW1TdGVwcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVN0ZXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZHVsb3NGdW5jdGlvbih0aGlzLmRhdGFTb3VyY2UuYWRkcmVzc0FycmF5LCB0aGlzLmRhdGFTb3VyY2Uubik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRJbnB1dHNGdW5jdGlvbih0aGlzLmRhdGFTb3VyY2UuYXJyYXksIHRoaXMuZGF0YVNvdXJjZS5hZGRyZXNzQXJyYXksIHRoaXMuZGF0YVNvdXJjZS5uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVPdXRwdXRzRnVuY3Rpb24odGhpcy5kYXRhU291cmNlLmFycmF5LCB0aGlzLmRhdGFTb3VyY2UuYWRkcmVzc0FycmF5LCB0aGlzLmRhdGFTb3VyY2Uubik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TW9kdWxvT3BlcmF0aW9uSW5kZXgobW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCwgbW9kLCBzdGFydE9mZnNldCkge1xuICAgICAgICBpZiAoIW1vZHVsb09wZXJhdGlvbnNNYXBbbW9kXSkge1xuICAgICAgICAgICAgbW9kdWxvT3BlcmF0aW9uc01hcFttb2RdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZHVsb09wZXJhdGlvbnNNYXBbbW9kXVtzdGFydE9mZnNldF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gbW9kdWxvT3BlcmF0aW9ucy5sZW5ndGggKyAyO1xuICAgICAgICAgICAgbW9kdWxvT3BlcmF0aW9uc01hcFttb2RdW3N0YXJ0T2Zmc2V0XSA9IGluZGV4O1xuICAgICAgICAgICAgbW9kdWxvT3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzcGFjZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICBtb2Q6IG1vZCxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBpbmRleCxcbiAgICAgICAgICAgICAgICBoaW50OiBgbW9kdWxvIG9wZXJhdGlvbiAke2luZGV4fTogKChuICsgJHtzdGFydE9mZnNldH0pICUgJHttb2R9KWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bG9PcGVyYXRpb25zTWFwW21vZF1bc3RhcnRPZmZzZXRdO1xuICAgIH1cbiAgICBtYWtlRnVuY3Rpb25Qcm92aWRlcihjYWxjdWxhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXApIHtcbiAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGNhbGN1bGF0aW9uIG9mIGNhbGN1bGF0aW9ucykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLm1ha2VMaW5lKGNhbGN1bGF0aW9uLCBtb2R1bG9PcGVyYXRpb25zLCBtb2R1bG9PcGVyYXRpb25zTWFwKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBGdW5jdGlvbihcImRcIiwgXCJhXCIsIFwiblwiLCBsaW5lcy5tYXAoKGYpID0+IGYoKSkuam9pbihcIlxcblwiKSk7XG4gICAgfVxuICAgIG1ha2VMaW5lKGNhbGN1bGF0aW9uLCBtb2R1bG9PcGVyYXRpb25zLCBtb2R1bG9PcGVyYXRpb25zTWFwKSB7XG4gICAgICAgIGxldCB0YXJnZXRBY2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNhbGN1bGF0aW9uLnRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0QWNjZXNzb3IgPSB0aGlzLm1ha2VWYWx1ZVNvdXJjZUFjY2Vzc29yKGNhbGN1bGF0aW9uLnRhcmdldCwgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNvdXJjZUFjY2Vzc29yID0gdGhpcy5tYWtlVmFsdWVTb3VyY2VBY2Nlc3NvcihjYWxjdWxhdGlvbi52YWx1ZSwgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodGFyZ2V0QWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBsaW5lICs9IGAke3RhcmdldEFjY2Vzc29yKCl9ID0gKChgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZSArPSBgJHtzb3VyY2VBY2Nlc3NvcigpfWA7XG4gICAgICAgICAgICBpZiAodGFyZ2V0QWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBsaW5lICs9IGApID8gMSA6IDApYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmUgKz0gXCI7XCI7XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZVZhbHVlU291cmNlQWNjZXNzb3IodmFsdWVTb3VyY2UsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXAsIHJlYWQgPSBmYWxzZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlU291cmNlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJTdGF0aWNBZGRyZXNzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlU3RhdGljQWRkcmVzc0FjY2Vzc29yKHZhbHVlU291cmNlLCByZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJSb3RhdGluZ0FkZHJlc3NcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VSb3RhdGluZ0FkZHJlc3NBY2Nlc3Nvcih2YWx1ZVNvdXJjZSwgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCwgcmVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiQW5kUnVsZVwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUFuZFJ1bGVBY2Nlc3Nvcih2YWx1ZVNvdXJjZSwgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiT3JSdWxlXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlT3JSdWxlQWNjZXNzb3IodmFsdWVTb3VyY2UsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIk5vdFJ1bGVcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VOb3RSdWxlQWNjZXNzb3IodmFsdWVTb3VyY2UsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkFsdGVybmF0aW5nVmFsdWVcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VBbHRlcm5hdGluZ1ZhbHVlQWNjZXNzb3IodmFsdWVTb3VyY2UsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOZXZlckVycm9yXzEuTmV2ZXJFcnJvcih2YWx1ZVNvdXJjZSwgXCJ1bmV4cGVjdGVkIHZhbHVlIHNvdXJjZSB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1ha2VTdGF0aWNBZGRyZXNzQWNjZXNzb3IoYWRkcmVzcywgcmVhZCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBgZFske2FkZHJlc3MuaW5mby5hZGRyZXNzfV0gLyoke2FkZHJlc3MuaW5mby5oaW50fSovYCArIChyZWFkID8gXCIgPT09IDFcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBtYWtlUm90YXRpbmdBZGRyZXNzQWNjZXNzb3IoYWRkcmVzcywgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCwgcmVhZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBtb2R1bG9PcGVyYXRpb25JbmRleCA9IHRoaXMuZ2V0TW9kdWxvT3BlcmF0aW9uSW5kZXgobW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCwgYWRkcmVzcy5pbmZvLm1vZCwgYWRkcmVzcy5pbmZvLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGBkWyR7YWRkcmVzcy5pbmZvLmFkZHJlc3N9ICsgYVske21vZHVsb09wZXJhdGlvbkluZGV4fV1dIC8qJHthZGRyZXNzLmluZm8uaGludH0qL2AgKyAocmVhZCA/IFwiID09PSAxXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgbWFrZUFuZFJ1bGVBY2Nlc3NvcihydWxlLCBtb2R1bG9PcGVyYXRpb25zLCBtb2R1bG9PcGVyYXRpb25zTWFwKSB7XG4gICAgICAgIGxldCBhY2Nlc3NvcnMgPSBydWxlLnZhbHVlLm1hcCgoc3ViVmFsdWVTb3VyY2UpID0+IHRoaXMubWFrZVZhbHVlU291cmNlQWNjZXNzb3Ioc3ViVmFsdWVTb3VyY2UsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXAsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGFjY2Vzc29ycy5tYXAoKGFjY2Vzc29yKSA9PiBgKCR7YWNjZXNzb3IoKX0pYCkuam9pbihcIiAmJiBcIik7XG4gICAgfVxuICAgIG1ha2VPclJ1bGVBY2Nlc3NvcihydWxlLCBtb2R1bG9PcGVyYXRpb25zLCBtb2R1bG9PcGVyYXRpb25zTWFwKSB7XG4gICAgICAgIGxldCBhY2Nlc3NvcnMgPSBydWxlLnZhbHVlLm1hcCgoc3ViVmFsdWVTb3VyY2UpID0+IHRoaXMubWFrZVZhbHVlU291cmNlQWNjZXNzb3Ioc3ViVmFsdWVTb3VyY2UsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXAsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGFjY2Vzc29ycy5tYXAoKGFjY2Vzc29yKSA9PiBgKCR7YWNjZXNzb3IoKX0pYCkuam9pbihcIiB8fCBcIik7XG4gICAgfVxuICAgIG1ha2VOb3RSdWxlQWNjZXNzb3IocnVsZSwgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCkge1xuICAgICAgICBsZXQgYWNjZXNzb3IgPSB0aGlzLm1ha2VWYWx1ZVNvdXJjZUFjY2Vzc29yKHJ1bGUudmFsdWUsIG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXAsIHRydWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gYCEoJHthY2Nlc3NvcigpfSlgO1xuICAgIH1cbiAgICBtYWtlQWx0ZXJuYXRpbmdWYWx1ZUFjY2Vzc29yKHZhbHVlLCBtb2R1bG9PcGVyYXRpb25zLCBtb2R1bG9PcGVyYXRpb25zTWFwKSB7XG4gICAgICAgIGxldCBtb2QgPSB2YWx1ZS5vZmZEdXJhdGlvbiArIHZhbHVlLm9uRHVyYXRpb247XG4gICAgICAgIGxldCBtb2R1bG9PcGVyYXRpb25JbmRleCA9IHRoaXMuZ2V0TW9kdWxvT3BlcmF0aW9uSW5kZXgobW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCwgbW9kLCB2YWx1ZS5zdGFydE9mZnNldCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBgYVske21vZHVsb09wZXJhdGlvbkluZGV4fV0gPCAke3ZhbHVlLm9uRHVyYXRpb259YDtcbiAgICB9XG4gICAgbWFrZU1vZHVsb3NVcGRhdGVGdW5jdGlvbihtb2R1bG9PcGVyYXRpb25zKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBvcGVyYXRpb24gb2YgbW9kdWxvT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgbGluZXMucHVzaChgYVske29wZXJhdGlvbi5hZGRyZXNzfV0gPSAoKG4gKyAke29wZXJhdGlvbi5zdGFydE9mZnNldH0pICUgJHtvcGVyYXRpb24ubW9kfSk7IC8qJHtvcGVyYXRpb24uaGludH0qL2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJhXCIsIFwiblwiLCBsaW5lcy5qb2luKFwiXFxuXCIpKTtcbiAgICB9XG4gICAgc3RlcChudW1DeWNsZXMgPSAxKSB7XG4gICAgICAgIGZvciAobGV0IHVwZGF0ZUZ1bmN0aW9uSW5zdGFuY2Ugb2YgdGhpcy51cGRhdGVGdW5jdGlvbkluc3RhbmNlcykge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZUZ1bmN0aW9uSW5zdGFuY2Uuc3RlcHNMZWZ0IDw9IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVwZGF0ZUZ1bmN0aW9uSW5zdGFuY2UuYWRkcmVzc1JlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlRnVuY3Rpb25JbnN0YW5jZS51cGRhdGVGdW5jdGlvbi5pbnB1dFZhbHVlc1tpXSA9IHVwZGF0ZUZ1bmN0aW9uSW5zdGFuY2UuYWRkcmVzc1JlYWRlcnNbaV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSB1cGRhdGVGdW5jdGlvbkluc3RhbmNlLnVwZGF0ZUZ1bmN0aW9uLmZ1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cGRhdGVGdW5jdGlvbkluc3RhbmNlLmFkZHJlc3NXcml0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVGdW5jdGlvbkluc3RhbmNlLmFkZHJlc3NXcml0ZXJzW2ldKHVwZGF0ZUZ1bmN0aW9uSW5zdGFuY2UudXBkYXRlRnVuY3Rpb24ub3V0cHV0VmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jdGlvbkluc3RhbmNlLnN0ZXBzTGVmdCA9IHVwZGF0ZUZ1bmN0aW9uSW5zdGFuY2UudXBkYXRlRnVuY3Rpb24uaW50ZXJ2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVGdW5jdGlvbkluc3RhbmNlLnN0ZXBzTGVmdCAtPSBudW1DeWNsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb1N0ZXBzKG51bUN5Y2xlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5DaXJjdWl0ID0gQ2lyY3VpdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNpcmN1aXQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/Circuit.js\n");

/***/ }),

/***/ "./out/js/CombinedElement.js":
/*!***********************************!*\
  !*** ./out/js/CombinedElement.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass CombinedElement {\n    constructor(name, elementWiringDescriptions) {\n        this.name = name;\n        this.inputReceiverDescriptions = [];\n        this.outputSourceDescriptions = [];\n        this.connectedElements = new Array(elementWiringDescriptions.length);\n        let connectedElementsMap = {};\n        let tempInputReceiverDescriptions = [];\n        for (let i = 0; i < elementWiringDescriptions.length; i++) {\n            this.connectedElements[i] = elementWiringDescriptions[i].element;\n            connectedElementsMap[elementWiringDescriptions[i].name] = elementWiringDescriptions[i].element;\n        }\n        for (let elementIndex = 0; elementIndex < elementWiringDescriptions.length; elementIndex++) {\n            let wiringDescription = elementWiringDescriptions[elementIndex];\n            let connectedElement = wiringDescription.element;\n            for (let inputIndex = 0; inputIndex < wiringDescription.inputs.length; inputIndex++) {\n                let inputDescription = wiringDescription.inputs[inputIndex];\n                if (inputDescription.name === \"outside\") {\n                    while (inputDescription.outputIndex >= tempInputReceiverDescriptions.length) {\n                        tempInputReceiverDescriptions.push(undefined);\n                    }\n                    if (tempInputReceiverDescriptions[inputDescription.outputIndex]) {\n                        throw new Error(this.name + \": input index \" + inputDescription.outputIndex + \" of this combined element is already connected to inside element \" + tempInputReceiverDescriptions[inputDescription.outputIndex].wiringDescriptionName + \" and therefore can not be connected to inside element \" + wiringDescription.name);\n                    }\n                    tempInputReceiverDescriptions[inputDescription.outputIndex] = {\n                        element: connectedElement,\n                        wiringDescriptionName: wiringDescription.name,\n                        index: inputIndex\n                    };\n                }\n                else {\n                    let sourceElement = connectedElementsMap[inputDescription.name];\n                    if (!sourceElement) {\n                        throw new Error(this.name + \": unknown element name: \" + inputDescription.name);\n                    }\n                    connectedElement.readInputFrom(inputIndex, sourceElement, inputDescription.outputIndex);\n                }\n            }\n            for (let externalOutputIndex of wiringDescription.externalOutputs) {\n                this.outputSourceDescriptions.push({\n                    element: connectedElement,\n                    wiringDescriptionName: wiringDescription.name,\n                    index: externalOutputIndex\n                });\n            }\n        }\n        for (let i = 0; i < tempInputReceiverDescriptions.length; i++) {\n            let valueLocationDescription = tempInputReceiverDescriptions[i];\n            if (!valueLocationDescription) {\n                throw new Error(this.name + \": input index \" + i + \" is not connected to any inner element, but higher input index exists\");\n            }\n            this.inputReceiverDescriptions.push(valueLocationDescription);\n        }\n    }\n    getName() {\n        return this.name;\n    }\n    getOwnType() {\n        return undefined;\n    }\n    getDelay() {\n        return 0;\n    }\n    getChildren() {\n        return this.connectedElements;\n    }\n    readInputFrom(inputIndex, sourceElement, sourceOutputIndex) {\n        if (inputIndex < this.inputReceiverDescriptions.length) {\n            let inputReceiverDescription = this.inputReceiverDescriptions[inputIndex];\n            inputReceiverDescription.element.readInputFrom(inputReceiverDescription.index, sourceElement, sourceOutputIndex);\n        }\n        else {\n            throw new Error(this.name + \": input index \" + inputIndex + \" is out of bounds for this element\");\n        }\n    }\n    getNumOutputs() {\n        return this.outputSourceDescriptions.length;\n    }\n    getOutputValueAddressProvider(outputIndex) {\n        let outputSourceDescription = this.outputSourceDescriptions[outputIndex];\n        return outputSourceDescription.element.getOutputValueAddressProvider(outputSourceDescription.index);\n    }\n    getWriteOutputsCalculations(space) {\n        let calculations = [];\n        for (let connectedElement of this.connectedElements) {\n            let childCalculations = connectedElement.getWriteOutputsCalculations(space);\n            calculations.push(...childCalculations);\n            while (space.next) {\n                space = space.next;\n            }\n            space = space.getNew();\n        }\n        return calculations;\n    }\n    getReadInputsCalculations() {\n        let calculations = [];\n        for (let connectedElement of this.connectedElements) {\n            let childCalculations = connectedElement.getReadInputsCalculations();\n            calculations.push(...childCalculations);\n        }\n        return calculations;\n    }\n    getUpdateFunctions() {\n        let updateFunctions = [];\n        for (let connectedElement of this.connectedElements) {\n            let childUpdateFunctions = connectedElement.getUpdateFunctions();\n            updateFunctions.push(...childUpdateFunctions);\n        }\n        return updateFunctions;\n    }\n    getInitiallyTrueAddresses() {\n        let calculations = [];\n        for (let connectedElement of this.connectedElements) {\n            let childCalculations = connectedElement.getInitiallyTrueAddresses();\n            calculations.push(...childCalculations);\n        }\n        return calculations;\n    }\n}\nexports.CombinedElement = CombinedElement;\n//# sourceMappingURL=CombinedElement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvQ29tYmluZWRFbGVtZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL0NvbWJpbmVkRWxlbWVudC5qcz9iNDNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQ29tYmluZWRFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBlbGVtZW50V2lyaW5nRGVzY3JpcHRpb25zKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5wdXRSZWNlaXZlckRlc2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFNvdXJjZURlc2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEVsZW1lbnRzID0gbmV3IEFycmF5KGVsZW1lbnRXaXJpbmdEZXNjcmlwdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgbGV0IGNvbm5lY3RlZEVsZW1lbnRzTWFwID0ge307XG4gICAgICAgIGxldCB0ZW1wSW5wdXRSZWNlaXZlckRlc2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRXaXJpbmdEZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkRWxlbWVudHNbaV0gPSBlbGVtZW50V2lyaW5nRGVzY3JpcHRpb25zW2ldLmVsZW1lbnQ7XG4gICAgICAgICAgICBjb25uZWN0ZWRFbGVtZW50c01hcFtlbGVtZW50V2lyaW5nRGVzY3JpcHRpb25zW2ldLm5hbWVdID0gZWxlbWVudFdpcmluZ0Rlc2NyaXB0aW9uc1tpXS5lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW1lbnRJbmRleCA9IDA7IGVsZW1lbnRJbmRleCA8IGVsZW1lbnRXaXJpbmdEZXNjcmlwdGlvbnMubGVuZ3RoOyBlbGVtZW50SW5kZXgrKykge1xuICAgICAgICAgICAgbGV0IHdpcmluZ0Rlc2NyaXB0aW9uID0gZWxlbWVudFdpcmluZ0Rlc2NyaXB0aW9uc1tlbGVtZW50SW5kZXhdO1xuICAgICAgICAgICAgbGV0IGNvbm5lY3RlZEVsZW1lbnQgPSB3aXJpbmdEZXNjcmlwdGlvbi5lbGVtZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaW5wdXRJbmRleCA9IDA7IGlucHV0SW5kZXggPCB3aXJpbmdEZXNjcmlwdGlvbi5pbnB1dHMubGVuZ3RoOyBpbnB1dEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXREZXNjcmlwdGlvbiA9IHdpcmluZ0Rlc2NyaXB0aW9uLmlucHV0c1tpbnB1dEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXREZXNjcmlwdGlvbi5uYW1lID09PSBcIm91dHNpZGVcIikge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5wdXREZXNjcmlwdGlvbi5vdXRwdXRJbmRleCA+PSB0ZW1wSW5wdXRSZWNlaXZlckRlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJbnB1dFJlY2VpdmVyRGVzY3JpcHRpb25zLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElucHV0UmVjZWl2ZXJEZXNjcmlwdGlvbnNbaW5wdXREZXNjcmlwdGlvbi5vdXRwdXRJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLm5hbWUgKyBcIjogaW5wdXQgaW5kZXggXCIgKyBpbnB1dERlc2NyaXB0aW9uLm91dHB1dEluZGV4ICsgXCIgb2YgdGhpcyBjb21iaW5lZCBlbGVtZW50IGlzIGFscmVhZHkgY29ubmVjdGVkIHRvIGluc2lkZSBlbGVtZW50IFwiICsgdGVtcElucHV0UmVjZWl2ZXJEZXNjcmlwdGlvbnNbaW5wdXREZXNjcmlwdGlvbi5vdXRwdXRJbmRleF0ud2lyaW5nRGVzY3JpcHRpb25OYW1lICsgXCIgYW5kIHRoZXJlZm9yZSBjYW4gbm90IGJlIGNvbm5lY3RlZCB0byBpbnNpZGUgZWxlbWVudCBcIiArIHdpcmluZ0Rlc2NyaXB0aW9uLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbXBJbnB1dFJlY2VpdmVyRGVzY3JpcHRpb25zW2lucHV0RGVzY3JpcHRpb24ub3V0cHV0SW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogY29ubmVjdGVkRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpcmluZ0Rlc2NyaXB0aW9uTmFtZTogd2lyaW5nRGVzY3JpcHRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbnB1dEluZGV4XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc291cmNlRWxlbWVudCA9IGNvbm5lY3RlZEVsZW1lbnRzTWFwW2lucHV0RGVzY3JpcHRpb24ubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMubmFtZSArIFwiOiB1bmtub3duIGVsZW1lbnQgbmFtZTogXCIgKyBpbnB1dERlc2NyaXB0aW9uLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEVsZW1lbnQucmVhZElucHV0RnJvbShpbnB1dEluZGV4LCBzb3VyY2VFbGVtZW50LCBpbnB1dERlc2NyaXB0aW9uLm91dHB1dEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBleHRlcm5hbE91dHB1dEluZGV4IG9mIHdpcmluZ0Rlc2NyaXB0aW9uLmV4dGVybmFsT3V0cHV0cykge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U291cmNlRGVzY3JpcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBjb25uZWN0ZWRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICB3aXJpbmdEZXNjcmlwdGlvbk5hbWU6IHdpcmluZ0Rlc2NyaXB0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBleHRlcm5hbE91dHB1dEluZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wSW5wdXRSZWNlaXZlckRlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlTG9jYXRpb25EZXNjcmlwdGlvbiA9IHRlbXBJbnB1dFJlY2VpdmVyRGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZUxvY2F0aW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5uYW1lICsgXCI6IGlucHV0IGluZGV4IFwiICsgaSArIFwiIGlzIG5vdCBjb25uZWN0ZWQgdG8gYW55IGlubmVyIGVsZW1lbnQsIGJ1dCBoaWdoZXIgaW5wdXQgaW5kZXggZXhpc3RzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnB1dFJlY2VpdmVyRGVzY3JpcHRpb25zLnB1c2godmFsdWVMb2NhdGlvbkRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICBnZXRPd25UeXBlKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXREZWxheSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRFbGVtZW50cztcbiAgICB9XG4gICAgcmVhZElucHV0RnJvbShpbnB1dEluZGV4LCBzb3VyY2VFbGVtZW50LCBzb3VyY2VPdXRwdXRJbmRleCkge1xuICAgICAgICBpZiAoaW5wdXRJbmRleCA8IHRoaXMuaW5wdXRSZWNlaXZlckRlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dFJlY2VpdmVyRGVzY3JpcHRpb24gPSB0aGlzLmlucHV0UmVjZWl2ZXJEZXNjcmlwdGlvbnNbaW5wdXRJbmRleF07XG4gICAgICAgICAgICBpbnB1dFJlY2VpdmVyRGVzY3JpcHRpb24uZWxlbWVudC5yZWFkSW5wdXRGcm9tKGlucHV0UmVjZWl2ZXJEZXNjcmlwdGlvbi5pbmRleCwgc291cmNlRWxlbWVudCwgc291cmNlT3V0cHV0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMubmFtZSArIFwiOiBpbnB1dCBpbmRleCBcIiArIGlucHV0SW5kZXggKyBcIiBpcyBvdXQgb2YgYm91bmRzIGZvciB0aGlzIGVsZW1lbnRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TnVtT3V0cHV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0U291cmNlRGVzY3JpcHRpb25zLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0T3V0cHV0VmFsdWVBZGRyZXNzUHJvdmlkZXIob3V0cHV0SW5kZXgpIHtcbiAgICAgICAgbGV0IG91dHB1dFNvdXJjZURlc2NyaXB0aW9uID0gdGhpcy5vdXRwdXRTb3VyY2VEZXNjcmlwdGlvbnNbb3V0cHV0SW5kZXhdO1xuICAgICAgICByZXR1cm4gb3V0cHV0U291cmNlRGVzY3JpcHRpb24uZWxlbWVudC5nZXRPdXRwdXRWYWx1ZUFkZHJlc3NQcm92aWRlcihvdXRwdXRTb3VyY2VEZXNjcmlwdGlvbi5pbmRleCk7XG4gICAgfVxuICAgIGdldFdyaXRlT3V0cHV0c0NhbGN1bGF0aW9ucyhzcGFjZSkge1xuICAgICAgICBsZXQgY2FsY3VsYXRpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGNvbm5lY3RlZEVsZW1lbnQgb2YgdGhpcy5jb25uZWN0ZWRFbGVtZW50cykge1xuICAgICAgICAgICAgbGV0IGNoaWxkQ2FsY3VsYXRpb25zID0gY29ubmVjdGVkRWxlbWVudC5nZXRXcml0ZU91dHB1dHNDYWxjdWxhdGlvbnMoc3BhY2UpO1xuICAgICAgICAgICAgY2FsY3VsYXRpb25zLnB1c2goLi4uY2hpbGRDYWxjdWxhdGlvbnMpO1xuICAgICAgICAgICAgd2hpbGUgKHNwYWNlLm5leHQpIHtcbiAgICAgICAgICAgICAgICBzcGFjZSA9IHNwYWNlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFjZSA9IHNwYWNlLmdldE5ldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGlvbnM7XG4gICAgfVxuICAgIGdldFJlYWRJbnB1dHNDYWxjdWxhdGlvbnMoKSB7XG4gICAgICAgIGxldCBjYWxjdWxhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29ubmVjdGVkRWxlbWVudCBvZiB0aGlzLmNvbm5lY3RlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRDYWxjdWxhdGlvbnMgPSBjb25uZWN0ZWRFbGVtZW50LmdldFJlYWRJbnB1dHNDYWxjdWxhdGlvbnMoKTtcbiAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5wdXNoKC4uLmNoaWxkQ2FsY3VsYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsY3VsYXRpb25zO1xuICAgIH1cbiAgICBnZXRVcGRhdGVGdW5jdGlvbnMoKSB7XG4gICAgICAgIGxldCB1cGRhdGVGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29ubmVjdGVkRWxlbWVudCBvZiB0aGlzLmNvbm5lY3RlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRVcGRhdGVGdW5jdGlvbnMgPSBjb25uZWN0ZWRFbGVtZW50LmdldFVwZGF0ZUZ1bmN0aW9ucygpO1xuICAgICAgICAgICAgdXBkYXRlRnVuY3Rpb25zLnB1c2goLi4uY2hpbGRVcGRhdGVGdW5jdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbnM7XG4gICAgfVxuICAgIGdldEluaXRpYWxseVRydWVBZGRyZXNzZXMoKSB7XG4gICAgICAgIGxldCBjYWxjdWxhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29ubmVjdGVkRWxlbWVudCBvZiB0aGlzLmNvbm5lY3RlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRDYWxjdWxhdGlvbnMgPSBjb25uZWN0ZWRFbGVtZW50LmdldEluaXRpYWxseVRydWVBZGRyZXNzZXMoKTtcbiAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5wdXNoKC4uLmNoaWxkQ2FsY3VsYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsY3VsYXRpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tYmluZWRFbGVtZW50ID0gQ29tYmluZWRFbGVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tYmluZWRFbGVtZW50LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/CombinedElement.js\n");

/***/ }),

/***/ "./out/js/ConnectedElement.js":
/*!************************************!*\
  !*** ./out/js/ConnectedElement.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst NeverError_1 = __webpack_require__(/*! ./NeverError */ \"./out/js/NeverError.js\");\nvar ConnectedElement;\n(function (ConnectedElement) {\n    class Space {\n        constructor() {\n            this.offset = 0;\n            this.size = 0;\n            this.next = undefined;\n            this.addresses = [];\n        }\n        getNew() {\n            if (this.next) {\n                throw new Error(\"next Space was already created\");\n            }\n            return this.next = new Space();\n        }\n        onAddress(address) {\n            this.addresses.push(address);\n        }\n        calculateSizeAndOffsetNext() {\n            for (let address of this.addresses) {\n                switch (address.type) {\n                    case \"StaticAddress\": {\n                        this.size = Math.max(this.size, address.info.address + 1);\n                        address.info.address += this.offset;\n                        break;\n                    }\n                    case \"RotatingAddress\": {\n                        this.size = Math.max(this.size, address.info.address + address.info.mod);\n                        address.info.address += this.offset;\n                        break;\n                    }\n                    default: {\n                        throw new NeverError_1.NeverError(address, \"unexpected address type\");\n                    }\n                }\n            }\n            if (this.next) {\n                this.next.offset = this.offset + this.size;\n            }\n        }\n    }\n    ConnectedElement.Space = Space;\n    ;\n    class StaticAddress {\n        constructor(info) {\n            this.info = info;\n            this.type = \"StaticAddress\";\n            info.space.onAddress(this);\n        }\n    }\n    ConnectedElement.StaticAddress = StaticAddress;\n    class RotatingAddress {\n        constructor(info) {\n            this.info = info;\n            this.type = \"RotatingAddress\";\n            info.space.onAddress(this);\n        }\n        getAllAddresses() {\n            let addresses = [];\n            for (let i = 0; i < this.info.mod; i++) {\n                addresses.push(new StaticAddress({\n                    space: this.info.space,\n                    address: this.info.address + i,\n                    hint: `static buffer row address of rotating address ${this.info.address} with offset ${i} mod ${this.info.mod}`\n                }));\n            }\n            return addresses;\n        }\n    }\n    ConnectedElement.RotatingAddress = RotatingAddress;\n})(ConnectedElement = exports.ConnectedElement || (exports.ConnectedElement = {}));\n//# sourceMappingURL=ConnectedElement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvQ29ubmVjdGVkRWxlbWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9Db25uZWN0ZWRFbGVtZW50LmpzPzFiZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOZXZlckVycm9yXzEgPSByZXF1aXJlKFwiLi9OZXZlckVycm9yXCIpO1xudmFyIENvbm5lY3RlZEVsZW1lbnQ7XG4oZnVuY3Rpb24gKENvbm5lY3RlZEVsZW1lbnQpIHtcbiAgICBjbGFzcyBTcGFjZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TmV3KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5leHQgU3BhY2Ugd2FzIGFscmVhZHkgY3JlYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSBuZXcgU3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBvbkFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxjdWxhdGVTaXplQW5kT2Zmc2V0TmV4dCgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFkZHJlc3Mgb2YgdGhpcy5hZGRyZXNzZXMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFkZHJlc3MudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU3RhdGljQWRkcmVzc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSBNYXRoLm1heCh0aGlzLnNpemUsIGFkZHJlc3MuaW5mby5hZGRyZXNzICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmluZm8uYWRkcmVzcyArPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJSb3RhdGluZ0FkZHJlc3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gTWF0aC5tYXgodGhpcy5zaXplLCBhZGRyZXNzLmluZm8uYWRkcmVzcyArIGFkZHJlc3MuaW5mby5tb2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5pbmZvLmFkZHJlc3MgKz0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmV2ZXJFcnJvcl8xLk5ldmVyRXJyb3IoYWRkcmVzcywgXCJ1bmV4cGVjdGVkIGFkZHJlc3MgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQub2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29ubmVjdGVkRWxlbWVudC5TcGFjZSA9IFNwYWNlO1xuICAgIDtcbiAgICBjbGFzcyBTdGF0aWNBZGRyZXNzIHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5mbykge1xuICAgICAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiU3RhdGljQWRkcmVzc1wiO1xuICAgICAgICAgICAgaW5mby5zcGFjZS5vbkFkZHJlc3ModGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29ubmVjdGVkRWxlbWVudC5TdGF0aWNBZGRyZXNzID0gU3RhdGljQWRkcmVzcztcbiAgICBjbGFzcyBSb3RhdGluZ0FkZHJlc3Mge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gXCJSb3RhdGluZ0FkZHJlc3NcIjtcbiAgICAgICAgICAgIGluZm8uc3BhY2Uub25BZGRyZXNzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGdldEFsbEFkZHJlc3NlcygpIHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmZvLm1vZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2gobmV3IFN0YXRpY0FkZHJlc3Moe1xuICAgICAgICAgICAgICAgICAgICBzcGFjZTogdGhpcy5pbmZvLnNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmluZm8uYWRkcmVzcyArIGksXG4gICAgICAgICAgICAgICAgICAgIGhpbnQ6IGBzdGF0aWMgYnVmZmVyIHJvdyBhZGRyZXNzIG9mIHJvdGF0aW5nIGFkZHJlc3MgJHt0aGlzLmluZm8uYWRkcmVzc30gd2l0aCBvZmZzZXQgJHtpfSBtb2QgJHt0aGlzLmluZm8ubW9kfWBcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzc2VzO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbm5lY3RlZEVsZW1lbnQuUm90YXRpbmdBZGRyZXNzID0gUm90YXRpbmdBZGRyZXNzO1xufSkoQ29ubmVjdGVkRWxlbWVudCA9IGV4cG9ydHMuQ29ubmVjdGVkRWxlbWVudCB8fCAoZXhwb3J0cy5Db25uZWN0ZWRFbGVtZW50ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3RlZEVsZW1lbnQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/ConnectedElement.js\n");

/***/ }),

/***/ "./out/js/DataSource.js":
/*!******************************!*\
  !*** ./out/js/DataSource.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst NeverError_1 = __webpack_require__(/*! ./NeverError */ \"./out/js/NeverError.js\");\nconst nOffset = 2;\nclass DataSource {\n    constructor(targetNumBytes, moduloOperations, moduloOperationsMap) {\n        this.targetNumBytes = targetNumBytes;\n        this.moduloOperationsMap = moduloOperationsMap;\n        this.n = -1;\n        this.addressesOffset = nOffset;\n        this.numAddresses = moduloOperations.length;\n        this.dataOffset = 4 * (this.addressesOffset + this.numAddresses);\n        this.numData = targetNumBytes - this.dataOffset;\n    }\n    getTargetNumBytes() {\n        return this.targetNumBytes;\n    }\n    setBuffer(buffer) {\n        this.array = new Uint8Array(buffer);\n        this.addressArray = new Uint32Array(buffer);\n    }\n    getAddressValueReader(address) {\n        if (address.type === \"StaticAddress\") {\n            let index = address.info.address;\n            return () => this.array[index] === 1;\n        }\n        else if (address.type === \"RotatingAddress\") {\n            const mod = address.info.mod;\n            const offset = address.info.address;\n            const moduloOperationIndex = this.moduloOperationsMap[address.info.mod][address.info.startOffset];\n            return (localOffset = 0) => this.array[offset + ((this.addressArray[moduloOperationIndex] + localOffset) % mod)] === 1;\n        }\n        else {\n            throw new NeverError_1.NeverError(address, \"unexpected address type\");\n        }\n    }\n    getAddressValueWriter(address) {\n        if (address.type === \"StaticAddress\") {\n            let index = address.info.address;\n            return (value) => this.array[index] = (value ? 1 : 0);\n        }\n        else if (address.type === \"RotatingAddress\") {\n            const mod = address.info.mod;\n            const offset = address.info.address;\n            const moduloOperationIndex = this.moduloOperationsMap[address.info.mod][address.info.startOffset];\n            return (value, localOffset = 0) => this.array[offset + ((this.addressArray[moduloOperationIndex] + localOffset) % mod)] = (value ? 1 : 0);\n        }\n        else {\n            throw new NeverError_1.NeverError(address, \"unexpected address type\");\n        }\n    }\n}\nexports.DataSource = DataSource;\n(function (DataSource) {\n    class RotatingAddressInstance {\n    }\n    DataSource.RotatingAddressInstance = RotatingAddressInstance;\n})(DataSource = exports.DataSource || (exports.DataSource = {}));\n//# sourceMappingURL=DataSource.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvRGF0YVNvdXJjZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9EYXRhU291cmNlLmpzPzc0MDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOZXZlckVycm9yXzEgPSByZXF1aXJlKFwiLi9OZXZlckVycm9yXCIpO1xuY29uc3Qgbk9mZnNldCA9IDI7XG5jbGFzcyBEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXROdW1CeXRlcywgbW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCkge1xuICAgICAgICB0aGlzLnRhcmdldE51bUJ5dGVzID0gdGFyZ2V0TnVtQnl0ZXM7XG4gICAgICAgIHRoaXMubW9kdWxvT3BlcmF0aW9uc01hcCA9IG1vZHVsb09wZXJhdGlvbnNNYXA7XG4gICAgICAgIHRoaXMubiA9IC0xO1xuICAgICAgICB0aGlzLmFkZHJlc3Nlc09mZnNldCA9IG5PZmZzZXQ7XG4gICAgICAgIHRoaXMubnVtQWRkcmVzc2VzID0gbW9kdWxvT3BlcmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZGF0YU9mZnNldCA9IDQgKiAodGhpcy5hZGRyZXNzZXNPZmZzZXQgKyB0aGlzLm51bUFkZHJlc3Nlcyk7XG4gICAgICAgIHRoaXMubnVtRGF0YSA9IHRhcmdldE51bUJ5dGVzIC0gdGhpcy5kYXRhT2Zmc2V0O1xuICAgIH1cbiAgICBnZXRUYXJnZXROdW1CeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0TnVtQnl0ZXM7XG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuYWRkcmVzc0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgfVxuICAgIGdldEFkZHJlc3NWYWx1ZVJlYWRlcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzLnR5cGUgPT09IFwiU3RhdGljQWRkcmVzc1wiKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBhZGRyZXNzLmluZm8uYWRkcmVzcztcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmFycmF5W2luZGV4XSA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZGRyZXNzLnR5cGUgPT09IFwiUm90YXRpbmdBZGRyZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZCA9IGFkZHJlc3MuaW5mby5tb2Q7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBhZGRyZXNzLmluZm8uYWRkcmVzcztcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsb09wZXJhdGlvbkluZGV4ID0gdGhpcy5tb2R1bG9PcGVyYXRpb25zTWFwW2FkZHJlc3MuaW5mby5tb2RdW2FkZHJlc3MuaW5mby5zdGFydE9mZnNldF07XG4gICAgICAgICAgICByZXR1cm4gKGxvY2FsT2Zmc2V0ID0gMCkgPT4gdGhpcy5hcnJheVtvZmZzZXQgKyAoKHRoaXMuYWRkcmVzc0FycmF5W21vZHVsb09wZXJhdGlvbkluZGV4XSArIGxvY2FsT2Zmc2V0KSAlIG1vZCldID09PSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5ldmVyRXJyb3JfMS5OZXZlckVycm9yKGFkZHJlc3MsIFwidW5leHBlY3RlZCBhZGRyZXNzIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QWRkcmVzc1ZhbHVlV3JpdGVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MudHlwZSA9PT0gXCJTdGF0aWNBZGRyZXNzXCIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGFkZHJlc3MuaW5mby5hZGRyZXNzO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gdGhpcy5hcnJheVtpbmRleF0gPSAodmFsdWUgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWRkcmVzcy50eXBlID09PSBcIlJvdGF0aW5nQWRkcmVzc1wiKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBhZGRyZXNzLmluZm8ubW9kO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYWRkcmVzcy5pbmZvLmFkZHJlc3M7XG4gICAgICAgICAgICBjb25zdCBtb2R1bG9PcGVyYXRpb25JbmRleCA9IHRoaXMubW9kdWxvT3BlcmF0aW9uc01hcFthZGRyZXNzLmluZm8ubW9kXVthZGRyZXNzLmluZm8uc3RhcnRPZmZzZXRdO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSwgbG9jYWxPZmZzZXQgPSAwKSA9PiB0aGlzLmFycmF5W29mZnNldCArICgodGhpcy5hZGRyZXNzQXJyYXlbbW9kdWxvT3BlcmF0aW9uSW5kZXhdICsgbG9jYWxPZmZzZXQpICUgbW9kKV0gPSAodmFsdWUgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmV2ZXJFcnJvcl8xLk5ldmVyRXJyb3IoYWRkcmVzcywgXCJ1bmV4cGVjdGVkIGFkZHJlc3MgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGF0YVNvdXJjZSA9IERhdGFTb3VyY2U7XG4oZnVuY3Rpb24gKERhdGFTb3VyY2UpIHtcbiAgICBjbGFzcyBSb3RhdGluZ0FkZHJlc3NJbnN0YW5jZSB7XG4gICAgfVxuICAgIERhdGFTb3VyY2UuUm90YXRpbmdBZGRyZXNzSW5zdGFuY2UgPSBSb3RhdGluZ0FkZHJlc3NJbnN0YW5jZTtcbn0pKERhdGFTb3VyY2UgPSBleHBvcnRzLkRhdGFTb3VyY2UgfHwgKGV4cG9ydHMuRGF0YVNvdXJjZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhU291cmNlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/DataSource.js\n");

/***/ }),

/***/ "./out/js/LogicElement.js":
/*!********************************!*\
  !*** ./out/js/LogicElement.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ConnectedElement_1 = __webpack_require__(/*! ./ConnectedElement */ \"./out/js/ConnectedElement.js\");\nclass LogicElement {\n    constructor(name, numInputs, numOutputs, initialValue = false) {\n        this.name = name;\n        this.numInputs = numInputs;\n        this.numOutputs = numOutputs;\n        this.initialValue = initialValue;\n        this.inputValueAddressProviders = new Array(numInputs);\n        this.generatedInputAddresses = new Array(numInputs);\n    }\n    getName() {\n        return this.name;\n    }\n    getOwnType() {\n        return \"LogicElement/\" + this.constructor.name;\n    }\n    getDelay() {\n        return 0;\n    }\n    getChildren() {\n        return [];\n    }\n    readInputFrom(inputIndex, sourceElement, sourceOutputIndex) {\n        if (inputIndex < this.inputValueAddressProviders.length) {\n            if (sourceOutputIndex >= sourceElement.getNumOutputs()) {\n                throw new Error(this.name + \": need output index \" + sourceOutputIndex + \", but \" + sourceElement.getName() + \" only has \" + sourceElement.getNumOutputs() + \" outputs\");\n            }\n            this.inputValueAddressProviders[inputIndex] = sourceElement.getOutputValueAddressProvider(sourceOutputIndex);\n        }\n        else {\n            throw new Error(this.name + \": input index \" + inputIndex + \" is out of bounds for this element\");\n        }\n    }\n    getNumOutputs() {\n        return this.numOutputs;\n    }\n    getOutputValueAddressProvider(outputIndex) {\n        if (outputIndex >= this.numOutputs) {\n            throw new Error(`${this.getName()}: output index ${outputIndex} is out of bounds for this element`);\n        }\n        return () => this.outputAddresses[outputIndex];\n    }\n    getWriteOutputsCalculations(space) {\n        this.inputSpace = space;\n        space = space.getNew();\n        let calculations = this.makeCalculations(this.inputSpace, space);\n        if (calculations.outputAddresses.length !== this.numOutputs) {\n            throw new Error(`${this.getName()}: expected ${this.numOutputs} output addresses, but got ${calculations.outputAddresses.length}`);\n        }\n        for (let outputAddress of calculations.outputAddresses) {\n            if (outputAddress.info.space !== space) {\n                throw new Error(`${this.getName()}: output addresses need to be in outputSpace`);\n            }\n        }\n        this.outputAddresses = calculations.outputAddresses;\n        return calculations.calculations;\n    }\n    getReadInputsCalculations() {\n        let calculations = [];\n        for (let i = 0; i < this.inputValueAddressProviders.length; i++) {\n            let addressProvider = this.inputValueAddressProviders[i];\n            if (!addressProvider) {\n                throw new Error(this.getName() + \": input \" + i + \" is not connected\");\n            }\n            let inputValueAddress = addressProvider();\n            let generatedInputAddress = new ConnectedElement_1.ConnectedElement.StaticAddress({\n                address: i,\n                space: this.inputSpace,\n                hint: `automatically generated static input address of logic element ${this.getName()}`\n            });\n            this.generatedInputAddresses[i] = generatedInputAddress;\n            calculations.push({\n                target: generatedInputAddress,\n                value: inputValueAddress\n            });\n        }\n        return calculations;\n    }\n    getUpdateFunctions() {\n        let functions = this.makeUpdateFunctions();\n        let updateFunctions = [];\n        for (let func of functions) {\n            let inputValues = new Array(this.generatedInputAddresses.length);\n            let outputValues = new Array(this.outputAddresses.length);\n            let inputAddresses = this.generatedInputAddresses;\n            if (func.reverseInputs) {\n                inputAddresses = inputAddresses.slice().reverse();\n            }\n            updateFunctions.push({\n                function: () => func.function(inputValues, outputValues),\n                interval: func.interval,\n                inputAddresses: inputAddresses,\n                inputValues: inputValues,\n                outputAddresses: this.outputAddresses,\n                outputValues: outputValues\n            });\n        }\n        return updateFunctions;\n    }\n    getInitiallyTrueAddresses() {\n        return this.initialValue ? this.outputAddresses : [];\n    }\n}\nexports.LogicElement = LogicElement;\n//# sourceMappingURL=LogicElement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvTG9naWNFbGVtZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL0xvZ2ljRWxlbWVudC5qcz9hZmZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29ubmVjdGVkRWxlbWVudF8xID0gcmVxdWlyZShcIi4vQ29ubmVjdGVkRWxlbWVudFwiKTtcbmNsYXNzIExvZ2ljRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgbnVtSW5wdXRzLCBudW1PdXRwdXRzLCBpbml0aWFsVmFsdWUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm51bUlucHV0cyA9IG51bUlucHV0cztcbiAgICAgICAgdGhpcy5udW1PdXRwdXRzID0gbnVtT3V0cHV0cztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnMgPSBuZXcgQXJyYXkobnVtSW5wdXRzKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZWRJbnB1dEFkZHJlc3NlcyA9IG5ldyBBcnJheShudW1JbnB1dHMpO1xuICAgIH1cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICBnZXRPd25UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJMb2dpY0VsZW1lbnQvXCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIGdldERlbGF5KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmVhZElucHV0RnJvbShpbnB1dEluZGV4LCBzb3VyY2VFbGVtZW50LCBzb3VyY2VPdXRwdXRJbmRleCkge1xuICAgICAgICBpZiAoaW5wdXRJbmRleCA8IHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlT3V0cHV0SW5kZXggPj0gc291cmNlRWxlbWVudC5nZXROdW1PdXRwdXRzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5uYW1lICsgXCI6IG5lZWQgb3V0cHV0IGluZGV4IFwiICsgc291cmNlT3V0cHV0SW5kZXggKyBcIiwgYnV0IFwiICsgc291cmNlRWxlbWVudC5nZXROYW1lKCkgKyBcIiBvbmx5IGhhcyBcIiArIHNvdXJjZUVsZW1lbnQuZ2V0TnVtT3V0cHV0cygpICsgXCIgb3V0cHV0c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnNbaW5wdXRJbmRleF0gPSBzb3VyY2VFbGVtZW50LmdldE91dHB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVyKHNvdXJjZU91dHB1dEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLm5hbWUgKyBcIjogaW5wdXQgaW5kZXggXCIgKyBpbnB1dEluZGV4ICsgXCIgaXMgb3V0IG9mIGJvdW5kcyBmb3IgdGhpcyBlbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE51bU91dHB1dHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bU91dHB1dHM7XG4gICAgfVxuICAgIGdldE91dHB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVyKG91dHB1dEluZGV4KSB7XG4gICAgICAgIGlmIChvdXRwdXRJbmRleCA+PSB0aGlzLm51bU91dHB1dHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmdldE5hbWUoKX06IG91dHB1dCBpbmRleCAke291dHB1dEluZGV4fSBpcyBvdXQgb2YgYm91bmRzIGZvciB0aGlzIGVsZW1lbnRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5vdXRwdXRBZGRyZXNzZXNbb3V0cHV0SW5kZXhdO1xuICAgIH1cbiAgICBnZXRXcml0ZU91dHB1dHNDYWxjdWxhdGlvbnMoc3BhY2UpIHtcbiAgICAgICAgdGhpcy5pbnB1dFNwYWNlID0gc3BhY2U7XG4gICAgICAgIHNwYWNlID0gc3BhY2UuZ2V0TmV3KCk7XG4gICAgICAgIGxldCBjYWxjdWxhdGlvbnMgPSB0aGlzLm1ha2VDYWxjdWxhdGlvbnModGhpcy5pbnB1dFNwYWNlLCBzcGFjZSk7XG4gICAgICAgIGlmIChjYWxjdWxhdGlvbnMub3V0cHV0QWRkcmVzc2VzLmxlbmd0aCAhPT0gdGhpcy5udW1PdXRwdXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5nZXROYW1lKCl9OiBleHBlY3RlZCAke3RoaXMubnVtT3V0cHV0c30gb3V0cHV0IGFkZHJlc3NlcywgYnV0IGdvdCAke2NhbGN1bGF0aW9ucy5vdXRwdXRBZGRyZXNzZXMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG91dHB1dEFkZHJlc3Mgb2YgY2FsY3VsYXRpb25zLm91dHB1dEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgaWYgKG91dHB1dEFkZHJlc3MuaW5mby5zcGFjZSAhPT0gc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5nZXROYW1lKCl9OiBvdXRwdXQgYWRkcmVzc2VzIG5lZWQgdG8gYmUgaW4gb3V0cHV0U3BhY2VgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dEFkZHJlc3NlcyA9IGNhbGN1bGF0aW9ucy5vdXRwdXRBZGRyZXNzZXM7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGlvbnMuY2FsY3VsYXRpb25zO1xuICAgIH1cbiAgICBnZXRSZWFkSW5wdXRzQ2FsY3VsYXRpb25zKCkge1xuICAgICAgICBsZXQgY2FsY3VsYXRpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3NQcm92aWRlciA9IHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnNbaV07XG4gICAgICAgICAgICBpZiAoIWFkZHJlc3NQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldE5hbWUoKSArIFwiOiBpbnB1dCBcIiArIGkgKyBcIiBpcyBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlucHV0VmFsdWVBZGRyZXNzID0gYWRkcmVzc1Byb3ZpZGVyKCk7XG4gICAgICAgICAgICBsZXQgZ2VuZXJhdGVkSW5wdXRBZGRyZXNzID0gbmV3IENvbm5lY3RlZEVsZW1lbnRfMS5Db25uZWN0ZWRFbGVtZW50LlN0YXRpY0FkZHJlc3Moe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGksXG4gICAgICAgICAgICAgICAgc3BhY2U6IHRoaXMuaW5wdXRTcGFjZSxcbiAgICAgICAgICAgICAgICBoaW50OiBgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgc3RhdGljIGlucHV0IGFkZHJlc3Mgb2YgbG9naWMgZWxlbWVudCAke3RoaXMuZ2V0TmFtZSgpfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRJbnB1dEFkZHJlc3Nlc1tpXSA9IGdlbmVyYXRlZElucHV0QWRkcmVzcztcbiAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGdlbmVyYXRlZElucHV0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZUFkZHJlc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGlvbnM7XG4gICAgfVxuICAgIGdldFVwZGF0ZUZ1bmN0aW9ucygpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9ucyA9IHRoaXMubWFrZVVwZGF0ZUZ1bmN0aW9ucygpO1xuICAgICAgICBsZXQgdXBkYXRlRnVuY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGZ1bmMgb2YgZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRWYWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5nZW5lcmF0ZWRJbnB1dEFkZHJlc3Nlcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IG91dHB1dFZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLm91dHB1dEFkZHJlc3Nlcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGlucHV0QWRkcmVzc2VzID0gdGhpcy5nZW5lcmF0ZWRJbnB1dEFkZHJlc3NlcztcbiAgICAgICAgICAgIGlmIChmdW5jLnJldmVyc2VJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dEFkZHJlc3NlcyA9IGlucHV0QWRkcmVzc2VzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlRnVuY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiAoKSA9PiBmdW5jLmZ1bmN0aW9uKGlucHV0VmFsdWVzLCBvdXRwdXRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIGludGVydmFsOiBmdW5jLmludGVydmFsLFxuICAgICAgICAgICAgICAgIGlucHV0QWRkcmVzc2VzOiBpbnB1dEFkZHJlc3NlcyxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlczogaW5wdXRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgb3V0cHV0QWRkcmVzc2VzOiB0aGlzLm91dHB1dEFkZHJlc3NlcyxcbiAgICAgICAgICAgICAgICBvdXRwdXRWYWx1ZXM6IG91dHB1dFZhbHVlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9ucztcbiAgICB9XG4gICAgZ2V0SW5pdGlhbGx5VHJ1ZUFkZHJlc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlID8gdGhpcy5vdXRwdXRBZGRyZXNzZXMgOiBbXTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ2ljRWxlbWVudCA9IExvZ2ljRWxlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ2ljRWxlbWVudC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/LogicElement.js\n");

/***/ }),

/***/ "./out/js/NeverError.js":
/*!******************************!*\
  !*** ./out/js/NeverError.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass NeverError extends Error {\n    constructor(arg, message) {\n        super(message);\n    }\n}\nexports.NeverError = NeverError;\n//# sourceMappingURL=NeverError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvTmV2ZXJFcnJvci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9OZXZlckVycm9yLmpzPzU4YmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBOZXZlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFyZywgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLk5ldmVyRXJyb3IgPSBOZXZlckVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV2ZXJFcnJvci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/NeverError.js\n");

/***/ }),

/***/ "./out/js/Vollgas.js":
/*!***************************!*\
  !*** ./out/js/Vollgas.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GrammarParser_1 = __webpack_require__(/*! ./grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst CombinedGraphicalElement_1 = __webpack_require__(/*! ./graphics/CombinedGraphicalElement */ \"./out/js/graphics/CombinedGraphicalElement.js\");\nconst GraphicalCircuit_1 = __webpack_require__(/*! ./graphics/GraphicalCircuit */ \"./out/js/graphics/GraphicalCircuit.js\");\nclass Vollgas {\n    constructor(parseResult) {\n        this.parseResult = parseResult;\n    }\n    static usingGrammar(descriptions) {\n        let parseResult = GrammarParser_1.GrammarParser.parse(descriptions);\n        return new Vollgas(parseResult);\n    }\n    static from(description) {\n        let parseResult = GrammarParser_1.GrammarParser.fromParsed(description);\n        return new Vollgas(parseResult);\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let element = new CombinedGraphicalElement_1.CombinedGraphicalElement(\"root_element\", this.parseResult.height, this.parseResult.wiringDescriptions);\n            this.graphicalCircuit = new GraphicalCircuit_1.GraphicalCircuit(element, this.parseResult.disableGraphics, this.parseResult.stepsPerSecond, this.parseResult.delayPerWindowHeight, this.parseResult.echoData, this.parseResult.cyclesPerStep, this.parseResult.additionalNorDelay);\n            yield this.graphicalCircuit.init(this.parseResult.echoFunctions);\n            if (!this.parseResult.disableGraphics) {\n                return this.graphicalCircuit.app.view;\n            }\n            else {\n                return undefined;\n            }\n        });\n    }\n    manualStep(numSteps) {\n        this.graphicalCircuit.circuit.step(numSteps);\n    }\n    manualStepAndRedraw(numSteps) {\n        this.manualStep(numSteps);\n        this.graphicalCircuit.graphicalElement.redraw(0);\n    }\n}\nexports.default = Vollgas;\n//# sourceMappingURL=Vollgas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvVm9sbGdhcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9Wb2xsZ2FzLmpzPzJiNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEdyYW1tYXJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL2dyYW1tYXIvR3JhbW1hclBhcnNlclwiKTtcbmNvbnN0IENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xID0gcmVxdWlyZShcIi4vZ3JhcGhpY3MvQ29tYmluZWRHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsQ2lyY3VpdF8xID0gcmVxdWlyZShcIi4vZ3JhcGhpY3MvR3JhcGhpY2FsQ2lyY3VpdFwiKTtcbmNsYXNzIFZvbGxnYXMge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlUmVzdWx0KSB7XG4gICAgICAgIHRoaXMucGFyc2VSZXN1bHQgPSBwYXJzZVJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIHVzaW5nR3JhbW1hcihkZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgbGV0IHBhcnNlUmVzdWx0ID0gR3JhbW1hclBhcnNlcl8xLkdyYW1tYXJQYXJzZXIucGFyc2UoZGVzY3JpcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2xsZ2FzKHBhcnNlUmVzdWx0KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oZGVzY3JpcHRpb24pIHtcbiAgICAgICAgbGV0IHBhcnNlUmVzdWx0ID0gR3JhbW1hclBhcnNlcl8xLkdyYW1tYXJQYXJzZXIuZnJvbVBhcnNlZChkZXNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybiBuZXcgVm9sbGdhcyhwYXJzZVJlc3VsdCk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IG5ldyBDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMS5Db21iaW5lZEdyYXBoaWNhbEVsZW1lbnQoXCJyb290X2VsZW1lbnRcIiwgdGhpcy5wYXJzZVJlc3VsdC5oZWlnaHQsIHRoaXMucGFyc2VSZXN1bHQud2lyaW5nRGVzY3JpcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY2FsQ2lyY3VpdCA9IG5ldyBHcmFwaGljYWxDaXJjdWl0XzEuR3JhcGhpY2FsQ2lyY3VpdChlbGVtZW50LCB0aGlzLnBhcnNlUmVzdWx0LmRpc2FibGVHcmFwaGljcywgdGhpcy5wYXJzZVJlc3VsdC5zdGVwc1BlclNlY29uZCwgdGhpcy5wYXJzZVJlc3VsdC5kZWxheVBlcldpbmRvd0hlaWdodCwgdGhpcy5wYXJzZVJlc3VsdC5lY2hvRGF0YSwgdGhpcy5wYXJzZVJlc3VsdC5jeWNsZXNQZXJTdGVwLCB0aGlzLnBhcnNlUmVzdWx0LmFkZGl0aW9uYWxOb3JEZWxheSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdyYXBoaWNhbENpcmN1aXQuaW5pdCh0aGlzLnBhcnNlUmVzdWx0LmVjaG9GdW5jdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlUmVzdWx0LmRpc2FibGVHcmFwaGljcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdyYXBoaWNhbENpcmN1aXQuYXBwLnZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFudWFsU3RlcChudW1TdGVwcykge1xuICAgICAgICB0aGlzLmdyYXBoaWNhbENpcmN1aXQuY2lyY3VpdC5zdGVwKG51bVN0ZXBzKTtcbiAgICB9XG4gICAgbWFudWFsU3RlcEFuZFJlZHJhdyhudW1TdGVwcykge1xuICAgICAgICB0aGlzLm1hbnVhbFN0ZXAobnVtU3RlcHMpO1xuICAgICAgICB0aGlzLmdyYXBoaWNhbENpcmN1aXQuZ3JhcGhpY2FsRWxlbWVudC5yZWRyYXcoMCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVm9sbGdhcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZvbGxnYXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/Vollgas.js\n");

/***/ }),

/***/ "./out/js/Vollgas_global.js":
/*!**********************************!*\
  !*** ./out/js/Vollgas_global.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vollgas_1 = __webpack_require__(/*! ./Vollgas */ \"./out/js/Vollgas.js\");\nwindow.Vollgas = Vollgas_1.default;\n//# sourceMappingURL=Vollgas_global.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvVm9sbGdhc19nbG9iYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvVm9sbGdhc19nbG9iYWwuanM/NWE1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFZvbGxnYXNfMSA9IHJlcXVpcmUoXCIuL1ZvbGxnYXNcIik7XG53aW5kb3cuVm9sbGdhcyA9IFZvbGxnYXNfMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vm9sbGdhc19nbG9iYWwuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/Vollgas_global.js\n");

/***/ }),

/***/ "./out/js/WasmInstance.js":
/*!********************************!*\
  !*** ./out/js/WasmInstance.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst NeverError_1 = __webpack_require__(/*! ./NeverError */ \"./out/js/NeverError.js\");\nclass WasmInstance {\n    constructor(dataSource, moduloOperations, moduloOperationsMap, calculations) {\n        this.dataSource = dataSource;\n        let testUint8Array = new Uint8Array([0x78, 0x56, 0x34, 0x12]);\n        let testUint32Array = new Uint32Array(testUint8Array.buffer);\n        if (testUint32Array[0] !== 0x12345678) {\n            throw new Error(`system is not little-endian; this is not implemented`);\n        }\n        let functionBodyCode = this.makeFunctionBodyCode(moduloOperations, moduloOperationsMap, calculations);\n        this.code = [].concat(WasmInstance.MAGIC_NUMBER, WasmInstance.VERSION, this.makeTypeSectionWithHeader(), this.makeImportSectionWithHeader(dataSource), this.makeFunctionSectionWithHeader(), this.makeExportSectionWithHeader(), this.makeCodeSectionWithHeader(functionBodyCode));\n    }\n    instantiate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let memory = new WebAssembly.Memory({\n                initial: Math.ceil(this.dataSource.getTargetNumBytes() / WasmInstance.WASM_PAGE_SIZE),\n                maximum: Math.ceil(this.dataSource.getTargetNumBytes() / WasmInstance.WASM_PAGE_SIZE)\n            });\n            let instance = yield WebAssembly.instantiate(new Uint8Array(this.code), {\n                imports: {\n                    memory: memory\n                }\n            });\n            this.dataSource.setBuffer(memory.buffer);\n            let stepFunction = instance.instance.exports.step;\n            if (!stepFunction) {\n                throw new Error(`expected step function to be exported by wasm module, got exports: ${instance.instance.exports}`);\n            }\n            this.stepFunction = stepFunction;\n        });\n    }\n    step(numSteps) {\n        return this.stepFunction(numSteps);\n    }\n    makeFunctionBodyCode(moduloOperations, moduloOperationsMap, calculations) {\n        let code = [];\n        code.push(...WasmInstance.OPCODE.I32_CONST);\n        code.push(...WasmInstance.varint(0));\n        code.push(...WasmInstance.OPCODE.I64_LOAD);\n        code.push(...WasmInstance.varuint(3));\n        code.push(...WasmInstance.varuint(0));\n        code.push(...WasmInstance.OPCODE.SET_LOCAL);\n        code.push(...WasmInstance.varuint(1));\n        code.push(...WasmInstance.OPCODE.BLOCK);\n        code.push(...WasmInstance.TYPE.EMPTY);\n        code.push(...WasmInstance.OPCODE.LOOP);\n        code.push(...WasmInstance.TYPE.EMPTY);\n        code.push(...WasmInstance.OPCODE.GET_LOCAL);\n        code.push(...WasmInstance.varuint(0));\n        code.push(...WasmInstance.OPCODE.I32_EQZ);\n        code.push(...WasmInstance.OPCODE.BR_IF);\n        code.push(...WasmInstance.varuint(1));\n        code.push(...WasmInstance.OPCODE.GET_LOCAL);\n        code.push(...WasmInstance.varuint(0));\n        code.push(...WasmInstance.OPCODE.I32_CONST);\n        code.push(...WasmInstance.varint(1));\n        code.push(...WasmInstance.OPCODE.I32_SUB);\n        code.push(...WasmInstance.OPCODE.SET_LOCAL);\n        code.push(...WasmInstance.varuint(0));\n        code.push(...WasmInstance.OPCODE.GET_LOCAL);\n        code.push(...WasmInstance.varuint(1));\n        code.push(...WasmInstance.OPCODE.I64_CONST);\n        code.push(...WasmInstance.varint(1));\n        code.push(...WasmInstance.OPCODE.I64_ADD);\n        code.push(...WasmInstance.OPCODE.SET_LOCAL);\n        code.push(...WasmInstance.varuint(1));\n        for (let i = 0; i < moduloOperations.length; i++) {\n            let operation = moduloOperations[i];\n            code.push(...WasmInstance.OPCODE.I32_CONST);\n            code.push(...WasmInstance.varint(0));\n            code.push(...WasmInstance.OPCODE.GET_LOCAL);\n            code.push(...WasmInstance.varuint(1));\n            if (operation.startOffset !== 0) {\n                if (operation.startOffset < 0 || (operation.startOffset % 1) !== 0) {\n                    throw new Error(`RotatingAddress.startOffset: expected unsigned integer, got: ${operation.startOffset}`);\n                }\n                code.push(...WasmInstance.OPCODE.I64_CONST);\n                code.push(...WasmInstance.varint(operation.startOffset));\n                code.push(...WasmInstance.OPCODE.I64_ADD);\n            }\n            code.push(...WasmInstance.OPCODE.I64_CONST);\n            code.push(...WasmInstance.varint(operation.mod));\n            code.push(...WasmInstance.OPCODE.I64_REM_U);\n            code.push(...WasmInstance.OPCODE.I64_STORE32);\n            code.push(...WasmInstance.varuint(2));\n            code.push(...WasmInstance.varuint(4 * operation.address));\n        }\n        for (let i = 0; i < calculations.length; i++) {\n            let calculation = calculations[i];\n            code.push(...this.makeCalculationCode(calculation, moduloOperationsMap, i));\n        }\n        code.push(...WasmInstance.OPCODE.BR);\n        code.push(...WasmInstance.varuint(0));\n        code.push(...WasmInstance.OPCODE.END);\n        code.push(...WasmInstance.OPCODE.END);\n        code.push(...WasmInstance.OPCODE.I32_CONST);\n        code.push(...WasmInstance.varint(0));\n        code.push(...WasmInstance.OPCODE.GET_LOCAL);\n        code.push(...WasmInstance.varuint(1));\n        code.push(...WasmInstance.OPCODE.I64_STORE);\n        code.push(...WasmInstance.varuint(3));\n        code.push(...WasmInstance.varuint(0));\n        code.push(...WasmInstance.OPCODE.END);\n        return code;\n    }\n    makeCalculationCode(calculation, moduloOperationsMap, calculationIndex) {\n        if (!calculation.target) {\n            throw new Error(`target-less calculations not implemented: calculation index ${calculationIndex}: ${calculation}`);\n        }\n        return [].concat(this.makeAddressAddressPushCode(calculation.target, moduloOperationsMap), this.makeValueSourceReaderCode(calculation.value, moduloOperationsMap), WasmInstance.OPCODE.I32_STORE8, WasmInstance.varuint(0), WasmInstance.varuint(calculation.target.info.address));\n    }\n    makeAddressAddressPushCode(target, moduloOperationsMap) {\n        switch (target.type) {\n            case \"StaticAddress\": {\n                return [].concat(WasmInstance.OPCODE.I32_CONST, WasmInstance.varint(0));\n            }\n            case \"RotatingAddress\": {\n                let moduloOperationIndex = moduloOperationsMap[target.info.mod][target.info.startOffset];\n                return this.makeModuloResultPushCode(moduloOperationIndex);\n            }\n            default: {\n                throw new NeverError_1.NeverError(target, \"unexpected value source type\");\n            }\n        }\n    }\n    makeModuloResultPushCode(moduloOperationIndex) {\n        return [].concat(WasmInstance.OPCODE.I32_CONST, WasmInstance.varint(0), WasmInstance.OPCODE.I32_LOAD, WasmInstance.varuint(0), WasmInstance.varuint(4 * moduloOperationIndex));\n    }\n    makeValueSourceReaderCode(valueSource, moduloOperationsMap) {\n        switch (valueSource.type) {\n            case \"StaticAddress\":\n            case \"RotatingAddress\": {\n                return this.makeAddressReaderCode(valueSource, moduloOperationsMap);\n            }\n            case \"AndRule\":\n            case \"OrRule\": {\n                return this.makeRuleReaderCode(valueSource, moduloOperationsMap);\n            }\n            case \"NotRule\": {\n                return this.makeNotRuleReaderCode(valueSource, moduloOperationsMap);\n            }\n            case \"AlternatingValue\": {\n                return this.makeAlternatingValueReaderCode(valueSource, moduloOperationsMap);\n            }\n            default: {\n                throw new NeverError_1.NeverError(valueSource, \"unexpected value source type\");\n            }\n        }\n    }\n    makeAddressReaderCode(address, moduloOperationsMap) {\n        return [].concat(this.makeAddressAddressPushCode(address, moduloOperationsMap), WasmInstance.OPCODE.I32_LOAD8_U, WasmInstance.varuint(0), WasmInstance.varuint(address.info.address));\n    }\n    makeRuleReaderCode(rule, moduloOperationsMap) {\n        let code = [];\n        let op;\n        switch (rule.type) {\n            case \"AndRule\": {\n                op = WasmInstance.OPCODE.I32_AND;\n                break;\n            }\n            case \"OrRule\": {\n                op = WasmInstance.OPCODE.I32_OR;\n                break;\n            }\n            default: {\n                throw new NeverError_1.NeverError(rule, \"unexpected rule type\");\n            }\n        }\n        for (let i = 0; i < rule.value.length; i++) {\n            let valueSource = rule.value[i];\n            code.push(...this.makeValueSourceReaderCode(valueSource, moduloOperationsMap));\n            if (i > 0) {\n                code.push(...op);\n            }\n        }\n        return code;\n    }\n    makeNotRuleReaderCode(rule, moduloOperationsMap) {\n        return [].concat(this.makeValueSourceReaderCode(rule.value, moduloOperationsMap), WasmInstance.OPCODE.I32_EQZ);\n    }\n    makeAlternatingValueReaderCode(alternatingValue, moduloOperationsMap) {\n        let mod = alternatingValue.offDuration + alternatingValue.onDuration;\n        let moduloOperationIndex = moduloOperationsMap[mod][alternatingValue.startOffset];\n        return [].concat(this.makeModuloResultPushCode(moduloOperationIndex), WasmInstance.OPCODE.I32_CONST, WasmInstance.varint(alternatingValue.onDuration), WasmInstance.OPCODE.I32_LT_U);\n    }\n    makeSectionHeaderWithPayload(type, sectionPayload) {\n        return [].concat(type, WasmInstance.varuint(sectionPayload.length), sectionPayload);\n    }\n    makeTypeSectionWithHeader() {\n        let typeSectionPayload = [].concat(WasmInstance.varuint(1), WasmInstance.TYPE.FUNC, WasmInstance.varuint(1), WasmInstance.TYPE.I32, 0x00);\n        return this.makeSectionHeaderWithPayload(WasmInstance.SECTION_TYPE.TYPE, typeSectionPayload);\n    }\n    makeImportSectionWithHeader(dataSource) {\n        let importModuleName = \"imports\";\n        let importFieldName = \"memory\";\n        let importSectionPayload = [].concat(WasmInstance.varuint(1), WasmInstance.varuint32LengthAndBytes(importModuleName), WasmInstance.varuint32LengthAndBytes(importFieldName), WasmInstance.EXTERNAL_KIND.MEMORY, 0x01, WasmInstance.varuint(Math.ceil(dataSource.getTargetNumBytes() / WasmInstance.WASM_PAGE_SIZE)), WasmInstance.varuint(Math.ceil(dataSource.getTargetNumBytes() / WasmInstance.WASM_PAGE_SIZE)));\n        return this.makeSectionHeaderWithPayload(WasmInstance.SECTION_TYPE.IMPORT, importSectionPayload);\n    }\n    makeFunctionSectionWithHeader() {\n        let functionSectionPayload = [].concat(WasmInstance.varuint(1), WasmInstance.varuint(0));\n        return this.makeSectionHeaderWithPayload(WasmInstance.SECTION_TYPE.FUNCTION, functionSectionPayload);\n    }\n    makeExportSectionWithHeader() {\n        let exportSectionPayload = [].concat(WasmInstance.varuint(1), WasmInstance.varuint32LengthAndBytes(\"step\"), WasmInstance.EXTERNAL_KIND.FUNCTION, WasmInstance.varuint(0));\n        return this.makeSectionHeaderWithPayload(WasmInstance.SECTION_TYPE.EXPORT, exportSectionPayload);\n    }\n    makeCodeSectionWithHeader(functionBodyCode) {\n        let functionBody = [].concat(WasmInstance.varuint(1), WasmInstance.varuint(1), WasmInstance.TYPE.I64, functionBodyCode);\n        let codeSectionPayload = [].concat(WasmInstance.varuint(1), WasmInstance.varuint(functionBody.length), functionBody);\n        return this.makeSectionHeaderWithPayload(WasmInstance.SECTION_TYPE.CODE, codeSectionPayload);\n    }\n}\nexports.WasmInstance = WasmInstance;\n(function (WasmInstance) {\n    WasmInstance.WASM_PAGE_SIZE = (1 << 16);\n    WasmInstance.MAGIC_NUMBER = bytes(\"\\0asm\");\n    WasmInstance.VERSION = [0x01, 0x00, 0x00, 0x00];\n    WasmInstance.TYPE = {\n        I32: [0x7f],\n        I64: [0x7e],\n        F32: [0x7d],\n        F64: [0x7c],\n        ANYFUNC: [0x70],\n        FUNC: [0x60],\n        EMPTY: [0x40]\n    };\n    WasmInstance.EXTERNAL_KIND = {\n        FUNCTION: [0x00],\n        MEMORY: [0x02]\n    };\n    WasmInstance.SECTION_TYPE = {\n        TYPE: [0x01],\n        IMPORT: [0x02],\n        FUNCTION: [0x03],\n        TABLE: [0x04],\n        MEMORY: [0x05],\n        GLOBAL: [0x06],\n        EXPORT: [0x07],\n        START: [0x08],\n        ELEMENT: [0x09],\n        CODE: [0x0a],\n        DATA: [0x0b]\n    };\n    WasmInstance.OPCODE = {\n        UNREACHABLE: [0x00],\n        NOP: [0x01],\n        BLOCK: [0x02],\n        LOOP: [0x03],\n        IF: [0x04],\n        ELSE: [0x05],\n        END: [0x0b],\n        BR: [0x0c],\n        BR_IF: [0x0d],\n        BR_TABLE: [0x0e],\n        RETURN: [0x0f],\n        GET_LOCAL: [0x20],\n        SET_LOCAL: [0x21],\n        TEE_LOCAL: [0x22],\n        GET_GLOBAL: [0x23],\n        SET_GLOBAL: [0x24],\n        I32_LOAD: [0x28],\n        I64_LOAD: [0x29],\n        I32_LOAD8_U: [0x2d],\n        I32_STORE: [0x36],\n        I64_STORE: [0x37],\n        I32_STORE8: [0x3a],\n        I64_STORE32: [0x3e],\n        I32_CONST: [0x41],\n        I64_CONST: [0x42],\n        I32_EQZ: [0x45],\n        I32_LT_U: [0x49],\n        I64_EQZ: [0x50],\n        I32_SUB: [0x6b],\n        I32_AND: [0x71],\n        I32_OR: [0x72],\n        I64_ADD: [0x7c],\n        I64_SUB: [0x7d],\n        I64_REM_U: [0x82],\n        I64_EXTEND_U_I32: [0xad]\n    };\n    function varuint(num) {\n        if (num < 0 || (num % 1) !== 0) {\n            throw new Error(`varuint: expected unsigned integer, got: ${num}`);\n        }\n        let bytes = [];\n        for (;;) {\n            let part = num & 0x7F;\n            num >>= 7;\n            if (num !== 0) {\n                part |= 0x80;\n            }\n            bytes.push(part);\n            if (num === 0) {\n                break;\n            }\n        }\n        return bytes;\n    }\n    WasmInstance.varuint = varuint;\n    function varint(num) {\n        if ((num % 1) !== 0) {\n            throw new Error(`varuint: expected signed integer, got: ${num}`);\n        }\n        let bytes = [];\n        for (;;) {\n            let part = num & 0x7F;\n            num >>= 7;\n            let done = (num === 0 && (part & 0x40) === 0) || (num === -1 && (part & 0x40) !== 0);\n            if (!done) {\n                part |= 0x80;\n            }\n            bytes.push(part);\n            if (done) {\n                break;\n            }\n        }\n        return bytes;\n    }\n    WasmInstance.varint = varint;\n    function bytes(str) {\n        return str.split(\"\").map((c) => c.charCodeAt(0));\n    }\n    WasmInstance.bytes = bytes;\n    function varuint32LengthAndBytes(str) {\n        let b = bytes(str);\n        return varuint(b.length).concat(b);\n    }\n    WasmInstance.varuint32LengthAndBytes = varuint32LengthAndBytes;\n})(WasmInstance = exports.WasmInstance || (exports.WasmInstance = {}));\n//# sourceMappingURL=WasmInstance.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvV2FzbUluc3RhbmNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL1dhc21JbnN0YW5jZS5qcz8yMjkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBOZXZlckVycm9yXzEgPSByZXF1aXJlKFwiLi9OZXZlckVycm9yXCIpO1xuY2xhc3MgV2FzbUluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhU291cmNlLCBtb2R1bG9PcGVyYXRpb25zLCBtb2R1bG9PcGVyYXRpb25zTWFwLCBjYWxjdWxhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgbGV0IHRlc3RVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoWzB4NzgsIDB4NTYsIDB4MzQsIDB4MTJdKTtcbiAgICAgICAgbGV0IHRlc3RVaW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSh0ZXN0VWludDhBcnJheS5idWZmZXIpO1xuICAgICAgICBpZiAodGVzdFVpbnQzMkFycmF5WzBdICE9PSAweDEyMzQ1Njc4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN5c3RlbSBpcyBub3QgbGl0dGxlLWVuZGlhbjsgdGhpcyBpcyBub3QgaW1wbGVtZW50ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVuY3Rpb25Cb2R5Q29kZSA9IHRoaXMubWFrZUZ1bmN0aW9uQm9keUNvZGUobW9kdWxvT3BlcmF0aW9ucywgbW9kdWxvT3BlcmF0aW9uc01hcCwgY2FsY3VsYXRpb25zKTtcbiAgICAgICAgdGhpcy5jb2RlID0gW10uY29uY2F0KFdhc21JbnN0YW5jZS5NQUdJQ19OVU1CRVIsIFdhc21JbnN0YW5jZS5WRVJTSU9OLCB0aGlzLm1ha2VUeXBlU2VjdGlvbldpdGhIZWFkZXIoKSwgdGhpcy5tYWtlSW1wb3J0U2VjdGlvbldpdGhIZWFkZXIoZGF0YVNvdXJjZSksIHRoaXMubWFrZUZ1bmN0aW9uU2VjdGlvbldpdGhIZWFkZXIoKSwgdGhpcy5tYWtlRXhwb3J0U2VjdGlvbldpdGhIZWFkZXIoKSwgdGhpcy5tYWtlQ29kZVNlY3Rpb25XaXRoSGVhZGVyKGZ1bmN0aW9uQm9keUNvZGUpKTtcbiAgICB9XG4gICAgaW5zdGFudGlhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAgICAgICAgICAgaW5pdGlhbDogTWF0aC5jZWlsKHRoaXMuZGF0YVNvdXJjZS5nZXRUYXJnZXROdW1CeXRlcygpIC8gV2FzbUluc3RhbmNlLldBU01fUEFHRV9TSVpFKSxcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiBNYXRoLmNlaWwodGhpcy5kYXRhU291cmNlLmdldFRhcmdldE51bUJ5dGVzKCkgLyBXYXNtSW5zdGFuY2UuV0FTTV9QQUdFX1NJWkUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IHlpZWxkIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG5ldyBVaW50OEFycmF5KHRoaXMuY29kZSksIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeTogbWVtb3J5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0QnVmZmVyKG1lbW9yeS5idWZmZXIpO1xuICAgICAgICAgICAgbGV0IHN0ZXBGdW5jdGlvbiA9IGluc3RhbmNlLmluc3RhbmNlLmV4cG9ydHMuc3RlcDtcbiAgICAgICAgICAgIGlmICghc3RlcEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBzdGVwIGZ1bmN0aW9uIHRvIGJlIGV4cG9ydGVkIGJ5IHdhc20gbW9kdWxlLCBnb3QgZXhwb3J0czogJHtpbnN0YW5jZS5pbnN0YW5jZS5leHBvcnRzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGVwRnVuY3Rpb24gPSBzdGVwRnVuY3Rpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGVwKG51bVN0ZXBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBGdW5jdGlvbihudW1TdGVwcyk7XG4gICAgfVxuICAgIG1ha2VGdW5jdGlvbkJvZHlDb2RlKG1vZHVsb09wZXJhdGlvbnMsIG1vZHVsb09wZXJhdGlvbnNNYXAsIGNhbGN1bGF0aW9ucykge1xuICAgICAgICBsZXQgY29kZSA9IFtdO1xuICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLk9QQ09ERS5JMzJfQ09OU1QpO1xuICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLnZhcmludCgwKSk7XG4gICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UuT1BDT0RFLkk2NF9MT0FEKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDMpKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDApKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuU0VUX0xPQ0FMKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDEpKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuQkxPQ0spO1xuICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLlRZUEUuRU1QVFkpO1xuICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLk9QQ09ERS5MT09QKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5UWVBFLkVNUFRZKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuR0VUX0xPQ0FMKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDApKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuSTMyX0VRWik7XG4gICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UuT1BDT0RFLkJSX0lGKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDEpKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuR0VUX0xPQ0FMKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDApKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuSTMyX0NPTlNUKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJpbnQoMSkpO1xuICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLk9QQ09ERS5JMzJfU1VCKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuU0VUX0xPQ0FMKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDApKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuR0VUX0xPQ0FMKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDEpKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuSTY0X0NPTlNUKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJpbnQoMSkpO1xuICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLk9QQ09ERS5JNjRfQUREKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuU0VUX0xPQ0FMKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDEpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2R1bG9PcGVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3BlcmF0aW9uID0gbW9kdWxvT3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UuT1BDT0RFLkkzMl9DT05TVCk7XG4gICAgICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLnZhcmludCgwKSk7XG4gICAgICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLk9QQ09ERS5HRVRfTE9DQUwpO1xuICAgICAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDEpKTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24uc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLnN0YXJ0T2Zmc2V0IDwgMCB8fCAob3BlcmF0aW9uLnN0YXJ0T2Zmc2V0ICUgMSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb3RhdGluZ0FkZHJlc3Muc3RhcnRPZmZzZXQ6IGV4cGVjdGVkIHVuc2lnbmVkIGludGVnZXIsIGdvdDogJHtvcGVyYXRpb24uc3RhcnRPZmZzZXR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UuT1BDT0RFLkk2NF9DT05TVCk7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJpbnQob3BlcmF0aW9uLnN0YXJ0T2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuSTY0X0FERCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLk9QQ09ERS5JNjRfQ09OU1QpO1xuICAgICAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJpbnQob3BlcmF0aW9uLm1vZCkpO1xuICAgICAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuSTY0X1JFTV9VKTtcbiAgICAgICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UuT1BDT0RFLkk2NF9TVE9SRTMyKTtcbiAgICAgICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UudmFydWludCgyKSk7XG4gICAgICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLnZhcnVpbnQoNCAqIG9wZXJhdGlvbi5hZGRyZXNzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxjdWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjYWxjdWxhdGlvbiA9IGNhbGN1bGF0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvZGUucHVzaCguLi50aGlzLm1ha2VDYWxjdWxhdGlvbkNvZGUoY2FsY3VsYXRpb24sIG1vZHVsb09wZXJhdGlvbnNNYXAsIGkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goLi4uV2FzbUluc3RhbmNlLk9QQ09ERS5CUik7XG4gICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UudmFydWludCgwKSk7XG4gICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UuT1BDT0RFLkVORCk7XG4gICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UuT1BDT0RFLkVORCk7XG4gICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UuT1BDT0RFLkkzMl9DT05TVCk7XG4gICAgICAgIGNvZGUucHVzaCguLi5XYXNtSW5zdGFuY2UudmFyaW50KDApKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuR0VUX0xPQ0FMKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDEpKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuSTY0X1NUT1JFKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDMpKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS52YXJ1aW50KDApKTtcbiAgICAgICAgY29kZS5wdXNoKC4uLldhc21JbnN0YW5jZS5PUENPREUuRU5EKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIG1ha2VDYWxjdWxhdGlvbkNvZGUoY2FsY3VsYXRpb24sIG1vZHVsb09wZXJhdGlvbnNNYXAsIGNhbGN1bGF0aW9uSW5kZXgpIHtcbiAgICAgICAgaWYgKCFjYWxjdWxhdGlvbi50YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdGFyZ2V0LWxlc3MgY2FsY3VsYXRpb25zIG5vdCBpbXBsZW1lbnRlZDogY2FsY3VsYXRpb24gaW5kZXggJHtjYWxjdWxhdGlvbkluZGV4fTogJHtjYWxjdWxhdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW10uY29uY2F0KHRoaXMubWFrZUFkZHJlc3NBZGRyZXNzUHVzaENvZGUoY2FsY3VsYXRpb24udGFyZ2V0LCBtb2R1bG9PcGVyYXRpb25zTWFwKSwgdGhpcy5tYWtlVmFsdWVTb3VyY2VSZWFkZXJDb2RlKGNhbGN1bGF0aW9uLnZhbHVlLCBtb2R1bG9PcGVyYXRpb25zTWFwKSwgV2FzbUluc3RhbmNlLk9QQ09ERS5JMzJfU1RPUkU4LCBXYXNtSW5zdGFuY2UudmFydWludCgwKSwgV2FzbUluc3RhbmNlLnZhcnVpbnQoY2FsY3VsYXRpb24udGFyZ2V0LmluZm8uYWRkcmVzcykpO1xuICAgIH1cbiAgICBtYWtlQWRkcmVzc0FkZHJlc3NQdXNoQ29kZSh0YXJnZXQsIG1vZHVsb09wZXJhdGlvbnNNYXApIHtcbiAgICAgICAgc3dpdGNoICh0YXJnZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIlN0YXRpY0FkZHJlc3NcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoV2FzbUluc3RhbmNlLk9QQ09ERS5JMzJfQ09OU1QsIFdhc21JbnN0YW5jZS52YXJpbnQoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIlJvdGF0aW5nQWRkcmVzc1wiOiB7XG4gICAgICAgICAgICAgICAgbGV0IG1vZHVsb09wZXJhdGlvbkluZGV4ID0gbW9kdWxvT3BlcmF0aW9uc01hcFt0YXJnZXQuaW5mby5tb2RdW3RhcmdldC5pbmZvLnN0YXJ0T2Zmc2V0XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlTW9kdWxvUmVzdWx0UHVzaENvZGUobW9kdWxvT3BlcmF0aW9uSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOZXZlckVycm9yXzEuTmV2ZXJFcnJvcih0YXJnZXQsIFwidW5leHBlY3RlZCB2YWx1ZSBzb3VyY2UgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYWtlTW9kdWxvUmVzdWx0UHVzaENvZGUobW9kdWxvT3BlcmF0aW9uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChXYXNtSW5zdGFuY2UuT1BDT0RFLkkzMl9DT05TVCwgV2FzbUluc3RhbmNlLnZhcmludCgwKSwgV2FzbUluc3RhbmNlLk9QQ09ERS5JMzJfTE9BRCwgV2FzbUluc3RhbmNlLnZhcnVpbnQoMCksIFdhc21JbnN0YW5jZS52YXJ1aW50KDQgKiBtb2R1bG9PcGVyYXRpb25JbmRleCkpO1xuICAgIH1cbiAgICBtYWtlVmFsdWVTb3VyY2VSZWFkZXJDb2RlKHZhbHVlU291cmNlLCBtb2R1bG9PcGVyYXRpb25zTWFwKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWVTb3VyY2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIlN0YXRpY0FkZHJlc3NcIjpcbiAgICAgICAgICAgIGNhc2UgXCJSb3RhdGluZ0FkZHJlc3NcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VBZGRyZXNzUmVhZGVyQ29kZSh2YWx1ZVNvdXJjZSwgbW9kdWxvT3BlcmF0aW9uc01hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiQW5kUnVsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIk9yUnVsZVwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVJ1bGVSZWFkZXJDb2RlKHZhbHVlU291cmNlLCBtb2R1bG9PcGVyYXRpb25zTWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJOb3RSdWxlXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlTm90UnVsZVJlYWRlckNvZGUodmFsdWVTb3VyY2UsIG1vZHVsb09wZXJhdGlvbnNNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkFsdGVybmF0aW5nVmFsdWVcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VBbHRlcm5hdGluZ1ZhbHVlUmVhZGVyQ29kZSh2YWx1ZVNvdXJjZSwgbW9kdWxvT3BlcmF0aW9uc01hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5ldmVyRXJyb3JfMS5OZXZlckVycm9yKHZhbHVlU291cmNlLCBcInVuZXhwZWN0ZWQgdmFsdWUgc291cmNlIHR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFrZUFkZHJlc3NSZWFkZXJDb2RlKGFkZHJlc3MsIG1vZHVsb09wZXJhdGlvbnNNYXApIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLm1ha2VBZGRyZXNzQWRkcmVzc1B1c2hDb2RlKGFkZHJlc3MsIG1vZHVsb09wZXJhdGlvbnNNYXApLCBXYXNtSW5zdGFuY2UuT1BDT0RFLkkzMl9MT0FEOF9VLCBXYXNtSW5zdGFuY2UudmFydWludCgwKSwgV2FzbUluc3RhbmNlLnZhcnVpbnQoYWRkcmVzcy5pbmZvLmFkZHJlc3MpKTtcbiAgICB9XG4gICAgbWFrZVJ1bGVSZWFkZXJDb2RlKHJ1bGUsIG1vZHVsb09wZXJhdGlvbnNNYXApIHtcbiAgICAgICAgbGV0IGNvZGUgPSBbXTtcbiAgICAgICAgbGV0IG9wO1xuICAgICAgICBzd2l0Y2ggKHJ1bGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkFuZFJ1bGVcIjoge1xuICAgICAgICAgICAgICAgIG9wID0gV2FzbUluc3RhbmNlLk9QQ09ERS5JMzJfQU5EO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIk9yUnVsZVwiOiB7XG4gICAgICAgICAgICAgICAgb3AgPSBXYXNtSW5zdGFuY2UuT1BDT0RFLkkzMl9PUjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmV2ZXJFcnJvcl8xLk5ldmVyRXJyb3IocnVsZSwgXCJ1bmV4cGVjdGVkIHJ1bGUgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZVNvdXJjZSA9IHJ1bGUudmFsdWVbaV07XG4gICAgICAgICAgICBjb2RlLnB1c2goLi4udGhpcy5tYWtlVmFsdWVTb3VyY2VSZWFkZXJDb2RlKHZhbHVlU291cmNlLCBtb2R1bG9PcGVyYXRpb25zTWFwKSk7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goLi4ub3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBtYWtlTm90UnVsZVJlYWRlckNvZGUocnVsZSwgbW9kdWxvT3BlcmF0aW9uc01hcCkge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KHRoaXMubWFrZVZhbHVlU291cmNlUmVhZGVyQ29kZShydWxlLnZhbHVlLCBtb2R1bG9PcGVyYXRpb25zTWFwKSwgV2FzbUluc3RhbmNlLk9QQ09ERS5JMzJfRVFaKTtcbiAgICB9XG4gICAgbWFrZUFsdGVybmF0aW5nVmFsdWVSZWFkZXJDb2RlKGFsdGVybmF0aW5nVmFsdWUsIG1vZHVsb09wZXJhdGlvbnNNYXApIHtcbiAgICAgICAgbGV0IG1vZCA9IGFsdGVybmF0aW5nVmFsdWUub2ZmRHVyYXRpb24gKyBhbHRlcm5hdGluZ1ZhbHVlLm9uRHVyYXRpb247XG4gICAgICAgIGxldCBtb2R1bG9PcGVyYXRpb25JbmRleCA9IG1vZHVsb09wZXJhdGlvbnNNYXBbbW9kXVthbHRlcm5hdGluZ1ZhbHVlLnN0YXJ0T2Zmc2V0XTtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLm1ha2VNb2R1bG9SZXN1bHRQdXNoQ29kZShtb2R1bG9PcGVyYXRpb25JbmRleCksIFdhc21JbnN0YW5jZS5PUENPREUuSTMyX0NPTlNULCBXYXNtSW5zdGFuY2UudmFyaW50KGFsdGVybmF0aW5nVmFsdWUub25EdXJhdGlvbiksIFdhc21JbnN0YW5jZS5PUENPREUuSTMyX0xUX1UpO1xuICAgIH1cbiAgICBtYWtlU2VjdGlvbkhlYWRlcldpdGhQYXlsb2FkKHR5cGUsIHNlY3Rpb25QYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQodHlwZSwgV2FzbUluc3RhbmNlLnZhcnVpbnQoc2VjdGlvblBheWxvYWQubGVuZ3RoKSwgc2VjdGlvblBheWxvYWQpO1xuICAgIH1cbiAgICBtYWtlVHlwZVNlY3Rpb25XaXRoSGVhZGVyKCkge1xuICAgICAgICBsZXQgdHlwZVNlY3Rpb25QYXlsb2FkID0gW10uY29uY2F0KFdhc21JbnN0YW5jZS52YXJ1aW50KDEpLCBXYXNtSW5zdGFuY2UuVFlQRS5GVU5DLCBXYXNtSW5zdGFuY2UudmFydWludCgxKSwgV2FzbUluc3RhbmNlLlRZUEUuSTMyLCAweDAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZVNlY3Rpb25IZWFkZXJXaXRoUGF5bG9hZChXYXNtSW5zdGFuY2UuU0VDVElPTl9UWVBFLlRZUEUsIHR5cGVTZWN0aW9uUGF5bG9hZCk7XG4gICAgfVxuICAgIG1ha2VJbXBvcnRTZWN0aW9uV2l0aEhlYWRlcihkYXRhU291cmNlKSB7XG4gICAgICAgIGxldCBpbXBvcnRNb2R1bGVOYW1lID0gXCJpbXBvcnRzXCI7XG4gICAgICAgIGxldCBpbXBvcnRGaWVsZE5hbWUgPSBcIm1lbW9yeVwiO1xuICAgICAgICBsZXQgaW1wb3J0U2VjdGlvblBheWxvYWQgPSBbXS5jb25jYXQoV2FzbUluc3RhbmNlLnZhcnVpbnQoMSksIFdhc21JbnN0YW5jZS52YXJ1aW50MzJMZW5ndGhBbmRCeXRlcyhpbXBvcnRNb2R1bGVOYW1lKSwgV2FzbUluc3RhbmNlLnZhcnVpbnQzMkxlbmd0aEFuZEJ5dGVzKGltcG9ydEZpZWxkTmFtZSksIFdhc21JbnN0YW5jZS5FWFRFUk5BTF9LSU5ELk1FTU9SWSwgMHgwMSwgV2FzbUluc3RhbmNlLnZhcnVpbnQoTWF0aC5jZWlsKGRhdGFTb3VyY2UuZ2V0VGFyZ2V0TnVtQnl0ZXMoKSAvIFdhc21JbnN0YW5jZS5XQVNNX1BBR0VfU0laRSkpLCBXYXNtSW5zdGFuY2UudmFydWludChNYXRoLmNlaWwoZGF0YVNvdXJjZS5nZXRUYXJnZXROdW1CeXRlcygpIC8gV2FzbUluc3RhbmNlLldBU01fUEFHRV9TSVpFKSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlU2VjdGlvbkhlYWRlcldpdGhQYXlsb2FkKFdhc21JbnN0YW5jZS5TRUNUSU9OX1RZUEUuSU1QT1JULCBpbXBvcnRTZWN0aW9uUGF5bG9hZCk7XG4gICAgfVxuICAgIG1ha2VGdW5jdGlvblNlY3Rpb25XaXRoSGVhZGVyKCkge1xuICAgICAgICBsZXQgZnVuY3Rpb25TZWN0aW9uUGF5bG9hZCA9IFtdLmNvbmNhdChXYXNtSW5zdGFuY2UudmFydWludCgxKSwgV2FzbUluc3RhbmNlLnZhcnVpbnQoMCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlU2VjdGlvbkhlYWRlcldpdGhQYXlsb2FkKFdhc21JbnN0YW5jZS5TRUNUSU9OX1RZUEUuRlVOQ1RJT04sIGZ1bmN0aW9uU2VjdGlvblBheWxvYWQpO1xuICAgIH1cbiAgICBtYWtlRXhwb3J0U2VjdGlvbldpdGhIZWFkZXIoKSB7XG4gICAgICAgIGxldCBleHBvcnRTZWN0aW9uUGF5bG9hZCA9IFtdLmNvbmNhdChXYXNtSW5zdGFuY2UudmFydWludCgxKSwgV2FzbUluc3RhbmNlLnZhcnVpbnQzMkxlbmd0aEFuZEJ5dGVzKFwic3RlcFwiKSwgV2FzbUluc3RhbmNlLkVYVEVSTkFMX0tJTkQuRlVOQ1RJT04sIFdhc21JbnN0YW5jZS52YXJ1aW50KDApKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZVNlY3Rpb25IZWFkZXJXaXRoUGF5bG9hZChXYXNtSW5zdGFuY2UuU0VDVElPTl9UWVBFLkVYUE9SVCwgZXhwb3J0U2VjdGlvblBheWxvYWQpO1xuICAgIH1cbiAgICBtYWtlQ29kZVNlY3Rpb25XaXRoSGVhZGVyKGZ1bmN0aW9uQm9keUNvZGUpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uQm9keSA9IFtdLmNvbmNhdChXYXNtSW5zdGFuY2UudmFydWludCgxKSwgV2FzbUluc3RhbmNlLnZhcnVpbnQoMSksIFdhc21JbnN0YW5jZS5UWVBFLkk2NCwgZnVuY3Rpb25Cb2R5Q29kZSk7XG4gICAgICAgIGxldCBjb2RlU2VjdGlvblBheWxvYWQgPSBbXS5jb25jYXQoV2FzbUluc3RhbmNlLnZhcnVpbnQoMSksIFdhc21JbnN0YW5jZS52YXJ1aW50KGZ1bmN0aW9uQm9keS5sZW5ndGgpLCBmdW5jdGlvbkJvZHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlU2VjdGlvbkhlYWRlcldpdGhQYXlsb2FkKFdhc21JbnN0YW5jZS5TRUNUSU9OX1RZUEUuQ09ERSwgY29kZVNlY3Rpb25QYXlsb2FkKTtcbiAgICB9XG59XG5leHBvcnRzLldhc21JbnN0YW5jZSA9IFdhc21JbnN0YW5jZTtcbihmdW5jdGlvbiAoV2FzbUluc3RhbmNlKSB7XG4gICAgV2FzbUluc3RhbmNlLldBU01fUEFHRV9TSVpFID0gKDEgPDwgMTYpO1xuICAgIFdhc21JbnN0YW5jZS5NQUdJQ19OVU1CRVIgPSBieXRlcyhcIlxcMGFzbVwiKTtcbiAgICBXYXNtSW5zdGFuY2UuVkVSU0lPTiA9IFsweDAxLCAweDAwLCAweDAwLCAweDAwXTtcbiAgICBXYXNtSW5zdGFuY2UuVFlQRSA9IHtcbiAgICAgICAgSTMyOiBbMHg3Zl0sXG4gICAgICAgIEk2NDogWzB4N2VdLFxuICAgICAgICBGMzI6IFsweDdkXSxcbiAgICAgICAgRjY0OiBbMHg3Y10sXG4gICAgICAgIEFOWUZVTkM6IFsweDcwXSxcbiAgICAgICAgRlVOQzogWzB4NjBdLFxuICAgICAgICBFTVBUWTogWzB4NDBdXG4gICAgfTtcbiAgICBXYXNtSW5zdGFuY2UuRVhURVJOQUxfS0lORCA9IHtcbiAgICAgICAgRlVOQ1RJT046IFsweDAwXSxcbiAgICAgICAgTUVNT1JZOiBbMHgwMl1cbiAgICB9O1xuICAgIFdhc21JbnN0YW5jZS5TRUNUSU9OX1RZUEUgPSB7XG4gICAgICAgIFRZUEU6IFsweDAxXSxcbiAgICAgICAgSU1QT1JUOiBbMHgwMl0sXG4gICAgICAgIEZVTkNUSU9OOiBbMHgwM10sXG4gICAgICAgIFRBQkxFOiBbMHgwNF0sXG4gICAgICAgIE1FTU9SWTogWzB4MDVdLFxuICAgICAgICBHTE9CQUw6IFsweDA2XSxcbiAgICAgICAgRVhQT1JUOiBbMHgwN10sXG4gICAgICAgIFNUQVJUOiBbMHgwOF0sXG4gICAgICAgIEVMRU1FTlQ6IFsweDA5XSxcbiAgICAgICAgQ09ERTogWzB4MGFdLFxuICAgICAgICBEQVRBOiBbMHgwYl1cbiAgICB9O1xuICAgIFdhc21JbnN0YW5jZS5PUENPREUgPSB7XG4gICAgICAgIFVOUkVBQ0hBQkxFOiBbMHgwMF0sXG4gICAgICAgIE5PUDogWzB4MDFdLFxuICAgICAgICBCTE9DSzogWzB4MDJdLFxuICAgICAgICBMT09QOiBbMHgwM10sXG4gICAgICAgIElGOiBbMHgwNF0sXG4gICAgICAgIEVMU0U6IFsweDA1XSxcbiAgICAgICAgRU5EOiBbMHgwYl0sXG4gICAgICAgIEJSOiBbMHgwY10sXG4gICAgICAgIEJSX0lGOiBbMHgwZF0sXG4gICAgICAgIEJSX1RBQkxFOiBbMHgwZV0sXG4gICAgICAgIFJFVFVSTjogWzB4MGZdLFxuICAgICAgICBHRVRfTE9DQUw6IFsweDIwXSxcbiAgICAgICAgU0VUX0xPQ0FMOiBbMHgyMV0sXG4gICAgICAgIFRFRV9MT0NBTDogWzB4MjJdLFxuICAgICAgICBHRVRfR0xPQkFMOiBbMHgyM10sXG4gICAgICAgIFNFVF9HTE9CQUw6IFsweDI0XSxcbiAgICAgICAgSTMyX0xPQUQ6IFsweDI4XSxcbiAgICAgICAgSTY0X0xPQUQ6IFsweDI5XSxcbiAgICAgICAgSTMyX0xPQUQ4X1U6IFsweDJkXSxcbiAgICAgICAgSTMyX1NUT1JFOiBbMHgzNl0sXG4gICAgICAgIEk2NF9TVE9SRTogWzB4MzddLFxuICAgICAgICBJMzJfU1RPUkU4OiBbMHgzYV0sXG4gICAgICAgIEk2NF9TVE9SRTMyOiBbMHgzZV0sXG4gICAgICAgIEkzMl9DT05TVDogWzB4NDFdLFxuICAgICAgICBJNjRfQ09OU1Q6IFsweDQyXSxcbiAgICAgICAgSTMyX0VRWjogWzB4NDVdLFxuICAgICAgICBJMzJfTFRfVTogWzB4NDldLFxuICAgICAgICBJNjRfRVFaOiBbMHg1MF0sXG4gICAgICAgIEkzMl9TVUI6IFsweDZiXSxcbiAgICAgICAgSTMyX0FORDogWzB4NzFdLFxuICAgICAgICBJMzJfT1I6IFsweDcyXSxcbiAgICAgICAgSTY0X0FERDogWzB4N2NdLFxuICAgICAgICBJNjRfU1VCOiBbMHg3ZF0sXG4gICAgICAgIEk2NF9SRU1fVTogWzB4ODJdLFxuICAgICAgICBJNjRfRVhURU5EX1VfSTMyOiBbMHhhZF1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHZhcnVpbnQobnVtKSB7XG4gICAgICAgIGlmIChudW0gPCAwIHx8IChudW0gJSAxKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YXJ1aW50OiBleHBlY3RlZCB1bnNpZ25lZCBpbnRlZ2VyLCBnb3Q6ICR7bnVtfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IG51bSAmIDB4N0Y7XG4gICAgICAgICAgICBudW0gPj49IDc7XG4gICAgICAgICAgICBpZiAobnVtICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcGFydCB8PSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZXMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIGlmIChudW0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIFdhc21JbnN0YW5jZS52YXJ1aW50ID0gdmFydWludDtcbiAgICBmdW5jdGlvbiB2YXJpbnQobnVtKSB7XG4gICAgICAgIGlmICgobnVtICUgMSkgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFydWludDogZXhwZWN0ZWQgc2lnbmVkIGludGVnZXIsIGdvdDogJHtudW19YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ5dGVzID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gbnVtICYgMHg3RjtcbiAgICAgICAgICAgIG51bSA+Pj0gNztcbiAgICAgICAgICAgIGxldCBkb25lID0gKG51bSA9PT0gMCAmJiAocGFydCAmIDB4NDApID09PSAwKSB8fCAobnVtID09PSAtMSAmJiAocGFydCAmIDB4NDApICE9PSAwKTtcbiAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgIHBhcnQgfD0gMHg4MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzLnB1c2gocGFydCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgV2FzbUluc3RhbmNlLnZhcmludCA9IHZhcmludDtcbiAgICBmdW5jdGlvbiBieXRlcyhzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5zcGxpdChcIlwiKS5tYXAoKGMpID0+IGMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICAgIFdhc21JbnN0YW5jZS5ieXRlcyA9IGJ5dGVzO1xuICAgIGZ1bmN0aW9uIHZhcnVpbnQzMkxlbmd0aEFuZEJ5dGVzKHN0cikge1xuICAgICAgICBsZXQgYiA9IGJ5dGVzKHN0cik7XG4gICAgICAgIHJldHVybiB2YXJ1aW50KGIubGVuZ3RoKS5jb25jYXQoYik7XG4gICAgfVxuICAgIFdhc21JbnN0YW5jZS52YXJ1aW50MzJMZW5ndGhBbmRCeXRlcyA9IHZhcnVpbnQzMkxlbmd0aEFuZEJ5dGVzO1xufSkoV2FzbUluc3RhbmNlID0gZXhwb3J0cy5XYXNtSW5zdGFuY2UgfHwgKGV4cG9ydHMuV2FzbUluc3RhbmNlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhc21JbnN0YW5jZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/WasmInstance.js\n");

/***/ }),

/***/ "./out/js/elements/Micro16Clock.js":
/*!*****************************************!*\
  !*** ./out/js/elements/Micro16Clock.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LogicElement_1 = __webpack_require__(/*! ../LogicElement */ \"./out/js/LogicElement.js\");\nconst ConnectedElement_1 = __webpack_require__(/*! ../ConnectedElement */ \"./out/js/ConnectedElement.js\");\nclass Micro16Clock extends LogicElement_1.LogicElement {\n    constructor(name, instructionDelay = 800, aluDelay = 1400, registersDelay = 400) {\n        super(name, 0, 3);\n        this.delays = [instructionDelay, aluDelay, registersDelay];\n    }\n    makeCalculations(inputSpace, outputSpace) {\n        let calculations = {\n            calculations: [],\n            outputAddresses: []\n        };\n        let delaySum = 0;\n        for (let delay of this.delays) {\n            delaySum += delay;\n        }\n        let onDurationSoFar = 0;\n        for (let i = 0; i < this.delays.length; i++) {\n            let address = new ConnectedElement_1.ConnectedElement.StaticAddress({\n                space: outputSpace,\n                address: i,\n                hint: `static output address for output ${i} of micro16 clock ${this.getName()}`\n            });\n            calculations.calculations.push({\n                target: address,\n                value: {\n                    type: \"AlternatingValue\",\n                    onDuration: this.delays[i],\n                    offDuration: delaySum - this.delays[i],\n                    startOffset: delaySum - onDurationSoFar\n                }\n            });\n            onDurationSoFar += this.delays[i];\n            calculations.outputAddresses.push(address);\n        }\n        return calculations;\n    }\n    makeUpdateFunctions() {\n        return [];\n    }\n}\nexports.Micro16Clock = Micro16Clock;\n//# sourceMappingURL=Micro16Clock.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZWxlbWVudHMvTWljcm8xNkNsb2NrLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2VsZW1lbnRzL01pY3JvMTZDbG9jay5qcz8xOGJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9naWNFbGVtZW50XzEgPSByZXF1aXJlKFwiLi4vTG9naWNFbGVtZW50XCIpO1xuY29uc3QgQ29ubmVjdGVkRWxlbWVudF8xID0gcmVxdWlyZShcIi4uL0Nvbm5lY3RlZEVsZW1lbnRcIik7XG5jbGFzcyBNaWNybzE2Q2xvY2sgZXh0ZW5kcyBMb2dpY0VsZW1lbnRfMS5Mb2dpY0VsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RydWN0aW9uRGVsYXkgPSA4MDAsIGFsdURlbGF5ID0gMTQwMCwgcmVnaXN0ZXJzRGVsYXkgPSA0MDApIHtcbiAgICAgICAgc3VwZXIobmFtZSwgMCwgMyk7XG4gICAgICAgIHRoaXMuZGVsYXlzID0gW2luc3RydWN0aW9uRGVsYXksIGFsdURlbGF5LCByZWdpc3RlcnNEZWxheV07XG4gICAgfVxuICAgIG1ha2VDYWxjdWxhdGlvbnMoaW5wdXRTcGFjZSwgb3V0cHV0U3BhY2UpIHtcbiAgICAgICAgbGV0IGNhbGN1bGF0aW9ucyA9IHtcbiAgICAgICAgICAgIGNhbGN1bGF0aW9uczogW10sXG4gICAgICAgICAgICBvdXRwdXRBZGRyZXNzZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGxldCBkZWxheVN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGRlbGF5IG9mIHRoaXMuZGVsYXlzKSB7XG4gICAgICAgICAgICBkZWxheVN1bSArPSBkZWxheTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25EdXJhdGlvblNvRmFyID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlbGF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSBuZXcgQ29ubmVjdGVkRWxlbWVudF8xLkNvbm5lY3RlZEVsZW1lbnQuU3RhdGljQWRkcmVzcyh7XG4gICAgICAgICAgICAgICAgc3BhY2U6IG91dHB1dFNwYWNlLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGksXG4gICAgICAgICAgICAgICAgaGludDogYHN0YXRpYyBvdXRwdXQgYWRkcmVzcyBmb3Igb3V0cHV0ICR7aX0gb2YgbWljcm8xNiBjbG9jayAke3RoaXMuZ2V0TmFtZSgpfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsY3VsYXRpb25zLmNhbGN1bGF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJBbHRlcm5hdGluZ1ZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIG9uRHVyYXRpb246IHRoaXMuZGVsYXlzW2ldLFxuICAgICAgICAgICAgICAgICAgICBvZmZEdXJhdGlvbjogZGVsYXlTdW0gLSB0aGlzLmRlbGF5c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IGRlbGF5U3VtIC0gb25EdXJhdGlvblNvRmFyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbkR1cmF0aW9uU29GYXIgKz0gdGhpcy5kZWxheXNbaV07XG4gICAgICAgICAgICBjYWxjdWxhdGlvbnMub3V0cHV0QWRkcmVzc2VzLnB1c2goYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0aW9ucztcbiAgICB9XG4gICAgbWFrZVVwZGF0ZUZ1bmN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmV4cG9ydHMuTWljcm8xNkNsb2NrID0gTWljcm8xNkNsb2NrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWljcm8xNkNsb2NrLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/elements/Micro16Clock.js\n");

/***/ }),

/***/ "./out/js/elements/Micro16Store.js":
/*!*****************************************!*\
  !*** ./out/js/elements/Micro16Store.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LogicElement_1 = __webpack_require__(/*! ../LogicElement */ \"./out/js/LogicElement.js\");\nconst ConnectedElement_1 = __webpack_require__(/*! ../ConnectedElement */ \"./out/js/ConnectedElement.js\");\nclass Micro16Store extends LogicElement_1.LogicElement {\n    constructor(name, code) {\n        super(name, 8, 32);\n        this.currentLineIndex = -1;\n        if ((code.length % 8) !== 0) {\n            throw new Error(`${this.getName()}: code length is ${code.length}, but needs to be a multiple of 8`);\n        }\n        this.lines = new Array(code.length / 8);\n        for (let i = 0; i < this.lines.length; i++) {\n            let instruction = parseInt(code.substr(8 * i, 8), 16);\n            let bits = new Array(32);\n            for (let j = 31; j >= 0; j--) {\n                bits[j] = !!(instruction & 1);\n                instruction >>= 1;\n            }\n            this.lines[i] = bits;\n        }\n    }\n    makeCalculations(inputSpace, outputSpace) {\n        let outputAddresses = [];\n        for (let i = 0; i < 32; i++) {\n            let address = new ConnectedElement_1.ConnectedElement.StaticAddress({\n                space: outputSpace,\n                address: i,\n                hint: `static output address for output ${i} of micro16 store ${this.getName()}`\n            });\n            outputAddresses.push(address);\n        }\n        return {\n            calculations: [],\n            outputAddresses: outputAddresses\n        };\n    }\n    makeUpdateFunctions() {\n        return [{\n                function: (inputValues, outputValues) => {\n                    let index = 0;\n                    for (let inputValue of inputValues) {\n                        index <<= 1;\n                        index |= (inputValue ? 1 : 0);\n                    }\n                    if (index === this.currentLineIndex) {\n                        return false;\n                    }\n                    let line = (index < this.lines.length) ? this.lines[index] : undefined;\n                    for (let i = 0; i < outputValues.length; i++) {\n                        outputValues[i] = !!(line && line[i]);\n                    }\n                    this.currentLineIndex = index;\n                    return true;\n                },\n                interval: 1,\n                reverseInputs: true\n            }];\n    }\n}\nexports.Micro16Store = Micro16Store;\n//# sourceMappingURL=Micro16Store.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZWxlbWVudHMvTWljcm8xNlN0b3JlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2VsZW1lbnRzL01pY3JvMTZTdG9yZS5qcz85YmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9naWNFbGVtZW50XzEgPSByZXF1aXJlKFwiLi4vTG9naWNFbGVtZW50XCIpO1xuY29uc3QgQ29ubmVjdGVkRWxlbWVudF8xID0gcmVxdWlyZShcIi4uL0Nvbm5lY3RlZEVsZW1lbnRcIik7XG5jbGFzcyBNaWNybzE2U3RvcmUgZXh0ZW5kcyBMb2dpY0VsZW1lbnRfMS5Mb2dpY0VsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgOCwgMzIpO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lSW5kZXggPSAtMTtcbiAgICAgICAgaWYgKChjb2RlLmxlbmd0aCAlIDgpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5nZXROYW1lKCl9OiBjb2RlIGxlbmd0aCBpcyAke2NvZGUubGVuZ3RofSwgYnV0IG5lZWRzIHRvIGJlIGEgbXVsdGlwbGUgb2YgOGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGluZXMgPSBuZXcgQXJyYXkoY29kZS5sZW5ndGggLyA4KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5zdHJ1Y3Rpb24gPSBwYXJzZUludChjb2RlLnN1YnN0cig4ICogaSwgOCksIDE2KTtcbiAgICAgICAgICAgIGxldCBiaXRzID0gbmV3IEFycmF5KDMyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAzMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBiaXRzW2pdID0gISEoaW5zdHJ1Y3Rpb24gJiAxKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGluZXNbaV0gPSBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1ha2VDYWxjdWxhdGlvbnMoaW5wdXRTcGFjZSwgb3V0cHV0U3BhY2UpIHtcbiAgICAgICAgbGV0IG91dHB1dEFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gbmV3IENvbm5lY3RlZEVsZW1lbnRfMS5Db25uZWN0ZWRFbGVtZW50LlN0YXRpY0FkZHJlc3Moe1xuICAgICAgICAgICAgICAgIHNwYWNlOiBvdXRwdXRTcGFjZSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBpLFxuICAgICAgICAgICAgICAgIGhpbnQ6IGBzdGF0aWMgb3V0cHV0IGFkZHJlc3MgZm9yIG91dHB1dCAke2l9IG9mIG1pY3JvMTYgc3RvcmUgJHt0aGlzLmdldE5hbWUoKX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dHB1dEFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxjdWxhdGlvbnM6IFtdLFxuICAgICAgICAgICAgb3V0cHV0QWRkcmVzc2VzOiBvdXRwdXRBZGRyZXNzZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZVVwZGF0ZUZ1bmN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IChpbnB1dFZhbHVlcywgb3V0cHV0VmFsdWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlucHV0VmFsdWUgb2YgaW5wdXRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IDw8PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggfD0gKGlucHV0VmFsdWUgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmN1cnJlbnRMaW5lSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IChpbmRleCA8IHRoaXMubGluZXMubGVuZ3RoKSA/IHRoaXMubGluZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsdWVzW2ldID0gISEobGluZSAmJiBsaW5lW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMaW5lSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogMSxcbiAgICAgICAgICAgICAgICByZXZlcnNlSW5wdXRzOiB0cnVlXG4gICAgICAgICAgICB9XTtcbiAgICB9XG59XG5leHBvcnRzLk1pY3JvMTZTdG9yZSA9IE1pY3JvMTZTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1pY3JvMTZTdG9yZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/elements/Micro16Store.js\n");

/***/ }),

/***/ "./out/js/elements/Nor.js":
/*!********************************!*\
  !*** ./out/js/elements/Nor.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LogicElement_1 = __webpack_require__(/*! ../LogicElement */ \"./out/js/LogicElement.js\");\nconst ConnectedElement_1 = __webpack_require__(/*! ../ConnectedElement */ \"./out/js/ConnectedElement.js\");\nclass Nor extends LogicElement_1.LogicElement {\n    constructor(name, numInputs, initialValue = false, additionalDelay = 0) {\n        super(name, numInputs, 1, initialValue);\n        this.additionalDelay = additionalDelay;\n        this.additionalDelayBufferAddress = undefined;\n        if (numInputs <= 0) {\n            throw new Error(`${this.getName()}: need at least one input`);\n        }\n    }\n    makeCalculations(inputSpace, outputSpace) {\n        let norAddresses = [];\n        for (let i = 0; i < this.numInputs; i++) {\n            norAddresses.push(new ConnectedElement_1.ConnectedElement.StaticAddress({\n                space: inputSpace,\n                address: i,\n                hint: `static input address for input ${i} of nor ${this.getName()}`\n            }));\n        }\n        let outputAddress = new ConnectedElement_1.ConnectedElement.StaticAddress({\n            space: outputSpace,\n            address: 0,\n            hint: `static output address of nor ${this.getName()}`\n        });\n        let resultTargetAddress = outputAddress;\n        let calculations = [];\n        if (this.additionalDelay) {\n            this.additionalDelayBufferAddress = new ConnectedElement_1.ConnectedElement.RotatingAddress({\n                space: outputSpace,\n                address: 1,\n                mod: this.additionalDelay,\n                startOffset: 0,\n                hint: `additional output delay buffer address for ${this.getName()}`\n            });\n            resultTargetAddress = this.additionalDelayBufferAddress;\n            calculations.push({\n                target: outputAddress,\n                value: resultTargetAddress\n            });\n        }\n        calculations.push({\n            target: resultTargetAddress,\n            value: {\n                type: \"NotRule\",\n                value: {\n                    type: \"OrRule\",\n                    value: norAddresses\n                }\n            }\n        });\n        return {\n            calculations: calculations,\n            outputAddresses: [outputAddress]\n        };\n    }\n    makeUpdateFunctions() {\n        return [];\n    }\n    getInitiallyTrueAddresses() {\n        let addresses = [];\n        if (this.initialValue) {\n            addresses.push(...this.outputAddresses);\n            if (this.additionalDelayBufferAddress) {\n                addresses.push(...this.additionalDelayBufferAddress.getAllAddresses());\n            }\n        }\n        return addresses;\n    }\n}\nexports.Nor = Nor;\n//# sourceMappingURL=Nor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZWxlbWVudHMvTm9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2VsZW1lbnRzL05vci5qcz8zZTIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9naWNFbGVtZW50XzEgPSByZXF1aXJlKFwiLi4vTG9naWNFbGVtZW50XCIpO1xuY29uc3QgQ29ubmVjdGVkRWxlbWVudF8xID0gcmVxdWlyZShcIi4uL0Nvbm5lY3RlZEVsZW1lbnRcIik7XG5jbGFzcyBOb3IgZXh0ZW5kcyBMb2dpY0VsZW1lbnRfMS5Mb2dpY0VsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG51bUlucHV0cywgaW5pdGlhbFZhbHVlID0gZmFsc2UsIGFkZGl0aW9uYWxEZWxheSA9IDApIHtcbiAgICAgICAgc3VwZXIobmFtZSwgbnVtSW5wdXRzLCAxLCBpbml0aWFsVmFsdWUpO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxEZWxheSA9IGFkZGl0aW9uYWxEZWxheTtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsRGVsYXlCdWZmZXJBZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobnVtSW5wdXRzIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmdldE5hbWUoKX06IG5lZWQgYXQgbGVhc3Qgb25lIGlucHV0YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFrZUNhbGN1bGF0aW9ucyhpbnB1dFNwYWNlLCBvdXRwdXRTcGFjZSkge1xuICAgICAgICBsZXQgbm9yQWRkcmVzc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgICAgICAgbm9yQWRkcmVzc2VzLnB1c2gobmV3IENvbm5lY3RlZEVsZW1lbnRfMS5Db25uZWN0ZWRFbGVtZW50LlN0YXRpY0FkZHJlc3Moe1xuICAgICAgICAgICAgICAgIHNwYWNlOiBpbnB1dFNwYWNlLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGksXG4gICAgICAgICAgICAgICAgaGludDogYHN0YXRpYyBpbnB1dCBhZGRyZXNzIGZvciBpbnB1dCAke2l9IG9mIG5vciAke3RoaXMuZ2V0TmFtZSgpfWBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0QWRkcmVzcyA9IG5ldyBDb25uZWN0ZWRFbGVtZW50XzEuQ29ubmVjdGVkRWxlbWVudC5TdGF0aWNBZGRyZXNzKHtcbiAgICAgICAgICAgIHNwYWNlOiBvdXRwdXRTcGFjZSxcbiAgICAgICAgICAgIGFkZHJlc3M6IDAsXG4gICAgICAgICAgICBoaW50OiBgc3RhdGljIG91dHB1dCBhZGRyZXNzIG9mIG5vciAke3RoaXMuZ2V0TmFtZSgpfWBcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXN1bHRUYXJnZXRBZGRyZXNzID0gb3V0cHV0QWRkcmVzcztcbiAgICAgICAgbGV0IGNhbGN1bGF0aW9ucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5hZGRpdGlvbmFsRGVsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkaXRpb25hbERlbGF5QnVmZmVyQWRkcmVzcyA9IG5ldyBDb25uZWN0ZWRFbGVtZW50XzEuQ29ubmVjdGVkRWxlbWVudC5Sb3RhdGluZ0FkZHJlc3Moe1xuICAgICAgICAgICAgICAgIHNwYWNlOiBvdXRwdXRTcGFjZSxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiAxLFxuICAgICAgICAgICAgICAgIG1vZDogdGhpcy5hZGRpdGlvbmFsRGVsYXksXG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgaGludDogYGFkZGl0aW9uYWwgb3V0cHV0IGRlbGF5IGJ1ZmZlciBhZGRyZXNzIGZvciAke3RoaXMuZ2V0TmFtZSgpfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0VGFyZ2V0QWRkcmVzcyA9IHRoaXMuYWRkaXRpb25hbERlbGF5QnVmZmVyQWRkcmVzcztcbiAgICAgICAgICAgIGNhbGN1bGF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG91dHB1dEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFRhcmdldEFkZHJlc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGN1bGF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHRhcmdldDogcmVzdWx0VGFyZ2V0QWRkcmVzcyxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJOb3RSdWxlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJPclJ1bGVcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5vckFkZHJlc3Nlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxjdWxhdGlvbnM6IGNhbGN1bGF0aW9ucyxcbiAgICAgICAgICAgIG91dHB1dEFkZHJlc3NlczogW291dHB1dEFkZHJlc3NdXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1ha2VVcGRhdGVGdW5jdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbGx5VHJ1ZUFkZHJlc3NlcygpIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKC4uLnRoaXMub3V0cHV0QWRkcmVzc2VzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGl0aW9uYWxEZWxheUJ1ZmZlckFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaCguLi50aGlzLmFkZGl0aW9uYWxEZWxheUJ1ZmZlckFkZHJlc3MuZ2V0QWxsQWRkcmVzc2VzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRyZXNzZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3IgPSBOb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3IuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/elements/Nor.js\n");

/***/ }),

/***/ "./out/js/elements/SinkTerminal.js":
/*!*****************************************!*\
  !*** ./out/js/elements/SinkTerminal.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LogicElement_1 = __webpack_require__(/*! ../LogicElement */ \"./out/js/LogicElement.js\");\nclass SinkTerminal extends LogicElement_1.LogicElement {\n    constructor(name, sink) {\n        super(name, 1, 0);\n        this.sink = sink;\n    }\n    makeCalculations(inputSpace, outputSpace) {\n        return {\n            calculations: [],\n            outputAddresses: []\n        };\n    }\n    makeUpdateFunctions() {\n        return [{\n                function: (inputValues, outputValues) => {\n                    this.sink(inputValues[0]);\n                    return false;\n                },\n                interval: 1\n            }];\n    }\n}\nexports.SinkTerminal = SinkTerminal;\n//# sourceMappingURL=SinkTerminal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZWxlbWVudHMvU2lua1Rlcm1pbmFsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2VsZW1lbnRzL1NpbmtUZXJtaW5hbC5qcz80MjY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9naWNFbGVtZW50XzEgPSByZXF1aXJlKFwiLi4vTG9naWNFbGVtZW50XCIpO1xuY2xhc3MgU2lua1Rlcm1pbmFsIGV4dGVuZHMgTG9naWNFbGVtZW50XzEuTG9naWNFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzaW5rKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIDEsIDApO1xuICAgICAgICB0aGlzLnNpbmsgPSBzaW5rO1xuICAgIH1cbiAgICBtYWtlQ2FsY3VsYXRpb25zKGlucHV0U3BhY2UsIG91dHB1dFNwYWNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxjdWxhdGlvbnM6IFtdLFxuICAgICAgICAgICAgb3V0cHV0QWRkcmVzc2VzOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBtYWtlVXBkYXRlRnVuY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogKGlucHV0VmFsdWVzLCBvdXRwdXRWYWx1ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaW5rKGlucHV0VmFsdWVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IDFcbiAgICAgICAgICAgIH1dO1xuICAgIH1cbn1cbmV4cG9ydHMuU2lua1Rlcm1pbmFsID0gU2lua1Rlcm1pbmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2lua1Rlcm1pbmFsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/elements/SinkTerminal.js\n");

/***/ }),

/***/ "./out/js/elements/SourceTerminal.js":
/*!*******************************************!*\
  !*** ./out/js/elements/SourceTerminal.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LogicElement_1 = __webpack_require__(/*! ../LogicElement */ \"./out/js/LogicElement.js\");\nconst ConnectedElement_1 = __webpack_require__(/*! ../ConnectedElement */ \"./out/js/ConnectedElement.js\");\nclass SourceTerminal extends LogicElement_1.LogicElement {\n    constructor(name, source) {\n        super(name, 0, 1, source());\n        this.source = source;\n    }\n    makeCalculations(inputSpace, outputSpace) {\n        let address = new ConnectedElement_1.ConnectedElement.StaticAddress({\n            space: outputSpace,\n            address: 0,\n            hint: `static output address for source terminal ${this.getName()}`\n        });\n        return {\n            calculations: [],\n            outputAddresses: [address]\n        };\n    }\n    makeUpdateFunctions() {\n        return [{\n                function: (inputValues, outputValues) => {\n                    outputValues[0] = this.source();\n                    return true;\n                },\n                interval: 1\n            }];\n    }\n}\nexports.SourceTerminal = SourceTerminal;\n//# sourceMappingURL=SourceTerminal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZWxlbWVudHMvU291cmNlVGVybWluYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZWxlbWVudHMvU291cmNlVGVybWluYWwuanM/YmRkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ2ljRWxlbWVudF8xID0gcmVxdWlyZShcIi4uL0xvZ2ljRWxlbWVudFwiKTtcbmNvbnN0IENvbm5lY3RlZEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuLi9Db25uZWN0ZWRFbGVtZW50XCIpO1xuY2xhc3MgU291cmNlVGVybWluYWwgZXh0ZW5kcyBMb2dpY0VsZW1lbnRfMS5Mb2dpY0VsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICBzdXBlcihuYW1lLCAwLCAxLCBzb3VyY2UoKSk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBtYWtlQ2FsY3VsYXRpb25zKGlucHV0U3BhY2UsIG91dHB1dFNwYWNlKSB7XG4gICAgICAgIGxldCBhZGRyZXNzID0gbmV3IENvbm5lY3RlZEVsZW1lbnRfMS5Db25uZWN0ZWRFbGVtZW50LlN0YXRpY0FkZHJlc3Moe1xuICAgICAgICAgICAgc3BhY2U6IG91dHB1dFNwYWNlLFxuICAgICAgICAgICAgYWRkcmVzczogMCxcbiAgICAgICAgICAgIGhpbnQ6IGBzdGF0aWMgb3V0cHV0IGFkZHJlc3MgZm9yIHNvdXJjZSB0ZXJtaW5hbCAke3RoaXMuZ2V0TmFtZSgpfWBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxjdWxhdGlvbnM6IFtdLFxuICAgICAgICAgICAgb3V0cHV0QWRkcmVzc2VzOiBbYWRkcmVzc11cbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZVVwZGF0ZUZ1bmN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IChpbnB1dFZhbHVlcywgb3V0cHV0VmFsdWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlc1swXSA9IHRoaXMuc291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IDFcbiAgICAgICAgICAgIH1dO1xuICAgIH1cbn1cbmV4cG9ydHMuU291cmNlVGVybWluYWwgPSBTb3VyY2VUZXJtaW5hbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvdXJjZVRlcm1pbmFsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/elements/SourceTerminal.js\n");

/***/ }),

/***/ "./out/js/elements/Split.js":
/*!**********************************!*\
  !*** ./out/js/elements/Split.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ConnectedElement_1 = __webpack_require__(/*! ../ConnectedElement */ \"./out/js/ConnectedElement.js\");\nclass Split {\n    constructor(name, numOutChannels, numInBits, initialValue = false) {\n        this.name = name;\n        this.numOutChannels = numOutChannels;\n        this.numInBits = numInBits;\n        this.initialValue = initialValue;\n        this.inputValueAddressProviders = new Array(numInBits);\n    }\n    getName() {\n        return this.name;\n    }\n    getOwnType() {\n        return this.constructor.name;\n    }\n    getDelay() {\n        return 0;\n    }\n    getChildren() {\n        return [];\n    }\n    readInputFrom(inputIndex, sourceElement, sourceOutputIndex) {\n        this.inputValueAddressProviders[inputIndex] = sourceElement.getOutputValueAddressProvider(sourceOutputIndex);\n    }\n    getNumOutputs() {\n        return this.numOutChannels * this.numInBits;\n    }\n    getOutputValueAddressProvider(outputIndex) {\n        if (this.numInBits) {\n            return () => this.inputValueAddressProviders[outputIndex % this.inputValueAddressProviders.length]();\n        }\n        else {\n            return () => this.fixedValueAddress;\n        }\n    }\n    getWriteOutputsCalculations(space) {\n        this.fixedValueAddress = new ConnectedElement_1.ConnectedElement.StaticAddress({\n            space: space,\n            address: 0,\n            hint: `static fixed value address for split ${this.getName()}`\n        });\n        return [];\n    }\n    getReadInputsCalculations() {\n        if (this.numInBits) {\n            for (let i = 0; i < this.inputValueAddressProviders.length; i++) {\n                if (!this.inputValueAddressProviders[i]) {\n                    throw new Error(this.getName() + \": input \" + i + \" is not connected\");\n                }\n            }\n        }\n        return [];\n    }\n    getUpdateFunctions() {\n        return [];\n    }\n    getInitiallyTrueAddresses() {\n        if (!this.numInBits && this.initialValue) {\n            return [this.fixedValueAddress];\n        }\n        else {\n            return [];\n        }\n    }\n}\nexports.Split = Split;\n//# sourceMappingURL=Split.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZWxlbWVudHMvU3BsaXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZWxlbWVudHMvU3BsaXQuanM/ZGFhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbm5lY3RlZEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuLi9Db25uZWN0ZWRFbGVtZW50XCIpO1xuY2xhc3MgU3BsaXQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG51bU91dENoYW5uZWxzLCBudW1JbkJpdHMsIGluaXRpYWxWYWx1ZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubnVtT3V0Q2hhbm5lbHMgPSBudW1PdXRDaGFubmVscztcbiAgICAgICAgdGhpcy5udW1JbkJpdHMgPSBudW1JbkJpdHM7XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzID0gbmV3IEFycmF5KG51bUluQml0cyk7XG4gICAgfVxuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIGdldE93blR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIGdldERlbGF5KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmVhZElucHV0RnJvbShpbnB1dEluZGV4LCBzb3VyY2VFbGVtZW50LCBzb3VyY2VPdXRwdXRJbmRleCkge1xuICAgICAgICB0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzW2lucHV0SW5kZXhdID0gc291cmNlRWxlbWVudC5nZXRPdXRwdXRWYWx1ZUFkZHJlc3NQcm92aWRlcihzb3VyY2VPdXRwdXRJbmRleCk7XG4gICAgfVxuICAgIGdldE51bU91dHB1dHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bU91dENoYW5uZWxzICogdGhpcy5udW1JbkJpdHM7XG4gICAgfVxuICAgIGdldE91dHB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVyKG91dHB1dEluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLm51bUluQml0cykge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnNbb3V0cHV0SW5kZXggJSB0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzLmxlbmd0aF0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmZpeGVkVmFsdWVBZGRyZXNzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFdyaXRlT3V0cHV0c0NhbGN1bGF0aW9ucyhzcGFjZSkge1xuICAgICAgICB0aGlzLmZpeGVkVmFsdWVBZGRyZXNzID0gbmV3IENvbm5lY3RlZEVsZW1lbnRfMS5Db25uZWN0ZWRFbGVtZW50LlN0YXRpY0FkZHJlc3Moe1xuICAgICAgICAgICAgc3BhY2U6IHNwYWNlLFxuICAgICAgICAgICAgYWRkcmVzczogMCxcbiAgICAgICAgICAgIGhpbnQ6IGBzdGF0aWMgZml4ZWQgdmFsdWUgYWRkcmVzcyBmb3Igc3BsaXQgJHt0aGlzLmdldE5hbWUoKX1gXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldFJlYWRJbnB1dHNDYWxjdWxhdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLm51bUluQml0cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldE5hbWUoKSArIFwiOiBpbnB1dCBcIiArIGkgKyBcIiBpcyBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldFVwZGF0ZUZ1bmN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXRJbml0aWFsbHlUcnVlQWRkcmVzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMubnVtSW5CaXRzICYmIHRoaXMuaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZml4ZWRWYWx1ZUFkZHJlc3NdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TcGxpdCA9IFNwbGl0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3BsaXQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/elements/Split.js\n");

/***/ }),

/***/ "./out/js/elements/Wire.js":
/*!*********************************!*\
  !*** ./out/js/elements/Wire.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ConnectedElement_1 = __webpack_require__(/*! ../ConnectedElement */ \"./out/js/ConnectedElement.js\");\nclass Wire {\n    constructor(name, delay, initialValue = false, num = 1) {\n        this.name = name;\n        this.initialValue = initialValue;\n        if (delay < 0) {\n            delay = 0;\n        }\n        this.delay = delay;\n        this.inputValueAddressProviders = new Array(num);\n        if (this.delay) {\n            this.outputAddresses = new Array(num);\n            this.delayBufferAddresses = new Array(num);\n        }\n    }\n    getName() {\n        return this.name;\n    }\n    getOwnType() {\n        return this.constructor.name;\n    }\n    getDelay() {\n        return this.delay;\n    }\n    getChildren() {\n        return [];\n    }\n    readInputFrom(inputIndex, sourceElement, sourceOutputIndex) {\n        if (inputIndex >= this.inputValueAddressProviders.length) {\n            throw new Error(this.getName() + \": input index \" + inputIndex + \" is out of bounds\");\n        }\n        this.inputValueAddressProviders[inputIndex] = sourceElement.getOutputValueAddressProvider(sourceOutputIndex);\n    }\n    getNumOutputs() {\n        return this.inputValueAddressProviders.length;\n    }\n    getOutputValueAddressProvider(outputIndex) {\n        if (this.delay) {\n            return () => this.outputAddresses[outputIndex];\n        }\n        else {\n            return () => this.inputValueAddressProviders[outputIndex]();\n        }\n    }\n    getDelayBufferAddressProvider(outputIndex) {\n        return () => this.delayBufferAddresses[outputIndex];\n    }\n    getWriteOutputsCalculations(space) {\n        for (let i = 0; i < this.inputValueAddressProviders.length; i++) {\n            if (!this.inputValueAddressProviders[i]) {\n                throw new Error(this.getName() + \": input \" + i + \" is not connected\");\n            }\n        }\n        this.writeOutputCalculations = [];\n        if (this.delay) {\n            for (let i = 0; i < this.inputValueAddressProviders.length; i++) {\n                let outputSourceAddress = new ConnectedElement_1.ConnectedElement.StaticAddress({\n                    space: space,\n                    address: i,\n                    hint: `wire output address for channel ${i} of ${this.getName()}`\n                });\n                this.outputAddresses[i] = outputSourceAddress;\n                let inputTargetAddress = new ConnectedElement_1.ConnectedElement.RotatingAddress({\n                    space: space,\n                    address: this.inputValueAddressProviders.length + i * this.delay,\n                    mod: this.delay,\n                    startOffset: 0,\n                    hint: `wire input address for channel ${i} of ${this.getName()}`\n                });\n                this.delayBufferAddresses[i] = new ConnectedElement_1.ConnectedElement.RotatingAddress(Object.assign({}, inputTargetAddress.info, { startOffset: 1, hint: `wire delay buffer read address for channel ${i} of ${this.getName()}` }));\n                this.writeOutputCalculations.push({\n                    target: inputTargetAddress,\n                    value: undefined\n                });\n            }\n        }\n        return this.writeOutputCalculations;\n    }\n    getReadInputsCalculations() {\n        let calculations = [];\n        if (this.delay) {\n            for (let i = 0; i < this.inputValueAddressProviders.length; i++) {\n                let inputSourceAddress = this.inputValueAddressProviders[i]();\n                if (!inputSourceAddress) {\n                    throw new Error(`${this.getName()}: input provider ${i} failed to provide an address`);\n                }\n                let writeOutputCalculation = this.writeOutputCalculations[i];\n                writeOutputCalculation.value = inputSourceAddress;\n                calculations.push({\n                    target: this.outputAddresses[i],\n                    value: writeOutputCalculation.target\n                });\n            }\n        }\n        return calculations;\n    }\n    getUpdateFunctions() {\n        return [];\n    }\n    getInitiallyTrueAddresses() {\n        let addresses = [];\n        if (this.delay && this.initialValue) {\n            for (let i = 0; i < this.delayBufferAddresses.length; i++) {\n                addresses.push(...this.delayBufferAddresses[i].getAllAddresses());\n            }\n            addresses.push(...this.outputAddresses);\n        }\n        return addresses;\n    }\n}\nexports.Wire = Wire;\n//# sourceMappingURL=Wire.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZWxlbWVudHMvV2lyZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9lbGVtZW50cy9XaXJlLmpzP2EyYzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb25uZWN0ZWRFbGVtZW50XzEgPSByZXF1aXJlKFwiLi4vQ29ubmVjdGVkRWxlbWVudFwiKTtcbmNsYXNzIFdpcmUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlbGF5LCBpbml0aWFsVmFsdWUgPSBmYWxzZSwgbnVtID0gMSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5pbnB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVycyA9IG5ldyBBcnJheShudW0pO1xuICAgICAgICBpZiAodGhpcy5kZWxheSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRBZGRyZXNzZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlCdWZmZXJBZGRyZXNzZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICBnZXRPd25UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH1cbiAgICBnZXREZWxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsYXk7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJlYWRJbnB1dEZyb20oaW5wdXRJbmRleCwgc291cmNlRWxlbWVudCwgc291cmNlT3V0cHV0SW5kZXgpIHtcbiAgICAgICAgaWYgKGlucHV0SW5kZXggPj0gdGhpcy5pbnB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldE5hbWUoKSArIFwiOiBpbnB1dCBpbmRleCBcIiArIGlucHV0SW5kZXggKyBcIiBpcyBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnNbaW5wdXRJbmRleF0gPSBzb3VyY2VFbGVtZW50LmdldE91dHB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVyKHNvdXJjZU91dHB1dEluZGV4KTtcbiAgICB9XG4gICAgZ2V0TnVtT3V0cHV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRPdXRwdXRWYWx1ZUFkZHJlc3NQcm92aWRlcihvdXRwdXRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMub3V0cHV0QWRkcmVzc2VzW291dHB1dEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzW291dHB1dEluZGV4XSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERlbGF5QnVmZmVyQWRkcmVzc1Byb3ZpZGVyKG91dHB1dEluZGV4KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmRlbGF5QnVmZmVyQWRkcmVzc2VzW291dHB1dEluZGV4XTtcbiAgICB9XG4gICAgZ2V0V3JpdGVPdXRwdXRzQ2FsY3VsYXRpb25zKHNwYWNlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZ2V0TmFtZSgpICsgXCI6IGlucHV0IFwiICsgaSArIFwiIGlzIG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZU91dHB1dENhbGN1bGF0aW9ucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5kZWxheSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG91dHB1dFNvdXJjZUFkZHJlc3MgPSBuZXcgQ29ubmVjdGVkRWxlbWVudF8xLkNvbm5lY3RlZEVsZW1lbnQuU3RhdGljQWRkcmVzcyh7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlOiBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogaSxcbiAgICAgICAgICAgICAgICAgICAgaGludDogYHdpcmUgb3V0cHV0IGFkZHJlc3MgZm9yIGNoYW5uZWwgJHtpfSBvZiAke3RoaXMuZ2V0TmFtZSgpfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dEFkZHJlc3Nlc1tpXSA9IG91dHB1dFNvdXJjZUFkZHJlc3M7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0VGFyZ2V0QWRkcmVzcyA9IG5ldyBDb25uZWN0ZWRFbGVtZW50XzEuQ29ubmVjdGVkRWxlbWVudC5Sb3RhdGluZ0FkZHJlc3Moe1xuICAgICAgICAgICAgICAgICAgICBzcGFjZTogc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnMubGVuZ3RoICsgaSAqIHRoaXMuZGVsYXksXG4gICAgICAgICAgICAgICAgICAgIG1vZDogdGhpcy5kZWxheSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGhpbnQ6IGB3aXJlIGlucHV0IGFkZHJlc3MgZm9yIGNoYW5uZWwgJHtpfSBvZiAke3RoaXMuZ2V0TmFtZSgpfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5QnVmZmVyQWRkcmVzc2VzW2ldID0gbmV3IENvbm5lY3RlZEVsZW1lbnRfMS5Db25uZWN0ZWRFbGVtZW50LlJvdGF0aW5nQWRkcmVzcyhPYmplY3QuYXNzaWduKHt9LCBpbnB1dFRhcmdldEFkZHJlc3MuaW5mbywgeyBzdGFydE9mZnNldDogMSwgaGludDogYHdpcmUgZGVsYXkgYnVmZmVyIHJlYWQgYWRkcmVzcyBmb3IgY2hhbm5lbCAke2l9IG9mICR7dGhpcy5nZXROYW1lKCl9YCB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZU91dHB1dENhbGN1bGF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBpbnB1dFRhcmdldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZU91dHB1dENhbGN1bGF0aW9ucztcbiAgICB9XG4gICAgZ2V0UmVhZElucHV0c0NhbGN1bGF0aW9ucygpIHtcbiAgICAgICAgbGV0IGNhbGN1bGF0aW9ucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5kZWxheSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0VmFsdWVBZGRyZXNzUHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0U291cmNlQWRkcmVzcyA9IHRoaXMuaW5wdXRWYWx1ZUFkZHJlc3NQcm92aWRlcnNbaV0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0U291cmNlQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5nZXROYW1lKCl9OiBpbnB1dCBwcm92aWRlciAke2l9IGZhaWxlZCB0byBwcm92aWRlIGFuIGFkZHJlc3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHdyaXRlT3V0cHV0Q2FsY3VsYXRpb24gPSB0aGlzLndyaXRlT3V0cHV0Q2FsY3VsYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIHdyaXRlT3V0cHV0Q2FsY3VsYXRpb24udmFsdWUgPSBpbnB1dFNvdXJjZUFkZHJlc3M7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMub3V0cHV0QWRkcmVzc2VzW2ldLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd3JpdGVPdXRwdXRDYWxjdWxhdGlvbi50YXJnZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsY3VsYXRpb25zO1xuICAgIH1cbiAgICBnZXRVcGRhdGVGdW5jdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbGx5VHJ1ZUFkZHJlc3NlcygpIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5kZWxheSAmJiB0aGlzLmluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlbGF5QnVmZmVyQWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goLi4udGhpcy5kZWxheUJ1ZmZlckFkZHJlc3Nlc1tpXS5nZXRBbGxBZGRyZXNzZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRyZXNzZXMucHVzaCguLi50aGlzLm91dHB1dEFkZHJlc3Nlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZHJlc3NlcztcbiAgICB9XG59XG5leHBvcnRzLldpcmUgPSBXaXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2lyZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/elements/Wire.js\n");

/***/ }),

/***/ "./out/js/grammar/GrammarParser.js":
/*!*****************************************!*\
  !*** ./out/js/grammar/GrammarParser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst nearley = __webpack_require__(/*! nearley */ \"./node_modules/nearley/lib/nearley.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ../graphics/GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GraphicalNor_1 = __webpack_require__(/*! ../graphics/GraphicalNor */ \"./out/js/graphics/GraphicalNor.js\");\nconst NeverError_1 = __webpack_require__(/*! ../NeverError */ \"./out/js/NeverError.js\");\nconst GraphicalSinkTerminal_1 = __webpack_require__(/*! ../graphics/GraphicalSinkTerminal */ \"./out/js/graphics/GraphicalSinkTerminal.js\");\nconst GraphicalSourceTerminal_1 = __webpack_require__(/*! ../graphics/GraphicalSourceTerminal */ \"./out/js/graphics/GraphicalSourceTerminal.js\");\nconst GraphicalSplit_1 = __webpack_require__(/*! ../graphics/GraphicalSplit */ \"./out/js/graphics/GraphicalSplit.js\");\nconst GraphicalDecoder_1 = __webpack_require__(/*! ../graphics/GraphicalDecoder */ \"./out/js/graphics/GraphicalDecoder.js\");\nconst GraphicalDFlipFlop_1 = __webpack_require__(/*! ../graphics/GraphicalDFlipFlop */ \"./out/js/graphics/GraphicalDFlipFlop.js\");\nconst GraphicalRegister_1 = __webpack_require__(/*! ../graphics/GraphicalRegister */ \"./out/js/graphics/GraphicalRegister.js\");\nconst GraphicalRSFlipFlop_1 = __webpack_require__(/*! ../graphics/GraphicalRSFlipFlop */ \"./out/js/graphics/GraphicalRSFlipFlop.js\");\nconst GraphicalJKFlipFlop_1 = __webpack_require__(/*! ../graphics/GraphicalJKFlipFlop */ \"./out/js/graphics/GraphicalJKFlipFlop.js\");\nconst GraphicalMultiplexer_1 = __webpack_require__(/*! ../graphics/GraphicalMultiplexer */ \"./out/js/graphics/GraphicalMultiplexer.js\");\nconst GraphicalHalfAdder_1 = __webpack_require__(/*! ../graphics/GraphicalHalfAdder */ \"./out/js/graphics/GraphicalHalfAdder.js\");\nconst GraphicalFullAdder_1 = __webpack_require__(/*! ../graphics/GraphicalFullAdder */ \"./out/js/graphics/GraphicalFullAdder.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ../graphics/GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalAnd_1 = __webpack_require__(/*! ../graphics/GraphicalAnd */ \"./out/js/graphics/GraphicalAnd.js\");\nconst GraphicalXor_1 = __webpack_require__(/*! ../graphics/GraphicalXor */ \"./out/js/graphics/GraphicalXor.js\");\nconst GraphicalMicro16_1 = __webpack_require__(/*! ../graphics/GraphicalMicro16 */ \"./out/js/graphics/GraphicalMicro16.js\");\nconst GraphicalMicro16Registers_1 = __webpack_require__(/*! ../graphics/GraphicalMicro16Registers */ \"./out/js/graphics/GraphicalMicro16Registers.js\");\nconst GraphicalMicro16Alu_1 = __webpack_require__(/*! ../graphics/GraphicalMicro16Alu */ \"./out/js/graphics/GraphicalMicro16Alu.js\");\nconst GraphicalMicro16Mic_1 = __webpack_require__(/*! ../graphics/GraphicalMicro16Mic */ \"./out/js/graphics/GraphicalMicro16Mic.js\");\nconst GraphicalMicro16Store_1 = __webpack_require__(/*! ../graphics/GraphicalMicro16Store */ \"./out/js/graphics/GraphicalMicro16Store.js\");\nconst GraphicalMicro16Clock_1 = __webpack_require__(/*! ../graphics/GraphicalMicro16Clock */ \"./out/js/graphics/GraphicalMicro16Clock.js\");\nconst GraphicalManyNors_1 = __webpack_require__(/*! ../graphics/GraphicalManyNors */ \"./out/js/graphics/GraphicalManyNors.js\");\nconst grammar = __webpack_require__(/*! ../../grammar/grammar.js */ \"./out/grammar/grammar.js\");\nclass GrammarParser {\n    static parse(descriptions, noElementInstancesForTesting = false, knownElementNames = []) {\n        let parsedElements = new Array(descriptions.length);\n        let parsedConfigs = new Array(descriptions.length);\n        for (let i = 0; i < descriptions.length; i++) {\n            let description = descriptions[i];\n            let parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n            parser.feed(description);\n            parser.finish();\n            let parsed = parser.results[0];\n            parsedElements[i] = parsed.elements;\n            parsedConfigs[i] = parsed.config;\n        }\n        let parsed = {\n            config: [].concat(...parsedConfigs),\n            elements: [].concat(...parsedElements)\n        };\n        if (!parsed.elements.length) {\n            throw new Error(\"nothing parsed\");\n        }\n        return GrammarParser.fromParsed(parsed, noElementInstancesForTesting, knownElementNames);\n    }\n    static fromParsed(parsed, noElementInstancesForTesting = false, knownElementNames = []) {\n        let elements = parsed.elements;\n        let params = this.parseParameters(undefined, undefined, parsed.config, {\n            height: {\n                default: GrammarParser.DEFAULT_TOTAL_HEIGHT\n            },\n            autoSource: {\n                default: false\n            },\n            autoSourceDeltaX: {\n                default: -2 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE\n            },\n            autoSourceDeltaY: {\n                default: 0\n            },\n            stepsPerSecond: {\n                default: -1\n            },\n            cyclesPerStep: {\n                default: 0,\n            },\n            delayPerWindowHeight: {\n                default: -1\n            },\n            additionalNorDelay: {\n                default: -1\n            },\n            echoData: {\n                default: false\n            },\n            echoFunctions: {\n                default: false\n            },\n            disableGraphics: {\n                default: false\n            }\n        });\n        let elementsMap = {};\n        let wireNamesMap = {};\n        let wireDescriptions = [];\n        let elementDescriptions = [];\n        for (let elementName of knownElementNames) {\n            if (elementsMap[elementName]) {\n                throw new Error(\"duplicate known element \" + elementName);\n            }\n            elementsMap[elementName] = {\n                element: undefined,\n                inputs: {},\n                outputs: {}\n            };\n        }\n        for (let element of elements) {\n            if (elementsMap[element.name]) {\n                throw new Error(\"duplicate element \" + element.name);\n            }\n            elementsMap[element.name] = {\n                element: element,\n                inputs: {},\n                outputs: {}\n            };\n        }\n        for (let parsedElement of elements) {\n            let elementName = parsedElement.name;\n            let element = elementsMap[elementName];\n            if (!element.element) {\n                continue;\n            }\n            for (let outsideInput of element.element.outsideInputs) {\n                let inputIndex = outsideInput.inputIndex !== null ? outsideInput.inputIndex : GrammarParser.getNextFreeIndex(element.inputs);\n                for (let i = 0; i <= outsideInput.more; i++) {\n                    if (element.inputs[inputIndex + i]) {\n                        throw new Error(`cannot set input ${inputIndex} of element ${elementName} as outside input: input is already occupied`);\n                    }\n                    if (params.autoSource) {\n                        let autoSourceElement = GrammarParser.makeAutoSource(elementName, inputIndex + i, params.autoSourceDeltaX, params.autoSourceDeltaY);\n                        if (elementsMap[autoSourceElement.name]) {\n                            throw new Error(`cannot create autosource element for element ${elementName}: element ${autoSourceElement.name} exists`);\n                        }\n                        elements.push(autoSourceElement);\n                        elementsMap[autoSourceElement.name] = {\n                            element: autoSourceElement,\n                            inputs: {},\n                            outputs: {}\n                        };\n                        element.inputs[inputIndex + i] = {\n                            name: autoSourceElement.name,\n                            outputIndex: 0\n                        };\n                    }\n                    else {\n                        element.inputs[inputIndex + i] = {\n                            name: \"outside\",\n                            outputIndex: outsideInput.outputIndex + i\n                        };\n                    }\n                }\n            }\n            for (let externalOutput of element.element.externalOutputs) {\n                for (let i = 0; i <= externalOutput.more; i++) {\n                    let outputIndex = externalOutput.outputIndex + i;\n                    if (element.outputs[outputIndex]) {\n                        throw new Error(element.element.name + \": cannot use output index \" + outputIndex + \" for external output twice\");\n                    }\n                    element.outputs[outputIndex] = true;\n                }\n            }\n            for (let i = 0; i < element.element.wires.length; i++) {\n                let wire = element.element.wires[i];\n                let outputIndex = wire.outputIndex !== null ? wire.outputIndex : GrammarParser.getNextFreeIndex(element.outputs);\n                for (let offset = 0; offset <= wire.more; offset++) {\n                    if (element.outputs[outputIndex + offset]) {\n                        throw new Error(element.element.name + \", wire index \" + i + \": cannot use output index \" + (outputIndex + offset) + \" twice\");\n                    }\n                }\n                for (let offset = 0; offset <= wire.more; offset++) {\n                    element.outputs[outputIndex + offset] = true;\n                }\n                let lastCoordinatesOriginal = wire.coordinates[wire.coordinates.length - 1];\n                if (!lastCoordinatesOriginal.name || lastCoordinatesOriginal.connector !== \"input\" || lastCoordinatesOriginal.index === undefined) {\n                    throw new Error(element.element.name + \", wire index \" + i + \": wire needs to terminate in some input connector of some element\");\n                }\n                let targetElementName = lastCoordinatesOriginal.name;\n                let targetElement = elementsMap[targetElementName];\n                if (!targetElement) {\n                    throw new Error(element.element.name + \", wire index \" + i + \": unknown element name in terminating input connector reference: \" + lastCoordinatesOriginal.name);\n                }\n                let targetInputIndex = lastCoordinatesOriginal.index !== null ? lastCoordinatesOriginal.index : GrammarParser.getNextFreeIndex(targetElement.inputs);\n                for (let offset = 0; offset <= wire.more; offset++) {\n                    if (targetElement.inputs[targetInputIndex + offset] && targetElement.inputs[targetInputIndex + offset].name !== element.element.name) {\n                        throw new Error(element.element.name + \", wire index \" + i + \": target element input index \" + (targetInputIndex + offset) + \" is occupied\");\n                    }\n                }\n                let connectorCoordinateOutputIndex = outputIndex + Math.floor(wire.more / 2);\n                let lastCoordinates = {\n                    name: lastCoordinatesOriginal.name,\n                    connector: lastCoordinatesOriginal.connector,\n                    index: targetInputIndex + Math.floor(wire.more / 2)\n                };\n                let wireName = elementName + \"_o\" + outputIndex + \"_\" + targetElementName + \"_i\" + targetInputIndex + \"_wire\";\n                if (elementsMap[wireName] || wireNamesMap[wireName]) {\n                    throw new Error(element.element.name + \", wire index \" + i + \": cannot assign wire name \" + wireName + \" because it is already used\");\n                }\n                wireNamesMap[wireName] = true;\n                let initialValue = wire.initialValue !== null ? wire.initialValue : undefined;\n                let graphicalWire = new GraphicalWire_1.GraphicalWire(wireName, initialValue, 1 + wire.more);\n                let wireInputs = [];\n                for (let offset = 0; offset <= wire.more; offset++) {\n                    wireInputs.push({\n                        name: elementName,\n                        outputIndex: outputIndex + offset\n                    });\n                }\n                wireDescriptions.push({\n                    name: wireName,\n                    element: noElementInstancesForTesting ? \"GraphicalWire\" : graphicalWire,\n                    height: \"auto\",\n                    inputs: wireInputs,\n                    externalOutputs: [],\n                    coordinates: [\n                        {\n                            name: elementName,\n                            connector: \"output\",\n                            index: connectorCoordinateOutputIndex\n                        },\n                        ...(wire.coordinates.slice(0, wire.coordinates.length - 1)),\n                        lastCoordinates\n                    ]\n                });\n                for (let offset = 0; offset <= wire.more; offset++) {\n                    targetElement.inputs[targetInputIndex + offset] = {\n                        name: wireName,\n                        outputIndex: offset\n                    };\n                }\n            }\n        }\n        for (let parsedElement of elements) {\n            let elementName = parsedElement.name;\n            let element = elementsMap[elementName];\n            if (!element.element) {\n                continue;\n            }\n            let numInputs = 0;\n            for (let index in element.inputs) {\n                numInputs++;\n            }\n            let inputs = new Array(numInputs);\n            for (let i = 0; i < inputs.length; i++) {\n                if (!element.inputs[i]) {\n                    throw new Error(\"element \" + elementName + \": input index \" + i + \" is not connected\");\n                }\n                inputs[i] = element.inputs[i];\n            }\n            let numWireOutputs = 0;\n            for (let wire of element.element.wires) {\n                numWireOutputs++;\n                numWireOutputs += wire.more;\n            }\n            let numExternalOutputs = 0;\n            for (let externalOutput of element.element.externalOutputs) {\n                numExternalOutputs++;\n                numExternalOutputs += externalOutput.more;\n            }\n            let externalOutputs = new Array(numExternalOutputs);\n            let i = 0;\n            for (let externalOutput of element.element.externalOutputs) {\n                for (let j = 0; j <= externalOutput.more; j++) {\n                    externalOutputs[i] = externalOutput.outputIndex + j;\n                    i++;\n                }\n            }\n            let graphicalElement = GrammarParser.makeElement(element, inputs, numWireOutputs + numExternalOutputs);\n            elementDescriptions.push({\n                name: elementName,\n                element: noElementInstancesForTesting ? graphicalElement.constructor.name : graphicalElement,\n                height: \"auto\",\n                inputs: inputs,\n                externalOutputs: externalOutputs,\n                coordinates: [element.element.base]\n            });\n        }\n        return {\n            height: params.height,\n            stepsPerSecond: params.stepsPerSecond >= 0 ? params.stepsPerSecond : undefined,\n            cyclesPerStep: params.cyclesPerStep > 0 ? params.cyclesPerStep : undefined,\n            delayPerWindowHeight: params.delayPerWindowHeight < 0 ? undefined : params.delayPerWindowHeight,\n            additionalNorDelay: params.additionalNorDelay < 0 ? undefined : params.additionalNorDelay,\n            echoData: params.echoData,\n            echoFunctions: params.echoFunctions,\n            disableGraphics: params.disableGraphics,\n            wiringDescriptions: [\n                ...elementDescriptions,\n                ...wireDescriptions\n            ]\n        };\n    }\n    static getNextFreeIndex(map) {\n        for (let i = 0;; i++) {\n            if (map[i] === undefined) {\n                return i;\n            }\n        }\n    }\n    static makeAutoSource(elementName, inputIndex, xDelta, yDelta) {\n        let sourceName = `autosource_${elementName}_input${inputIndex}`;\n        return {\n            name: sourceName,\n            type: \"source\",\n            parameters: [],\n            base: {\n                base: {\n                    connector: \"output\",\n                    index: 0\n                },\n                coordinates: {\n                    x: {\n                        delta: xDelta,\n                        from: {\n                            name: elementName,\n                            connector: \"input\",\n                            index: inputIndex\n                        }\n                    },\n                    y: {\n                        delta: yDelta,\n                        from: {\n                            name: elementName,\n                            connector: \"input\",\n                            index: inputIndex\n                        }\n                    }\n                }\n            },\n            outsideInputs: [],\n            externalOutputs: [],\n            wires: [\n                {\n                    outputIndex: 0,\n                    more: 0,\n                    coordinates: [\n                        {\n                            name: elementName,\n                            connector: \"input\",\n                            index: inputIndex\n                        }\n                    ],\n                    initialValue: null\n                }\n            ]\n        };\n    }\n    static parseParameters(elementName, typeName, values, parameters) {\n        let elementNameDesc = elementName ? `element ${elementName}` : \"root\";\n        let typeNameDesc = typeName ? `type ${typeName}` : \"config\";\n        let parameterValues = {};\n        for (let value of values) {\n            let paramDesc = parameters[value.key];\n            if (!paramDesc) {\n                throw new Error(`${elementNameDesc}: unknown parameter for ${typeNameDesc}: ${value.key}`);\n            }\n            let paramValue;\n            if (paramDesc.parse) {\n                try {\n                    paramValue = paramDesc.parse(value.value);\n                }\n                catch (e) {\n                    throw new Error(`${elementNameDesc}: parsing of parameter ${value.key} failed for ${typeNameDesc}: ` + e.name + \": \" + e.message + \"\\n\" + e.stack);\n                }\n            }\n            else if ((typeof paramDesc.default) === \"number\") {\n                paramValue = parseInt(value.value);\n                if (isNaN(paramValue)) {\n                    throw new Error(`${elementNameDesc}: parsing of parameter ${value.key} failed for ${typeNameDesc}: number expected, got: ${value.value}`);\n                }\n            }\n            else if ((typeof paramDesc.default) === \"boolean\") {\n                if (value.value !== \"true\" && value.value !== \"false\") {\n                    throw new Error(`${elementNameDesc}: parsing of parameter ${value.key} failed for ${typeNameDesc}: boolean expected, got: ${value.value}`);\n                }\n                paramValue = (value.value === \"true\");\n            }\n            else {\n                paramValue = value.value;\n            }\n            parameterValues[value.key] = paramValue;\n        }\n        for (let parameterName in parameters) {\n            if (!parameterValues.hasOwnProperty(parameterName)) {\n                let parameterInfo = parameters[parameterName];\n                if (parameterInfo.required) {\n                    throw new Error(`${elementNameDesc}: missing parameter ${parameterName} for ${typeNameDesc}`);\n                }\n                else {\n                    parameterValues[parameterName] = parameterInfo.default;\n                }\n            }\n        }\n        for (let parameterName in parameterValues) {\n            let paramDesc = parameters[parameterName];\n            if (paramDesc.check) {\n                let paramValue = parameterValues[parameterName];\n                if (!paramDesc.check(paramValue)) {\n                    throw new Error(`element ${elementName}: parsing of parameter ${parameterName} failed for ${typeNameDesc}: check function returned false for value ${paramValue}: ${paramDesc.check.toString()}`);\n                }\n            }\n        }\n        return parameterValues;\n    }\n    static makeElement(processedElement, inputs, numOutputs) {\n        let element = processedElement.element;\n        let type = element.type;\n        switch (type) {\n            case \"nor\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, GrammarParser.PARAMS_INIT_OVERRIDEHEIGHT_MIRRORCONNECTORS);\n                return new GraphicalNor_1.GraphicalNor(element.name, inputs.length, params.init, params.overrideHeight >= 0 ? params.overrideHeight : undefined, params.mirrorConnectors);\n            }\n            case \"or\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT_MIRRORCONNECTORS);\n                return new GraphicalOr_1.GraphicalOr(element.name, inputs.length, params.detailed, params.overrideHeight >= 0 ? params.overrideHeight : undefined, params.mirrorConnectors);\n            }\n            case \"and\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT);\n                return new GraphicalAnd_1.GraphicalAnd(element.name, inputs.length, params.detailed, params.overrideHeight >= 0 ? params.overrideHeight : undefined);\n            }\n            case \"xor\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT);\n                return new GraphicalXor_1.GraphicalXor(element.name, params.detailed, params.overrideHeight >= 0 ? params.overrideHeight : undefined);\n            }\n            case \"sink\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, {});\n                return new GraphicalSinkTerminal_1.GraphicalSinkTerminal(element.name);\n            }\n            case \"source\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, {});\n                return new GraphicalSourceTerminal_1.GraphicalSourceTerminal(element.name, false);\n            }\n            case \"split\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, Object.assign({}, GrammarParser.PARAMS_INIT_OVERRIDEHEIGHT, { numInBits: {\n                        default: inputs.length,\n                        check: (n) => n >= 0\n                    }, numOutChannels: {\n                        default: numOutputs / Math.max(inputs.length, 1)\n                    }, line: {\n                        default: false\n                    }, displayValue: {\n                        default: \"\",\n                        check: (s) => s === \"\" || s === \"aboveLeft\" || s === \"aboveRight\" || s === \"belowLeft\" || s === \"belowRight\"\n                    } }));\n                return new GraphicalSplit_1.GraphicalSplit(element.name, params.numOutChannels, params.numInBits, params.line, params.overrideHeight >= 0 ? params.overrideHeight : undefined, params.init, params.displayValue ? params.displayValue : undefined);\n            }\n            case \"decoder\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, Object.assign({}, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT_MIRRORCONNECTORS, { numInBits: {\n                        default: Math.max(inputs.length, Math.ceil(Math.log2(numOutputs))),\n                        check: (n) => n > 0\n                    } }));\n                return new GraphicalDecoder_1.GraphicalDecoder(element.name, params.numInBits, params.detailed, params.mirrorConnectors, params.overrideHeight >= 0 ? params.overrideHeight : undefined);\n            }\n            case \"rsff\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, GrammarParser.PARAMS_INIT);\n                return new GraphicalRSFlipFlop_1.GraphicalRSFlipFlop(element.name, params.init);\n            }\n            case \"dff\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, GrammarParser.PARAMS_DETAILED_INIT);\n                return new GraphicalDFlipFlop_1.GraphicalDFlipFlop(element.name, params.detailed, params.init);\n            }\n            case \"jkff\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, GrammarParser.PARAMS_DETAILED_INIT);\n                return new GraphicalJKFlipFlop_1.GraphicalJKFlipFlop(element.name, params.detailed, params.init);\n            }\n            case \"reg\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, Object.assign({}, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT, { numInBits: {\n                        default: Math.max(numOutputs, inputs.length - 1),\n                        check: (n) => n >= 0\n                    }, mirrorConnectors: {\n                        default: false\n                    }, readOnly: {\n                        default: false\n                    }, initHex: {\n                        default: \"\"\n                    } }));\n                return new GraphicalRegister_1.GraphicalRegister(element.name, params.numInBits, params.detailed, params.overrideHeight >= 0 ? params.overrideHeight : undefined, params.mirrorConnectors, params.readOnly, params.initHex.length ? params.initHex : undefined);\n            }\n            case \"mux\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, Object.assign({}, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT, { numInChannels: {\n                        default: Math.ceil(inputs.length / (numOutputs + 1)),\n                        check: (n) => n > 0\n                    }, numOutBits: {\n                        default: numOutputs,\n                        check: (n) => n > 0\n                    }, wireDist: {\n                        default: -1\n                    }, mirrorConnectors: {\n                        default: false\n                    } }));\n                return new GraphicalMultiplexer_1.GraphicalMultiplexer(element.name, params.numInChannels, params.numOutBits, params.detailed, params.wireDist >= 0 ? params.wireDist : undefined, params.overrideHeight >= 0 ? params.overrideHeight : undefined, params.mirrorConnectors);\n            }\n            case \"ha\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, Object.assign({}, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT, { additionalAndOutput: {\n                        default: false\n                    } }));\n                return new GraphicalHalfAdder_1.GraphicalHalfAdder(element.name, params.detailed, params.overrideHeight >= 0 ? params.overrideHeight : undefined, params.additionalAndOutput);\n            }\n            case \"fa\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, Object.assign({}, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT, { additionalAndOutput: {\n                        default: false\n                    } }));\n                return new GraphicalFullAdder_1.GraphicalFullAdder(element.name, params.detailed, params.overrideHeight >= 0 ? params.overrideHeight : undefined, params.additionalAndOutput);\n            }\n            case \"micro16\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, {\n                    code: {\n                        default: \"\",\n                        required: true\n                    },\n                    instructionDelay: {\n                        default: -1\n                    },\n                    aluDelay: {\n                        default: -1\n                    },\n                    registersDelay: {\n                        default: -1\n                    }\n                });\n                return new GraphicalMicro16_1.GraphicalMicro16(element.name, params.code, params.instructionDelay >= 0 ? params.instructionDelay : undefined, params.aluDelay >= 0 ? params.aluDelay : undefined, params.registersDelay >= 0 ? params.registersDelay : undefined);\n            }\n            case \"micro16regs\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, {});\n                return new GraphicalMicro16Registers_1.GraphicalMicro16Registers(element.name);\n            }\n            case \"micro16alu\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, {});\n                return new GraphicalMicro16Alu_1.GraphicalMicro16Alu(element.name);\n            }\n            case \"micro16mic\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, {});\n                return new GraphicalMicro16Mic_1.GraphicalMicro16Mic(element.name);\n            }\n            case \"micro16store\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, {\n                    code: {\n                        default: \"\",\n                        required: true\n                    }\n                });\n                return new GraphicalMicro16Store_1.GraphicalMicro16Store(element.name, params.code);\n            }\n            case \"micro16clock\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, {\n                    instructionDelay: {\n                        default: -1\n                    },\n                    aluDelay: {\n                        default: -1\n                    },\n                    registersDelay: {\n                        default: -1\n                    }\n                });\n                return new GraphicalMicro16Clock_1.GraphicalMicro16Clock(element.name, params.instructionDelay >= 0 ? params.instructionDelay : undefined, params.aluDelay >= 0 ? params.aluDelay : undefined, params.registersDelay >= 0 ? params.registersDelay : undefined);\n            }\n            case \"manynors\": {\n                let params = GrammarParser.parseParameters(element.name, type, element.parameters, Object.assign({}, GrammarParser.PARAMS_DETAILED_INIT, { n: {\n                        default: 1,\n                        check: (n) => n > 0,\n                        required: true\n                    } }));\n                return new GraphicalManyNors_1.GraphicalManyNors(element.name, params.n, params.detailed, params.init);\n            }\n        }\n        throw new NeverError_1.NeverError(type, \"element \" + element.name + \": unknown type: \" + element.type);\n    }\n}\nexports.GrammarParser = GrammarParser;\n(function (GrammarParser) {\n    GrammarParser.DEFAULT_TOTAL_HEIGHT = 600;\n    GrammarParser.PARAMS_DETAILED = {\n        detailed: {\n            default: false\n        }\n    };\n    GrammarParser.PARAMS_INIT = {\n        init: {\n            default: false\n        }\n    };\n    GrammarParser.PARAMS_OVERRIDEHEIGHT = {\n        overrideHeight: {\n            default: -1\n        }\n    };\n    GrammarParser.PARAMS_MIRRORCONNECTORS = {\n        mirrorConnectors: {\n            default: false\n        }\n    };\n    GrammarParser.PARAMS_DETAILED_INIT = Object.assign({}, GrammarParser.PARAMS_DETAILED, GrammarParser.PARAMS_INIT);\n    GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT = Object.assign({}, GrammarParser.PARAMS_DETAILED, GrammarParser.PARAMS_OVERRIDEHEIGHT);\n    GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT_MIRRORCONNECTORS = Object.assign({}, GrammarParser.PARAMS_DETAILED_OVERRIDEHEIGHT, GrammarParser.PARAMS_MIRRORCONNECTORS);\n    GrammarParser.PARAMS_INIT_OVERRIDEHEIGHT = Object.assign({}, GrammarParser.PARAMS_INIT, GrammarParser.PARAMS_OVERRIDEHEIGHT);\n    GrammarParser.PARAMS_INIT_OVERRIDEHEIGHT_MIRRORCONNECTORS = Object.assign({}, GrammarParser.PARAMS_INIT_OVERRIDEHEIGHT, GrammarParser.PARAMS_MIRRORCONNECTORS);\n})(GrammarParser = exports.GrammarParser || (exports.GrammarParser = {}));\n//# sourceMappingURL=GrammarParser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhbW1hci9HcmFtbWFyUGFyc2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYW1tYXIvR3JhbW1hclBhcnNlci5qcz9lZTE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbmVhcmxleSA9IHJlcXVpcmUoXCJuZWFybGV5XCIpO1xuY29uc3QgR3JhcGhpY2FsV2lyZV8xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFwaGljYWxOb3JfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljcy9HcmFwaGljYWxOb3JcIik7XG5jb25zdCBOZXZlckVycm9yXzEgPSByZXF1aXJlKFwiLi4vTmV2ZXJFcnJvclwiKTtcbmNvbnN0IEdyYXBoaWNhbFNpbmtUZXJtaW5hbF8xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbFNpbmtUZXJtaW5hbFwiKTtcbmNvbnN0IEdyYXBoaWNhbFNvdXJjZVRlcm1pbmFsXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGhpY3MvR3JhcGhpY2FsU291cmNlVGVybWluYWxcIik7XG5jb25zdCBHcmFwaGljYWxTcGxpdF8xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbFNwbGl0XCIpO1xuY29uc3QgR3JhcGhpY2FsRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbERlY29kZXJcIik7XG5jb25zdCBHcmFwaGljYWxERmxpcEZsb3BfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljcy9HcmFwaGljYWxERmxpcEZsb3BcIik7XG5jb25zdCBHcmFwaGljYWxSZWdpc3Rlcl8xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbFJlZ2lzdGVyXCIpO1xuY29uc3QgR3JhcGhpY2FsUlNGbGlwRmxvcF8xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbFJTRmxpcEZsb3BcIik7XG5jb25zdCBHcmFwaGljYWxKS0ZsaXBGbG9wXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGhpY3MvR3JhcGhpY2FsSktGbGlwRmxvcFwiKTtcbmNvbnN0IEdyYXBoaWNhbE11bHRpcGxleGVyXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGhpY3MvR3JhcGhpY2FsTXVsdGlwbGV4ZXJcIik7XG5jb25zdCBHcmFwaGljYWxIYWxmQWRkZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljcy9HcmFwaGljYWxIYWxmQWRkZXJcIik7XG5jb25zdCBHcmFwaGljYWxGdWxsQWRkZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljcy9HcmFwaGljYWxGdWxsQWRkZXJcIik7XG5jb25zdCBHcmFwaGljYWxPcl8xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbE9yXCIpO1xuY29uc3QgR3JhcGhpY2FsQW5kXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGhpY3MvR3JhcGhpY2FsQW5kXCIpO1xuY29uc3QgR3JhcGhpY2FsWG9yXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGhpY3MvR3JhcGhpY2FsWG9yXCIpO1xuY29uc3QgR3JhcGhpY2FsTWljcm8xNl8xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbE1pY3JvMTZcIik7XG5jb25zdCBHcmFwaGljYWxNaWNybzE2UmVnaXN0ZXJzXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGhpY3MvR3JhcGhpY2FsTWljcm8xNlJlZ2lzdGVyc1wiKTtcbmNvbnN0IEdyYXBoaWNhbE1pY3JvMTZBbHVfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljcy9HcmFwaGljYWxNaWNybzE2QWx1XCIpO1xuY29uc3QgR3JhcGhpY2FsTWljcm8xNk1pY18xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbE1pY3JvMTZNaWNcIik7XG5jb25zdCBHcmFwaGljYWxNaWNybzE2U3RvcmVfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljcy9HcmFwaGljYWxNaWNybzE2U3RvcmVcIik7XG5jb25zdCBHcmFwaGljYWxNaWNybzE2Q2xvY2tfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljcy9HcmFwaGljYWxNaWNybzE2Q2xvY2tcIik7XG5jb25zdCBHcmFwaGljYWxNYW55Tm9yc18xID0gcmVxdWlyZShcIi4uL2dyYXBoaWNzL0dyYXBoaWNhbE1hbnlOb3JzXCIpO1xuY29uc3QgZ3JhbW1hciA9IHJlcXVpcmUoXCIuLi8uLi9ncmFtbWFyL2dyYW1tYXIuanNcIik7XG5jbGFzcyBHcmFtbWFyUGFyc2VyIHtcbiAgICBzdGF0aWMgcGFyc2UoZGVzY3JpcHRpb25zLCBub0VsZW1lbnRJbnN0YW5jZXNGb3JUZXN0aW5nID0gZmFsc2UsIGtub3duRWxlbWVudE5hbWVzID0gW10pIHtcbiAgICAgICAgbGV0IHBhcnNlZEVsZW1lbnRzID0gbmV3IEFycmF5KGRlc2NyaXB0aW9ucy5sZW5ndGgpO1xuICAgICAgICBsZXQgcGFyc2VkQ29uZmlncyA9IG5ldyBBcnJheShkZXNjcmlwdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgIGxldCBwYXJzZXIgPSBuZXcgbmVhcmxleS5QYXJzZXIobmVhcmxleS5HcmFtbWFyLmZyb21Db21waWxlZChncmFtbWFyKSk7XG4gICAgICAgICAgICBwYXJzZXIuZmVlZChkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBwYXJzZXIuZmluaXNoKCk7XG4gICAgICAgICAgICBsZXQgcGFyc2VkID0gcGFyc2VyLnJlc3VsdHNbMF07XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50c1tpXSA9IHBhcnNlZC5lbGVtZW50cztcbiAgICAgICAgICAgIHBhcnNlZENvbmZpZ3NbaV0gPSBwYXJzZWQuY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSB7XG4gICAgICAgICAgICBjb25maWc6IFtdLmNvbmNhdCguLi5wYXJzZWRDb25maWdzKSxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBbXS5jb25jYXQoLi4ucGFyc2VkRWxlbWVudHMpXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcGFyc2VkLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90aGluZyBwYXJzZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdyYW1tYXJQYXJzZXIuZnJvbVBhcnNlZChwYXJzZWQsIG5vRWxlbWVudEluc3RhbmNlc0ZvclRlc3RpbmcsIGtub3duRWxlbWVudE5hbWVzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21QYXJzZWQocGFyc2VkLCBub0VsZW1lbnRJbnN0YW5jZXNGb3JUZXN0aW5nID0gZmFsc2UsIGtub3duRWxlbWVudE5hbWVzID0gW10pIHtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gcGFyc2VkLmVsZW1lbnRzO1xuICAgICAgICBsZXQgcGFyYW1zID0gdGhpcy5wYXJzZVBhcmFtZXRlcnModW5kZWZpbmVkLCB1bmRlZmluZWQsIHBhcnNlZC5jb25maWcsIHtcbiAgICAgICAgICAgIGhlaWdodDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IEdyYW1tYXJQYXJzZXIuREVGQVVMVF9UT1RBTF9IRUlHSFRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdXRvU291cmNlOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdXRvU291cmNlRGVsdGFYOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogLTIgKiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdXRvU291cmNlRGVsdGFZOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0ZXBzUGVyU2Vjb25kOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogLTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjeWNsZXNQZXJTdGVwOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxheVBlcldpbmRvd0hlaWdodDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC0xXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkaXRpb25hbE5vckRlbGF5OiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogLTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlY2hvRGF0YToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWNob0Z1bmN0aW9uczoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzYWJsZUdyYXBoaWNzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBlbGVtZW50c01hcCA9IHt9O1xuICAgICAgICBsZXQgd2lyZU5hbWVzTWFwID0ge307XG4gICAgICAgIGxldCB3aXJlRGVzY3JpcHRpb25zID0gW107XG4gICAgICAgIGxldCBlbGVtZW50RGVzY3JpcHRpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGVsZW1lbnROYW1lIG9mIGtub3duRWxlbWVudE5hbWVzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHNNYXBbZWxlbWVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGtub3duIGVsZW1lbnQgXCIgKyBlbGVtZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50c01hcFtlbGVtZW50TmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGlucHV0czoge30sXG4gICAgICAgICAgICAgICAgb3V0cHV0czoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzTWFwW2VsZW1lbnQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgZWxlbWVudCBcIiArIGVsZW1lbnQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50c01hcFtlbGVtZW50Lm5hbWVdID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB7fSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwYXJzZWRFbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudE5hbWUgPSBwYXJzZWRFbGVtZW50Lm5hbWU7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRzTWFwW2VsZW1lbnROYW1lXTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBvdXRzaWRlSW5wdXQgb2YgZWxlbWVudC5lbGVtZW50Lm91dHNpZGVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXRJbmRleCA9IG91dHNpZGVJbnB1dC5pbnB1dEluZGV4ICE9PSBudWxsID8gb3V0c2lkZUlucHV0LmlucHV0SW5kZXggOiBHcmFtbWFyUGFyc2VyLmdldE5leHRGcmVlSW5kZXgoZWxlbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG91dHNpZGVJbnB1dC5tb3JlOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5wdXRzW2lucHV0SW5kZXggKyBpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3Qgc2V0IGlucHV0ICR7aW5wdXRJbmRleH0gb2YgZWxlbWVudCAke2VsZW1lbnROYW1lfSBhcyBvdXRzaWRlIGlucHV0OiBpbnB1dCBpcyBhbHJlYWR5IG9jY3VwaWVkYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5hdXRvU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXV0b1NvdXJjZUVsZW1lbnQgPSBHcmFtbWFyUGFyc2VyLm1ha2VBdXRvU291cmNlKGVsZW1lbnROYW1lLCBpbnB1dEluZGV4ICsgaSwgcGFyYW1zLmF1dG9Tb3VyY2VEZWx0YVgsIHBhcmFtcy5hdXRvU291cmNlRGVsdGFZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c01hcFthdXRvU291cmNlRWxlbWVudC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNyZWF0ZSBhdXRvc291cmNlIGVsZW1lbnQgZm9yIGVsZW1lbnQgJHtlbGVtZW50TmFtZX06IGVsZW1lbnQgJHthdXRvU291cmNlRWxlbWVudC5uYW1lfSBleGlzdHNgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYXV0b1NvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNNYXBbYXV0b1NvdXJjZUVsZW1lbnQubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogYXV0b1NvdXJjZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5wdXRzW2lucHV0SW5kZXggKyBpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdXRvU291cmNlRWxlbWVudC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnB1dHNbaW5wdXRJbmRleCArIGldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib3V0c2lkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiBvdXRzaWRlSW5wdXQub3V0cHV0SW5kZXggKyBpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZXh0ZXJuYWxPdXRwdXQgb2YgZWxlbWVudC5lbGVtZW50LmV4dGVybmFsT3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGV4dGVybmFsT3V0cHV0Lm1vcmU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBleHRlcm5hbE91dHB1dC5vdXRwdXRJbmRleCArIGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm91dHB1dHNbb3V0cHV0SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZWxlbWVudC5lbGVtZW50Lm5hbWUgKyBcIjogY2Fubm90IHVzZSBvdXRwdXQgaW5kZXggXCIgKyBvdXRwdXRJbmRleCArIFwiIGZvciBleHRlcm5hbCBvdXRwdXQgdHdpY2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vdXRwdXRzW291dHB1dEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmVsZW1lbnQud2lyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgd2lyZSA9IGVsZW1lbnQuZWxlbWVudC53aXJlc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSB3aXJlLm91dHB1dEluZGV4ICE9PSBudWxsID8gd2lyZS5vdXRwdXRJbmRleCA6IEdyYW1tYXJQYXJzZXIuZ2V0TmV4dEZyZWVJbmRleChlbGVtZW50Lm91dHB1dHMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8PSB3aXJlLm1vcmU7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm91dHB1dHNbb3V0cHV0SW5kZXggKyBvZmZzZXRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZWxlbWVudC5lbGVtZW50Lm5hbWUgKyBcIiwgd2lyZSBpbmRleCBcIiArIGkgKyBcIjogY2Fubm90IHVzZSBvdXRwdXQgaW5kZXggXCIgKyAob3V0cHV0SW5kZXggKyBvZmZzZXQpICsgXCIgdHdpY2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDw9IHdpcmUubW9yZTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vdXRwdXRzW291dHB1dEluZGV4ICsgb2Zmc2V0XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBsYXN0Q29vcmRpbmF0ZXNPcmlnaW5hbCA9IHdpcmUuY29vcmRpbmF0ZXNbd2lyZS5jb29yZGluYXRlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RDb29yZGluYXRlc09yaWdpbmFsLm5hbWUgfHwgbGFzdENvb3JkaW5hdGVzT3JpZ2luYWwuY29ubmVjdG9yICE9PSBcImlucHV0XCIgfHwgbGFzdENvb3JkaW5hdGVzT3JpZ2luYWwuaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZWxlbWVudC5lbGVtZW50Lm5hbWUgKyBcIiwgd2lyZSBpbmRleCBcIiArIGkgKyBcIjogd2lyZSBuZWVkcyB0byB0ZXJtaW5hdGUgaW4gc29tZSBpbnB1dCBjb25uZWN0b3Igb2Ygc29tZSBlbGVtZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudE5hbWUgPSBsYXN0Q29vcmRpbmF0ZXNPcmlnaW5hbC5uYW1lO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRFbGVtZW50ID0gZWxlbWVudHNNYXBbdGFyZ2V0RWxlbWVudE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZWxlbWVudC5lbGVtZW50Lm5hbWUgKyBcIiwgd2lyZSBpbmRleCBcIiArIGkgKyBcIjogdW5rbm93biBlbGVtZW50IG5hbWUgaW4gdGVybWluYXRpbmcgaW5wdXQgY29ubmVjdG9yIHJlZmVyZW5jZTogXCIgKyBsYXN0Q29vcmRpbmF0ZXNPcmlnaW5hbC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldElucHV0SW5kZXggPSBsYXN0Q29vcmRpbmF0ZXNPcmlnaW5hbC5pbmRleCAhPT0gbnVsbCA/IGxhc3RDb29yZGluYXRlc09yaWdpbmFsLmluZGV4IDogR3JhbW1hclBhcnNlci5nZXROZXh0RnJlZUluZGV4KHRhcmdldEVsZW1lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPD0gd2lyZS5tb3JlOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudC5pbnB1dHNbdGFyZ2V0SW5wdXRJbmRleCArIG9mZnNldF0gJiYgdGFyZ2V0RWxlbWVudC5pbnB1dHNbdGFyZ2V0SW5wdXRJbmRleCArIG9mZnNldF0ubmFtZSAhPT0gZWxlbWVudC5lbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbGVtZW50LmVsZW1lbnQubmFtZSArIFwiLCB3aXJlIGluZGV4IFwiICsgaSArIFwiOiB0YXJnZXQgZWxlbWVudCBpbnB1dCBpbmRleCBcIiArICh0YXJnZXRJbnB1dEluZGV4ICsgb2Zmc2V0KSArIFwiIGlzIG9jY3VwaWVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0b3JDb29yZGluYXRlT3V0cHV0SW5kZXggPSBvdXRwdXRJbmRleCArIE1hdGguZmxvb3Iod2lyZS5tb3JlIC8gMik7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbGFzdENvb3JkaW5hdGVzT3JpZ2luYWwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yOiBsYXN0Q29vcmRpbmF0ZXNPcmlnaW5hbC5jb25uZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiB0YXJnZXRJbnB1dEluZGV4ICsgTWF0aC5mbG9vcih3aXJlLm1vcmUgLyAyKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGV0IHdpcmVOYW1lID0gZWxlbWVudE5hbWUgKyBcIl9vXCIgKyBvdXRwdXRJbmRleCArIFwiX1wiICsgdGFyZ2V0RWxlbWVudE5hbWUgKyBcIl9pXCIgKyB0YXJnZXRJbnB1dEluZGV4ICsgXCJfd2lyZVwiO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c01hcFt3aXJlTmFtZV0gfHwgd2lyZU5hbWVzTWFwW3dpcmVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZWxlbWVudC5lbGVtZW50Lm5hbWUgKyBcIiwgd2lyZSBpbmRleCBcIiArIGkgKyBcIjogY2Fubm90IGFzc2lnbiB3aXJlIG5hbWUgXCIgKyB3aXJlTmFtZSArIFwiIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aXJlTmFtZXNNYXBbd2lyZU5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbFZhbHVlID0gd2lyZS5pbml0aWFsVmFsdWUgIT09IG51bGwgPyB3aXJlLmluaXRpYWxWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgZ3JhcGhpY2FsV2lyZSA9IG5ldyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZSh3aXJlTmFtZSwgaW5pdGlhbFZhbHVlLCAxICsgd2lyZS5tb3JlKTtcbiAgICAgICAgICAgICAgICBsZXQgd2lyZUlucHV0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8PSB3aXJlLm1vcmU7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpcmVJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiBvdXRwdXRJbmRleCArIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2lyZURlc2NyaXB0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogd2lyZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5vRWxlbWVudEluc3RhbmNlc0ZvclRlc3RpbmcgPyBcIkdyYXBoaWNhbFdpcmVcIiA6IGdyYXBoaWNhbFdpcmUsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogd2lyZUlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3I6IFwib3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNvbm5lY3RvckNvb3JkaW5hdGVPdXRwdXRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLih3aXJlLmNvb3JkaW5hdGVzLnNsaWNlKDAsIHdpcmUuY29vcmRpbmF0ZXMubGVuZ3RoIC0gMSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPD0gd2lyZS5tb3JlOyBvZmZzZXQrKykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LmlucHV0c1t0YXJnZXRJbnB1dEluZGV4ICsgb2Zmc2V0XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHdpcmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0SW5kZXg6IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwYXJzZWRFbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudE5hbWUgPSBwYXJzZWRFbGVtZW50Lm5hbWU7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRzTWFwW2VsZW1lbnROYW1lXTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtSW5wdXRzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4IGluIGVsZW1lbnQuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgbnVtSW5wdXRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5wdXRzID0gbmV3IEFycmF5KG51bUlucHV0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5pbnB1dHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZWxlbWVudCBcIiArIGVsZW1lbnROYW1lICsgXCI6IGlucHV0IGluZGV4IFwiICsgaSArIFwiIGlzIG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0c1tpXSA9IGVsZW1lbnQuaW5wdXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG51bVdpcmVPdXRwdXRzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpcmUgb2YgZWxlbWVudC5lbGVtZW50LndpcmVzKSB7XG4gICAgICAgICAgICAgICAgbnVtV2lyZU91dHB1dHMrKztcbiAgICAgICAgICAgICAgICBudW1XaXJlT3V0cHV0cyArPSB3aXJlLm1vcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbnVtRXh0ZXJuYWxPdXRwdXRzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGV4dGVybmFsT3V0cHV0IG9mIGVsZW1lbnQuZWxlbWVudC5leHRlcm5hbE91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBudW1FeHRlcm5hbE91dHB1dHMrKztcbiAgICAgICAgICAgICAgICBudW1FeHRlcm5hbE91dHB1dHMgKz0gZXh0ZXJuYWxPdXRwdXQubW9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRlcm5hbE91dHB1dHMgPSBuZXcgQXJyYXkobnVtRXh0ZXJuYWxPdXRwdXRzKTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGV4dGVybmFsT3V0cHV0IG9mIGVsZW1lbnQuZWxlbWVudC5leHRlcm5hbE91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBleHRlcm5hbE91dHB1dC5tb3JlOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzW2ldID0gZXh0ZXJuYWxPdXRwdXQub3V0cHV0SW5kZXggKyBqO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdyYXBoaWNhbEVsZW1lbnQgPSBHcmFtbWFyUGFyc2VyLm1ha2VFbGVtZW50KGVsZW1lbnQsIGlucHV0cywgbnVtV2lyZU91dHB1dHMgKyBudW1FeHRlcm5hbE91dHB1dHMpO1xuICAgICAgICAgICAgZWxlbWVudERlc2NyaXB0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50TmFtZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBub0VsZW1lbnRJbnN0YW5jZXNGb3JUZXN0aW5nID8gZ3JhcGhpY2FsRWxlbWVudC5jb25zdHJ1Y3Rvci5uYW1lIDogZ3JhcGhpY2FsRWxlbWVudCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXRzLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogZXh0ZXJuYWxPdXRwdXRzLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbZWxlbWVudC5lbGVtZW50LmJhc2VdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiBwYXJhbXMuaGVpZ2h0LFxuICAgICAgICAgICAgc3RlcHNQZXJTZWNvbmQ6IHBhcmFtcy5zdGVwc1BlclNlY29uZCA+PSAwID8gcGFyYW1zLnN0ZXBzUGVyU2Vjb25kIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3ljbGVzUGVyU3RlcDogcGFyYW1zLmN5Y2xlc1BlclN0ZXAgPiAwID8gcGFyYW1zLmN5Y2xlc1BlclN0ZXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkZWxheVBlcldpbmRvd0hlaWdodDogcGFyYW1zLmRlbGF5UGVyV2luZG93SGVpZ2h0IDwgMCA/IHVuZGVmaW5lZCA6IHBhcmFtcy5kZWxheVBlcldpbmRvd0hlaWdodCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxOb3JEZWxheTogcGFyYW1zLmFkZGl0aW9uYWxOb3JEZWxheSA8IDAgPyB1bmRlZmluZWQgOiBwYXJhbXMuYWRkaXRpb25hbE5vckRlbGF5LFxuICAgICAgICAgICAgZWNob0RhdGE6IHBhcmFtcy5lY2hvRGF0YSxcbiAgICAgICAgICAgIGVjaG9GdW5jdGlvbnM6IHBhcmFtcy5lY2hvRnVuY3Rpb25zLFxuICAgICAgICAgICAgZGlzYWJsZUdyYXBoaWNzOiBwYXJhbXMuZGlzYWJsZUdyYXBoaWNzLFxuICAgICAgICAgICAgd2lyaW5nRGVzY3JpcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgLi4uZWxlbWVudERlc2NyaXB0aW9ucyxcbiAgICAgICAgICAgICAgICAuLi53aXJlRGVzY3JpcHRpb25zXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXROZXh0RnJlZUluZGV4KG1hcCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcFtpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIG1ha2VBdXRvU291cmNlKGVsZW1lbnROYW1lLCBpbnB1dEluZGV4LCB4RGVsdGEsIHlEZWx0YSkge1xuICAgICAgICBsZXQgc291cmNlTmFtZSA9IGBhdXRvc291cmNlXyR7ZWxlbWVudE5hbWV9X2lucHV0JHtpbnB1dEluZGV4fWA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtdLFxuICAgICAgICAgICAgYmFzZToge1xuICAgICAgICAgICAgICAgIGJhc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yOiBcIm91dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHhEZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3I6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5wdXRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogeURlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbnB1dEluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3V0c2lkZUlucHV0czogW10sXG4gICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgd2lyZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgICBtb3JlOiAwLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbnB1dEluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlUGFyYW1ldGVycyhlbGVtZW50TmFtZSwgdHlwZU5hbWUsIHZhbHVlcywgcGFyYW1ldGVycykge1xuICAgICAgICBsZXQgZWxlbWVudE5hbWVEZXNjID0gZWxlbWVudE5hbWUgPyBgZWxlbWVudCAke2VsZW1lbnROYW1lfWAgOiBcInJvb3RcIjtcbiAgICAgICAgbGV0IHR5cGVOYW1lRGVzYyA9IHR5cGVOYW1lID8gYHR5cGUgJHt0eXBlTmFtZX1gIDogXCJjb25maWdcIjtcbiAgICAgICAgbGV0IHBhcmFtZXRlclZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCBwYXJhbURlc2MgPSBwYXJhbWV0ZXJzW3ZhbHVlLmtleV07XG4gICAgICAgICAgICBpZiAoIXBhcmFtRGVzYykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlbGVtZW50TmFtZURlc2N9OiB1bmtub3duIHBhcmFtZXRlciBmb3IgJHt0eXBlTmFtZURlc2N9OiAke3ZhbHVlLmtleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJhbVZhbHVlO1xuICAgICAgICAgICAgaWYgKHBhcmFtRGVzYy5wYXJzZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgPSBwYXJhbURlc2MucGFyc2UodmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZWxlbWVudE5hbWVEZXNjfTogcGFyc2luZyBvZiBwYXJhbWV0ZXIgJHt2YWx1ZS5rZXl9IGZhaWxlZCBmb3IgJHt0eXBlTmFtZURlc2N9OiBgICsgZS5uYW1lICsgXCI6IFwiICsgZS5tZXNzYWdlICsgXCJcXG5cIiArIGUuc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlb2YgcGFyYW1EZXNjLmRlZmF1bHQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1WYWx1ZSA9IHBhcnNlSW50KHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyYW1WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2VsZW1lbnROYW1lRGVzY306IHBhcnNpbmcgb2YgcGFyYW1ldGVyICR7dmFsdWUua2V5fSBmYWlsZWQgZm9yICR7dHlwZU5hbWVEZXNjfTogbnVtYmVyIGV4cGVjdGVkLCBnb3Q6ICR7dmFsdWUudmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGVvZiBwYXJhbURlc2MuZGVmYXVsdCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnZhbHVlICE9PSBcInRydWVcIiAmJiB2YWx1ZS52YWx1ZSAhPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlbGVtZW50TmFtZURlc2N9OiBwYXJzaW5nIG9mIHBhcmFtZXRlciAke3ZhbHVlLmtleX0gZmFpbGVkIGZvciAke3R5cGVOYW1lRGVzY306IGJvb2xlYW4gZXhwZWN0ZWQsIGdvdDogJHt2YWx1ZS52YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1WYWx1ZSA9ICh2YWx1ZS52YWx1ZSA9PT0gXCJ0cnVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1WYWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1ldGVyVmFsdWVzW3ZhbHVlLmtleV0gPSBwYXJhbVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHBhcmFtZXRlck5hbWUgaW4gcGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKCFwYXJhbWV0ZXJWYWx1ZXMuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVySW5mbyA9IHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlckluZm8ucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2VsZW1lbnROYW1lRGVzY306IG1pc3NpbmcgcGFyYW1ldGVyICR7cGFyYW1ldGVyTmFtZX0gZm9yICR7dHlwZU5hbWVEZXNjfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyVmFsdWVzW3BhcmFtZXRlck5hbWVdID0gcGFyYW1ldGVySW5mby5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwYXJhbWV0ZXJOYW1lIGluIHBhcmFtZXRlclZhbHVlcykge1xuICAgICAgICAgICAgbGV0IHBhcmFtRGVzYyA9IHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV07XG4gICAgICAgICAgICBpZiAocGFyYW1EZXNjLmNoZWNrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtVmFsdWUgPSBwYXJhbWV0ZXJWYWx1ZXNbcGFyYW1ldGVyTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbURlc2MuY2hlY2socGFyYW1WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbGVtZW50ICR7ZWxlbWVudE5hbWV9OiBwYXJzaW5nIG9mIHBhcmFtZXRlciAke3BhcmFtZXRlck5hbWV9IGZhaWxlZCBmb3IgJHt0eXBlTmFtZURlc2N9OiBjaGVjayBmdW5jdGlvbiByZXR1cm5lZCBmYWxzZSBmb3IgdmFsdWUgJHtwYXJhbVZhbHVlfTogJHtwYXJhbURlc2MuY2hlY2sudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlclZhbHVlcztcbiAgICB9XG4gICAgc3RhdGljIG1ha2VFbGVtZW50KHByb2Nlc3NlZEVsZW1lbnQsIGlucHV0cywgbnVtT3V0cHV0cykge1xuICAgICAgICBsZXQgZWxlbWVudCA9IHByb2Nlc3NlZEVsZW1lbnQuZWxlbWVudDtcbiAgICAgICAgbGV0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm5vclwiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCBHcmFtbWFyUGFyc2VyLlBBUkFNU19JTklUX09WRVJSSURFSEVJR0hUX01JUlJPUkNPTk5FQ1RPUlMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yKGVsZW1lbnQubmFtZSwgaW5wdXRzLmxlbmd0aCwgcGFyYW1zLmluaXQsIHBhcmFtcy5vdmVycmlkZUhlaWdodCA+PSAwID8gcGFyYW1zLm92ZXJyaWRlSGVpZ2h0IDogdW5kZWZpbmVkLCBwYXJhbXMubWlycm9yQ29ubmVjdG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwib3JcIjoge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBHcmFtbWFyUGFyc2VyLnBhcnNlUGFyYW1ldGVycyhlbGVtZW50Lm5hbWUsIHR5cGUsIGVsZW1lbnQucGFyYW1ldGVycywgR3JhbW1hclBhcnNlci5QQVJBTVNfREVUQUlMRURfT1ZFUlJJREVIRUlHSFRfTUlSUk9SQ09OTkVDVE9SUyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yKGVsZW1lbnQubmFtZSwgaW5wdXRzLmxlbmd0aCwgcGFyYW1zLmRldGFpbGVkLCBwYXJhbXMub3ZlcnJpZGVIZWlnaHQgPj0gMCA/IHBhcmFtcy5vdmVycmlkZUhlaWdodCA6IHVuZGVmaW5lZCwgcGFyYW1zLm1pcnJvckNvbm5lY3RvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImFuZFwiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCBHcmFtbWFyUGFyc2VyLlBBUkFNU19ERVRBSUxFRF9PVkVSUklERUhFSUdIVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljYWxBbmRfMS5HcmFwaGljYWxBbmQoZWxlbWVudC5uYW1lLCBpbnB1dHMubGVuZ3RoLCBwYXJhbXMuZGV0YWlsZWQsIHBhcmFtcy5vdmVycmlkZUhlaWdodCA+PSAwID8gcGFyYW1zLm92ZXJyaWRlSGVpZ2h0IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ4b3JcIjoge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBHcmFtbWFyUGFyc2VyLnBhcnNlUGFyYW1ldGVycyhlbGVtZW50Lm5hbWUsIHR5cGUsIGVsZW1lbnQucGFyYW1ldGVycywgR3JhbW1hclBhcnNlci5QQVJBTVNfREVUQUlMRURfT1ZFUlJJREVIRUlHSFQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsWG9yXzEuR3JhcGhpY2FsWG9yKGVsZW1lbnQubmFtZSwgcGFyYW1zLmRldGFpbGVkLCBwYXJhbXMub3ZlcnJpZGVIZWlnaHQgPj0gMCA/IHBhcmFtcy5vdmVycmlkZUhlaWdodCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic2lua1wiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljYWxTaW5rVGVybWluYWxfMS5HcmFwaGljYWxTaW5rVGVybWluYWwoZWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2VcIjoge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBHcmFtbWFyUGFyc2VyLnBhcnNlUGFyYW1ldGVycyhlbGVtZW50Lm5hbWUsIHR5cGUsIGVsZW1lbnQucGFyYW1ldGVycywge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsU291cmNlVGVybWluYWxfMS5HcmFwaGljYWxTb3VyY2VUZXJtaW5hbChlbGVtZW50Lm5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzcGxpdFwiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCBPYmplY3QuYXNzaWduKHt9LCBHcmFtbWFyUGFyc2VyLlBBUkFNU19JTklUX09WRVJSSURFSEVJR0hULCB7IG51bUluQml0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogaW5wdXRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrOiAobikgPT4gbiA+PSAwXG4gICAgICAgICAgICAgICAgICAgIH0sIG51bU91dENoYW5uZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBudW1PdXRwdXRzIC8gTWF0aC5tYXgoaW5wdXRzLmxlbmd0aCwgMSlcbiAgICAgICAgICAgICAgICAgICAgfSwgbGluZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSwgZGlzcGxheVZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2s6IChzKSA9PiBzID09PSBcIlwiIHx8IHMgPT09IFwiYWJvdmVMZWZ0XCIgfHwgcyA9PT0gXCJhYm92ZVJpZ2h0XCIgfHwgcyA9PT0gXCJiZWxvd0xlZnRcIiB8fCBzID09PSBcImJlbG93UmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNhbFNwbGl0XzEuR3JhcGhpY2FsU3BsaXQoZWxlbWVudC5uYW1lLCBwYXJhbXMubnVtT3V0Q2hhbm5lbHMsIHBhcmFtcy5udW1JbkJpdHMsIHBhcmFtcy5saW5lLCBwYXJhbXMub3ZlcnJpZGVIZWlnaHQgPj0gMCA/IHBhcmFtcy5vdmVycmlkZUhlaWdodCA6IHVuZGVmaW5lZCwgcGFyYW1zLmluaXQsIHBhcmFtcy5kaXNwbGF5VmFsdWUgPyBwYXJhbXMuZGlzcGxheVZhbHVlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJkZWNvZGVyXCI6IHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0gR3JhbW1hclBhcnNlci5wYXJzZVBhcmFtZXRlcnMoZWxlbWVudC5uYW1lLCB0eXBlLCBlbGVtZW50LnBhcmFtZXRlcnMsIE9iamVjdC5hc3NpZ24oe30sIEdyYW1tYXJQYXJzZXIuUEFSQU1TX0RFVEFJTEVEX09WRVJSSURFSEVJR0hUX01JUlJPUkNPTk5FQ1RPUlMsIHsgbnVtSW5CaXRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBNYXRoLm1heChpbnB1dHMubGVuZ3RoLCBNYXRoLmNlaWwoTWF0aC5sb2cyKG51bU91dHB1dHMpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVjazogKG4pID0+IG4gPiAwXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsRGVjb2Rlcl8xLkdyYXBoaWNhbERlY29kZXIoZWxlbWVudC5uYW1lLCBwYXJhbXMubnVtSW5CaXRzLCBwYXJhbXMuZGV0YWlsZWQsIHBhcmFtcy5taXJyb3JDb25uZWN0b3JzLCBwYXJhbXMub3ZlcnJpZGVIZWlnaHQgPj0gMCA/IHBhcmFtcy5vdmVycmlkZUhlaWdodCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicnNmZlwiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCBHcmFtbWFyUGFyc2VyLlBBUkFNU19JTklUKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNhbFJTRmxpcEZsb3BfMS5HcmFwaGljYWxSU0ZsaXBGbG9wKGVsZW1lbnQubmFtZSwgcGFyYW1zLmluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImRmZlwiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCBHcmFtbWFyUGFyc2VyLlBBUkFNU19ERVRBSUxFRF9JTklUKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNhbERGbGlwRmxvcF8xLkdyYXBoaWNhbERGbGlwRmxvcChlbGVtZW50Lm5hbWUsIHBhcmFtcy5kZXRhaWxlZCwgcGFyYW1zLmluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImprZmZcIjoge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBHcmFtbWFyUGFyc2VyLnBhcnNlUGFyYW1ldGVycyhlbGVtZW50Lm5hbWUsIHR5cGUsIGVsZW1lbnQucGFyYW1ldGVycywgR3JhbW1hclBhcnNlci5QQVJBTVNfREVUQUlMRURfSU5JVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljYWxKS0ZsaXBGbG9wXzEuR3JhcGhpY2FsSktGbGlwRmxvcChlbGVtZW50Lm5hbWUsIHBhcmFtcy5kZXRhaWxlZCwgcGFyYW1zLmluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlZ1wiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCBPYmplY3QuYXNzaWduKHt9LCBHcmFtbWFyUGFyc2VyLlBBUkFNU19ERVRBSUxFRF9PVkVSUklERUhFSUdIVCwgeyBudW1JbkJpdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IE1hdGgubWF4KG51bU91dHB1dHMsIGlucHV0cy5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrOiAobikgPT4gbiA+PSAwXG4gICAgICAgICAgICAgICAgICAgIH0sIG1pcnJvckNvbm5lY3RvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlYWRPbmx5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LCBpbml0SGV4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsUmVnaXN0ZXJfMS5HcmFwaGljYWxSZWdpc3RlcihlbGVtZW50Lm5hbWUsIHBhcmFtcy5udW1JbkJpdHMsIHBhcmFtcy5kZXRhaWxlZCwgcGFyYW1zLm92ZXJyaWRlSGVpZ2h0ID49IDAgPyBwYXJhbXMub3ZlcnJpZGVIZWlnaHQgOiB1bmRlZmluZWQsIHBhcmFtcy5taXJyb3JDb25uZWN0b3JzLCBwYXJhbXMucmVhZE9ubHksIHBhcmFtcy5pbml0SGV4Lmxlbmd0aCA/IHBhcmFtcy5pbml0SGV4IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtdXhcIjoge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBHcmFtbWFyUGFyc2VyLnBhcnNlUGFyYW1ldGVycyhlbGVtZW50Lm5hbWUsIHR5cGUsIGVsZW1lbnQucGFyYW1ldGVycywgT2JqZWN0LmFzc2lnbih7fSwgR3JhbW1hclBhcnNlci5QQVJBTVNfREVUQUlMRURfT1ZFUlJJREVIRUlHSFQsIHsgbnVtSW5DaGFubmVsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogTWF0aC5jZWlsKGlucHV0cy5sZW5ndGggLyAobnVtT3V0cHV0cyArIDEpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrOiAobikgPT4gbiA+IDBcbiAgICAgICAgICAgICAgICAgICAgfSwgbnVtT3V0Qml0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogbnVtT3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrOiAobikgPT4gbiA+IDBcbiAgICAgICAgICAgICAgICAgICAgfSwgd2lyZURpc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC0xXG4gICAgICAgICAgICAgICAgICAgIH0sIG1pcnJvckNvbm5lY3RvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsTXVsdGlwbGV4ZXJfMS5HcmFwaGljYWxNdWx0aXBsZXhlcihlbGVtZW50Lm5hbWUsIHBhcmFtcy5udW1JbkNoYW5uZWxzLCBwYXJhbXMubnVtT3V0Qml0cywgcGFyYW1zLmRldGFpbGVkLCBwYXJhbXMud2lyZURpc3QgPj0gMCA/IHBhcmFtcy53aXJlRGlzdCA6IHVuZGVmaW5lZCwgcGFyYW1zLm92ZXJyaWRlSGVpZ2h0ID49IDAgPyBwYXJhbXMub3ZlcnJpZGVIZWlnaHQgOiB1bmRlZmluZWQsIHBhcmFtcy5taXJyb3JDb25uZWN0b3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJoYVwiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCBPYmplY3QuYXNzaWduKHt9LCBHcmFtbWFyUGFyc2VyLlBBUkFNU19ERVRBSUxFRF9PVkVSUklERUhFSUdIVCwgeyBhZGRpdGlvbmFsQW5kT3V0cHV0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNhbEhhbGZBZGRlcl8xLkdyYXBoaWNhbEhhbGZBZGRlcihlbGVtZW50Lm5hbWUsIHBhcmFtcy5kZXRhaWxlZCwgcGFyYW1zLm92ZXJyaWRlSGVpZ2h0ID49IDAgPyBwYXJhbXMub3ZlcnJpZGVIZWlnaHQgOiB1bmRlZmluZWQsIHBhcmFtcy5hZGRpdGlvbmFsQW5kT3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmYVwiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCBPYmplY3QuYXNzaWduKHt9LCBHcmFtbWFyUGFyc2VyLlBBUkFNU19ERVRBSUxFRF9PVkVSUklERUhFSUdIVCwgeyBhZGRpdGlvbmFsQW5kT3V0cHV0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNhbEZ1bGxBZGRlcl8xLkdyYXBoaWNhbEZ1bGxBZGRlcihlbGVtZW50Lm5hbWUsIHBhcmFtcy5kZXRhaWxlZCwgcGFyYW1zLm92ZXJyaWRlSGVpZ2h0ID49IDAgPyBwYXJhbXMub3ZlcnJpZGVIZWlnaHQgOiB1bmRlZmluZWQsIHBhcmFtcy5hZGRpdGlvbmFsQW5kT3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtaWNybzE2XCI6IHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0gR3JhbW1hclBhcnNlci5wYXJzZVBhcmFtZXRlcnMoZWxlbWVudC5uYW1lLCB0eXBlLCBlbGVtZW50LnBhcmFtZXRlcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uRGVsYXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC0xXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsdURlbGF5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAtMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcnNEZWxheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogLTFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsTWljcm8xNl8xLkdyYXBoaWNhbE1pY3JvMTYoZWxlbWVudC5uYW1lLCBwYXJhbXMuY29kZSwgcGFyYW1zLmluc3RydWN0aW9uRGVsYXkgPj0gMCA/IHBhcmFtcy5pbnN0cnVjdGlvbkRlbGF5IDogdW5kZWZpbmVkLCBwYXJhbXMuYWx1RGVsYXkgPj0gMCA/IHBhcmFtcy5hbHVEZWxheSA6IHVuZGVmaW5lZCwgcGFyYW1zLnJlZ2lzdGVyc0RlbGF5ID49IDAgPyBwYXJhbXMucmVnaXN0ZXJzRGVsYXkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1pY3JvMTZyZWdzXCI6IHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0gR3JhbW1hclBhcnNlci5wYXJzZVBhcmFtZXRlcnMoZWxlbWVudC5uYW1lLCB0eXBlLCBlbGVtZW50LnBhcmFtZXRlcnMsIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNhbE1pY3JvMTZSZWdpc3RlcnNfMS5HcmFwaGljYWxNaWNybzE2UmVnaXN0ZXJzKGVsZW1lbnQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWljcm8xNmFsdVwiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljYWxNaWNybzE2QWx1XzEuR3JhcGhpY2FsTWljcm8xNkFsdShlbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1pY3JvMTZtaWNcIjoge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBHcmFtbWFyUGFyc2VyLnBhcnNlUGFyYW1ldGVycyhlbGVtZW50Lm5hbWUsIHR5cGUsIGVsZW1lbnQucGFyYW1ldGVycywge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsTWljcm8xNk1pY18xLkdyYXBoaWNhbE1pY3JvMTZNaWMoZWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtaWNybzE2c3RvcmVcIjoge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbXMgPSBHcmFtbWFyUGFyc2VyLnBhcnNlUGFyYW1ldGVycyhlbGVtZW50Lm5hbWUsIHR5cGUsIGVsZW1lbnQucGFyYW1ldGVycywge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsTWljcm8xNlN0b3JlXzEuR3JhcGhpY2FsTWljcm8xNlN0b3JlKGVsZW1lbnQubmFtZSwgcGFyYW1zLmNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1pY3JvMTZjbG9ja1wiOiB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEdyYW1tYXJQYXJzZXIucGFyc2VQYXJhbWV0ZXJzKGVsZW1lbnQubmFtZSwgdHlwZSwgZWxlbWVudC5wYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uRGVsYXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC0xXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsdURlbGF5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAtMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcnNEZWxheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogLTFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhpY2FsTWljcm8xNkNsb2NrXzEuR3JhcGhpY2FsTWljcm8xNkNsb2NrKGVsZW1lbnQubmFtZSwgcGFyYW1zLmluc3RydWN0aW9uRGVsYXkgPj0gMCA/IHBhcmFtcy5pbnN0cnVjdGlvbkRlbGF5IDogdW5kZWZpbmVkLCBwYXJhbXMuYWx1RGVsYXkgPj0gMCA/IHBhcmFtcy5hbHVEZWxheSA6IHVuZGVmaW5lZCwgcGFyYW1zLnJlZ2lzdGVyc0RlbGF5ID49IDAgPyBwYXJhbXMucmVnaXN0ZXJzRGVsYXkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1hbnlub3JzXCI6IHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0gR3JhbW1hclBhcnNlci5wYXJzZVBhcmFtZXRlcnMoZWxlbWVudC5uYW1lLCB0eXBlLCBlbGVtZW50LnBhcmFtZXRlcnMsIE9iamVjdC5hc3NpZ24oe30sIEdyYW1tYXJQYXJzZXIuUEFSQU1TX0RFVEFJTEVEX0lOSVQsIHsgbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrOiAobikgPT4gbiA+IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNhbE1hbnlOb3JzXzEuR3JhcGhpY2FsTWFueU5vcnMoZWxlbWVudC5uYW1lLCBwYXJhbXMubiwgcGFyYW1zLmRldGFpbGVkLCBwYXJhbXMuaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5ldmVyRXJyb3JfMS5OZXZlckVycm9yKHR5cGUsIFwiZWxlbWVudCBcIiArIGVsZW1lbnQubmFtZSArIFwiOiB1bmtub3duIHR5cGU6IFwiICsgZWxlbWVudC50eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkdyYW1tYXJQYXJzZXIgPSBHcmFtbWFyUGFyc2VyO1xuKGZ1bmN0aW9uIChHcmFtbWFyUGFyc2VyKSB7XG4gICAgR3JhbW1hclBhcnNlci5ERUZBVUxUX1RPVEFMX0hFSUdIVCA9IDYwMDtcbiAgICBHcmFtbWFyUGFyc2VyLlBBUkFNU19ERVRBSUxFRCA9IHtcbiAgICAgICAgZGV0YWlsZWQ6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyYW1tYXJQYXJzZXIuUEFSQU1TX0lOSVQgPSB7XG4gICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdyYW1tYXJQYXJzZXIuUEFSQU1TX09WRVJSSURFSEVJR0hUID0ge1xuICAgICAgICBvdmVycmlkZUhlaWdodDoge1xuICAgICAgICAgICAgZGVmYXVsdDogLTFcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JhbW1hclBhcnNlci5QQVJBTVNfTUlSUk9SQ09OTkVDVE9SUyA9IHtcbiAgICAgICAgbWlycm9yQ29ubmVjdG9yczoge1xuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JhbW1hclBhcnNlci5QQVJBTVNfREVUQUlMRURfSU5JVCA9IE9iamVjdC5hc3NpZ24oe30sIEdyYW1tYXJQYXJzZXIuUEFSQU1TX0RFVEFJTEVELCBHcmFtbWFyUGFyc2VyLlBBUkFNU19JTklUKTtcbiAgICBHcmFtbWFyUGFyc2VyLlBBUkFNU19ERVRBSUxFRF9PVkVSUklERUhFSUdIVCA9IE9iamVjdC5hc3NpZ24oe30sIEdyYW1tYXJQYXJzZXIuUEFSQU1TX0RFVEFJTEVELCBHcmFtbWFyUGFyc2VyLlBBUkFNU19PVkVSUklERUhFSUdIVCk7XG4gICAgR3JhbW1hclBhcnNlci5QQVJBTVNfREVUQUlMRURfT1ZFUlJJREVIRUlHSFRfTUlSUk9SQ09OTkVDVE9SUyA9IE9iamVjdC5hc3NpZ24oe30sIEdyYW1tYXJQYXJzZXIuUEFSQU1TX0RFVEFJTEVEX09WRVJSSURFSEVJR0hULCBHcmFtbWFyUGFyc2VyLlBBUkFNU19NSVJST1JDT05ORUNUT1JTKTtcbiAgICBHcmFtbWFyUGFyc2VyLlBBUkFNU19JTklUX09WRVJSSURFSEVJR0hUID0gT2JqZWN0LmFzc2lnbih7fSwgR3JhbW1hclBhcnNlci5QQVJBTVNfSU5JVCwgR3JhbW1hclBhcnNlci5QQVJBTVNfT1ZFUlJJREVIRUlHSFQpO1xuICAgIEdyYW1tYXJQYXJzZXIuUEFSQU1TX0lOSVRfT1ZFUlJJREVIRUlHSFRfTUlSUk9SQ09OTkVDVE9SUyA9IE9iamVjdC5hc3NpZ24oe30sIEdyYW1tYXJQYXJzZXIuUEFSQU1TX0lOSVRfT1ZFUlJJREVIRUlHSFQsIEdyYW1tYXJQYXJzZXIuUEFSQU1TX01JUlJPUkNPTk5FQ1RPUlMpO1xufSkoR3JhbW1hclBhcnNlciA9IGV4cG9ydHMuR3JhbW1hclBhcnNlciB8fCAoZXhwb3J0cy5HcmFtbWFyUGFyc2VyID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYW1tYXJQYXJzZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/grammar/GrammarParser.js\n");

/***/ }),

/***/ "./out/js/graphics/CombinedGraphicalElement.js":
/*!*****************************************************!*\
  !*** ./out/js/graphics/CombinedGraphicalElement.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst StubGraphicalElement_1 = __webpack_require__(/*! ./StubGraphicalElement */ \"./out/js/graphics/StubGraphicalElement.js\");\nconst CombinedElement_1 = __webpack_require__(/*! ../CombinedElement */ \"./out/js/CombinedElement.js\");\nclass CombinedGraphicalElement extends StubGraphicalElement_1.StubGraphicalElement {\n    constructor(name, totalHeight, wiringDescriptions) {\n        super(name);\n        this.totalHeight = totalHeight;\n        this.wiringDescriptions = wiringDescriptions;\n        this.elementInfosList = [];\n        this.elementsList = [];\n    }\n    getDefaultHeight() {\n        return this.totalHeight;\n    }\n    scaleCoordinateValue(value, elementHeight) {\n        return value * elementHeight / this.totalHeight;\n    }\n    resolveCoordinatesDescription(wiringDescription, childCoordinates, i, elementsMap, nextValueSubscribers, prevValues, elementHeight) {\n        let newCoordinates;\n        let xSet;\n        let ySet;\n        newCoordinates = {\n            x: 0,\n            y: 0\n        };\n        let coordinatesDescription = wiringDescription.coordinates[i];\n        if (coordinatesDescription.base) {\n            let basedCoordinates = coordinatesDescription;\n            let connectorCoordinates = this.resolveOwnRelativeConnectorCoordinatesReference(basedCoordinates.base, wiringDescription.element, wiringDescription.name);\n            newCoordinates.x -= connectorCoordinates.x;\n            newCoordinates.y -= connectorCoordinates.y;\n            coordinatesDescription = basedCoordinates.coordinates;\n        }\n        if (coordinatesDescription.x !== undefined && coordinatesDescription.y !== undefined) {\n            xSet = this.resolveCoordinateValueDescription(coordinatesDescription.x, wiringDescription, i, newCoordinates, \"x\", elementsMap, nextValueSubscribers, prevValues, elementHeight);\n            ySet = this.resolveCoordinateValueDescription(coordinatesDescription.y, wiringDescription, i, newCoordinates, \"y\", elementsMap, nextValueSubscribers, prevValues, elementHeight);\n        }\n        else {\n            let reference = coordinatesDescription;\n            let connectorCoordinates = this.resolveConnectorCoordinatesReference(reference, elementsMap);\n            newCoordinates.x += connectorCoordinates.x;\n            newCoordinates.y += connectorCoordinates.y;\n            xSet = ySet = true;\n        }\n        childCoordinates[i] = newCoordinates;\n        if (xSet) {\n            this.updateSubscribersAndPrevValues(nextValueSubscribers, prevValues, newCoordinates, \"x\");\n        }\n        if (ySet) {\n            this.updateSubscribersAndPrevValues(nextValueSubscribers, prevValues, newCoordinates, \"y\");\n        }\n    }\n    updateSubscribersAndPrevValues(nextValueSubscribers, prevValues, newCoordinates, coordinate) {\n        let prevValue = newCoordinates[coordinate];\n        prevValues[coordinate] = prevValue;\n        let subscribers = nextValueSubscribers[coordinate];\n        for (let i = subscribers.length - 1; i >= 0; i--) {\n            let subscriber = subscribers[i];\n            subscriber.coordinates[subscriber.coordinate] += prevValue;\n            prevValue = subscriber.coordinates[subscriber.coordinate];\n        }\n        nextValueSubscribers[coordinate] = [];\n    }\n    resolveCoordinateValueDescription(value, wiringDescription, i, newCoordinates, coordinate, elementsMap, nextValueSubscribers, prevValues, elementHeight) {\n        if ((typeof value) === \"number\") {\n            newCoordinates[coordinate] += this.scaleCoordinateValue(value, elementHeight);\n            return true;\n        }\n        else if (value === \"next\") {\n            nextValueSubscribers[coordinate].push({\n                coordinates: newCoordinates,\n                coordinate: coordinate\n            });\n            return false;\n        }\n        else if (value === \"prev\") {\n            let scaledPrevValue = prevValues[coordinate];\n            if (scaledPrevValue === undefined) {\n                throw new Error(this.getName() + \": graphical element \" + wiringDescription.name + \", coordinates index \" + i + \": no previous value yet for \" + coordinate);\n            }\n            if (nextValueSubscribers[coordinate].length) {\n                throw new Error(this.getName() + \": graphical element \" + wiringDescription.name + \", coordinates index \" + i + \": previous \" + coordinate + \" value referenced, but previous value references next\");\n            }\n            newCoordinates[coordinate] += scaledPrevValue;\n            return true;\n        }\n        else if (value.delta !== undefined) {\n            let relativeReference = value;\n            newCoordinates[coordinate] += this.scaleCoordinateValue(relativeReference.delta, elementHeight);\n            return this.resolveCoordinateValueDescription(relativeReference.from, wiringDescription, i, newCoordinates, coordinate, elementsMap, nextValueSubscribers, prevValues, elementHeight);\n        }\n        else if (value.name) {\n            newCoordinates[coordinate] += this.resolveConnectorCoordinatesReference(value, elementsMap)[coordinate];\n            return true;\n        }\n        else {\n            throw new Error(this.getName() + \": graphical element \" + wiringDescription.name + \", coordinates index \" + i + \": unknown coordinate value description for \" + coordinate);\n        }\n    }\n    resolveConnectorCoordinatesReference(reference, elementsMap) {\n        let referencedElement = elementsMap[reference.name];\n        if (!referencedElement) {\n            throw new Error(this.getName() + \": no such wiring description name (yet; remember: no forward references): \" + reference.name);\n        }\n        let relativeCoordinates = this.resolveOwnRelativeConnectorCoordinatesReference(reference, referencedElement, reference.name);\n        return {\n            x: referencedElement.baseCoordinates.x + relativeCoordinates.x,\n            y: referencedElement.baseCoordinates.y + relativeCoordinates.y\n        };\n    }\n    resolveOwnRelativeConnectorCoordinatesReference(reference, referencedElement, wiringDescriptionName) {\n        let connectorCoordinates = referencedElement.connectorCoordinates;\n        if (!connectorCoordinates) {\n            throw new Error(this.getName() + \": wiring description name \" + wiringDescriptionName + \" has no connector coordinates\");\n        }\n        let coordinatesList = connectorCoordinates[reference.connector];\n        if (reference.index >= coordinatesList.length) {\n            throw new Error(this.getName() + \": wiring description name \" + wiringDescriptionName + \" has no connector coordinates index \" + reference.index + \" at connector \" + reference.connector);\n        }\n        return coordinatesList[reference.index];\n    }\n    resolveHeight(wiringDescription) {\n        let height = wiringDescription.height;\n        if (height === \"auto\") {\n            return wiringDescription.element.getDefaultHeight();\n        }\n        else {\n            return height;\n        }\n    }\n    makeConnectorCoordinates(elementHeight) {\n        for (let wiringDescription of this.wiringDescriptions) {\n            wiringDescription.element.prefixName(this.getName() + \"/\");\n            wiringDescription.element.initConnectorCoordinates(this.scaleCoordinateValue(this.resolveHeight(wiringDescription), elementHeight));\n        }\n        let elementsMap = {};\n        this.elementWiringDescriptions = new Array(this.wiringDescriptions.length);\n        for (let i = 0; i < this.wiringDescriptions.length; i++) {\n            let wiringDescription = this.wiringDescriptions[i];\n            let childCoordinates = new Array(wiringDescription.coordinates.length);\n            let prevValues = {\n                x: undefined,\n                y: undefined\n            };\n            let nextValueSubscribers = {\n                x: [],\n                y: []\n            };\n            for (let i = 0; i < childCoordinates.length; i++) {\n                this.resolveCoordinatesDescription(wiringDescription, childCoordinates, i, elementsMap, nextValueSubscribers, prevValues, elementHeight);\n            }\n            if (nextValueSubscribers.x.length) {\n                throw new Error(this.getName() + \": graphical element \" + wiringDescription.name + \": forward x value references left, but no more coordinates\");\n            }\n            if (nextValueSubscribers.y.length) {\n                throw new Error(this.getName() + \": graphical element \" + wiringDescription.name + \": forward y value references left, but no more coordinates\");\n            }\n            let childElementHeight = this.scaleCoordinateValue(this.resolveHeight(wiringDescription), elementHeight);\n            wiringDescription.element.initBaseCoordinates(childElementHeight, childCoordinates);\n            wiringDescription.element.initElement(childElementHeight, childCoordinates);\n            elementsMap[wiringDescription.name] = wiringDescription.element;\n            this.elementInfosList.push({\n                wiringDescription: wiringDescription,\n                elementHeight: childElementHeight,\n                coordinates: childCoordinates\n            });\n            this.elementsList.push(wiringDescription.element);\n            this.elementWiringDescriptions[i] = {\n                name: wiringDescription.name,\n                element: wiringDescription.element.element,\n                inputs: wiringDescription.inputs,\n                externalOutputs: wiringDescription.externalOutputs\n            };\n        }\n        this.combinedElement = new CombinedElement_1.CombinedElement(this.name, this.elementWiringDescriptions);\n        let connectorCoordinates = {\n            input: [],\n            output: []\n        };\n        for (let valueLocationDescription of this.combinedElement.inputReceiverDescriptions) {\n            let inputElement = elementsMap[valueLocationDescription.wiringDescriptionName];\n            let elementConnectorCoordinates = inputElement.connectorCoordinates;\n            if (!elementConnectorCoordinates) {\n                throw new Error(this.getName() + \": element \" + inputElement.getName() + \" reads input, but does not provide connector coordinates\");\n            }\n            let inputCoordinates = elementConnectorCoordinates.input[valueLocationDescription.index];\n            if (!inputCoordinates) {\n                throw new Error(this.getName() + \": element \" + inputElement.getName() + \" reads input, but does not provide connector coordinates for input index \" + valueLocationDescription.index);\n            }\n            connectorCoordinates.input.push({\n                x: inputElement.baseCoordinates.x + inputCoordinates.x,\n                y: inputElement.baseCoordinates.y + inputCoordinates.y\n            });\n        }\n        for (let valueLocationDescription of this.combinedElement.outputSourceDescriptions) {\n            let outputElement = elementsMap[valueLocationDescription.wiringDescriptionName];\n            let elementConnectorCoordinates = outputElement.connectorCoordinates;\n            if (!elementConnectorCoordinates) {\n                throw new Error(this.getName() + \": element \" + outputElement.getName() + \" delivers output, but does not provide connector coordinates\");\n            }\n            let outputCoordinates = elementConnectorCoordinates.output[valueLocationDescription.index];\n            if (!outputCoordinates) {\n                throw new Error(this.getName() + \": element \" + outputElement.getName() + \" delivers output, but does not provide connector coordinates for output index \" + valueLocationDescription.index);\n            }\n            connectorCoordinates.output.push({\n                x: outputElement.baseCoordinates.x + outputCoordinates.x,\n                y: outputElement.baseCoordinates.y + outputCoordinates.y\n            });\n        }\n        return connectorCoordinates;\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeElement(elementHeight, coordinates) {\n        return this.combinedElement;\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        let graphics = new PIXI.Graphics();\n        for (let i = this.elementInfosList.length - 1; i >= 0; i--) {\n            let elementInfo = this.elementInfosList[i];\n            elementInfo.wiringDescription.element.initGraphics(elementInfo.elementHeight, elementInfo.coordinates, dataSource);\n            let childGraphics = elementInfo.wiringDescription.element.graphics;\n            if (!childGraphics) {\n                throw new Error(this.getName() + \": element \" + elementInfo.wiringDescription.name + \" fails to provide graphics\");\n            }\n            childGraphics.x = elementInfo.wiringDescription.element.baseCoordinates.x;\n            childGraphics.y = elementInfo.wiringDescription.element.baseCoordinates.y;\n            graphics.addChild(childGraphics);\n        }\n        return graphics;\n    }\n    redraw(progress) {\n        for (let element of this.elementsList) {\n            element.redraw(progress);\n        }\n    }\n}\nexports.CombinedGraphicalElement = CombinedGraphicalElement;\n//# sourceMappingURL=CombinedGraphicalElement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvQ29tYmluZWRHcmFwaGljYWxFbGVtZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0NvbWJpbmVkR3JhcGhpY2FsRWxlbWVudC5qcz9jOTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3R1YkdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL1N0dWJHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgQ29tYmluZWRFbGVtZW50XzEgPSByZXF1aXJlKFwiLi4vQ29tYmluZWRFbGVtZW50XCIpO1xuY2xhc3MgQ29tYmluZWRHcmFwaGljYWxFbGVtZW50IGV4dGVuZHMgU3R1YkdyYXBoaWNhbEVsZW1lbnRfMS5TdHViR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdG90YWxIZWlnaHQsIHdpcmluZ0Rlc2NyaXB0aW9ucykge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy50b3RhbEhlaWdodCA9IHRvdGFsSGVpZ2h0O1xuICAgICAgICB0aGlzLndpcmluZ0Rlc2NyaXB0aW9ucyA9IHdpcmluZ0Rlc2NyaXB0aW9ucztcbiAgICAgICAgdGhpcy5lbGVtZW50SW5mb3NMaXN0ID0gW107XG4gICAgICAgIHRoaXMuZWxlbWVudHNMaXN0ID0gW107XG4gICAgfVxuICAgIGdldERlZmF1bHRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsSGVpZ2h0O1xuICAgIH1cbiAgICBzY2FsZUNvb3JkaW5hdGVWYWx1ZSh2YWx1ZSwgZWxlbWVudEhlaWdodCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgKiBlbGVtZW50SGVpZ2h0IC8gdGhpcy50b3RhbEhlaWdodDtcbiAgICB9XG4gICAgcmVzb2x2ZUNvb3JkaW5hdGVzRGVzY3JpcHRpb24od2lyaW5nRGVzY3JpcHRpb24sIGNoaWxkQ29vcmRpbmF0ZXMsIGksIGVsZW1lbnRzTWFwLCBuZXh0VmFsdWVTdWJzY3JpYmVycywgcHJldlZhbHVlcywgZWxlbWVudEhlaWdodCkge1xuICAgICAgICBsZXQgbmV3Q29vcmRpbmF0ZXM7XG4gICAgICAgIGxldCB4U2V0O1xuICAgICAgICBsZXQgeVNldDtcbiAgICAgICAgbmV3Q29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY29vcmRpbmF0ZXNEZXNjcmlwdGlvbiA9IHdpcmluZ0Rlc2NyaXB0aW9uLmNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXNEZXNjcmlwdGlvbi5iYXNlKSB7XG4gICAgICAgICAgICBsZXQgYmFzZWRDb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzRGVzY3JpcHRpb247XG4gICAgICAgICAgICBsZXQgY29ubmVjdG9yQ29vcmRpbmF0ZXMgPSB0aGlzLnJlc29sdmVPd25SZWxhdGl2ZUNvbm5lY3RvckNvb3JkaW5hdGVzUmVmZXJlbmNlKGJhc2VkQ29vcmRpbmF0ZXMuYmFzZSwgd2lyaW5nRGVzY3JpcHRpb24uZWxlbWVudCwgd2lyaW5nRGVzY3JpcHRpb24ubmFtZSk7XG4gICAgICAgICAgICBuZXdDb29yZGluYXRlcy54IC09IGNvbm5lY3RvckNvb3JkaW5hdGVzLng7XG4gICAgICAgICAgICBuZXdDb29yZGluYXRlcy55IC09IGNvbm5lY3RvckNvb3JkaW5hdGVzLnk7XG4gICAgICAgICAgICBjb29yZGluYXRlc0Rlc2NyaXB0aW9uID0gYmFzZWRDb29yZGluYXRlcy5jb29yZGluYXRlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29vcmRpbmF0ZXNEZXNjcmlwdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgY29vcmRpbmF0ZXNEZXNjcmlwdGlvbi55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHhTZXQgPSB0aGlzLnJlc29sdmVDb29yZGluYXRlVmFsdWVEZXNjcmlwdGlvbihjb29yZGluYXRlc0Rlc2NyaXB0aW9uLngsIHdpcmluZ0Rlc2NyaXB0aW9uLCBpLCBuZXdDb29yZGluYXRlcywgXCJ4XCIsIGVsZW1lbnRzTWFwLCBuZXh0VmFsdWVTdWJzY3JpYmVycywgcHJldlZhbHVlcywgZWxlbWVudEhlaWdodCk7XG4gICAgICAgICAgICB5U2V0ID0gdGhpcy5yZXNvbHZlQ29vcmRpbmF0ZVZhbHVlRGVzY3JpcHRpb24oY29vcmRpbmF0ZXNEZXNjcmlwdGlvbi55LCB3aXJpbmdEZXNjcmlwdGlvbiwgaSwgbmV3Q29vcmRpbmF0ZXMsIFwieVwiLCBlbGVtZW50c01hcCwgbmV4dFZhbHVlU3Vic2NyaWJlcnMsIHByZXZWYWx1ZXMsIGVsZW1lbnRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZSA9IGNvb3JkaW5hdGVzRGVzY3JpcHRpb247XG4gICAgICAgICAgICBsZXQgY29ubmVjdG9yQ29vcmRpbmF0ZXMgPSB0aGlzLnJlc29sdmVDb25uZWN0b3JDb29yZGluYXRlc1JlZmVyZW5jZShyZWZlcmVuY2UsIGVsZW1lbnRzTWFwKTtcbiAgICAgICAgICAgIG5ld0Nvb3JkaW5hdGVzLnggKz0gY29ubmVjdG9yQ29vcmRpbmF0ZXMueDtcbiAgICAgICAgICAgIG5ld0Nvb3JkaW5hdGVzLnkgKz0gY29ubmVjdG9yQ29vcmRpbmF0ZXMueTtcbiAgICAgICAgICAgIHhTZXQgPSB5U2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZENvb3JkaW5hdGVzW2ldID0gbmV3Q29vcmRpbmF0ZXM7XG4gICAgICAgIGlmICh4U2V0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzQW5kUHJldlZhbHVlcyhuZXh0VmFsdWVTdWJzY3JpYmVycywgcHJldlZhbHVlcywgbmV3Q29vcmRpbmF0ZXMsIFwieFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeVNldCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpYmVyc0FuZFByZXZWYWx1ZXMobmV4dFZhbHVlU3Vic2NyaWJlcnMsIHByZXZWYWx1ZXMsIG5ld0Nvb3JkaW5hdGVzLCBcInlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3Vic2NyaWJlcnNBbmRQcmV2VmFsdWVzKG5leHRWYWx1ZVN1YnNjcmliZXJzLCBwcmV2VmFsdWVzLCBuZXdDb29yZGluYXRlcywgY29vcmRpbmF0ZSkge1xuICAgICAgICBsZXQgcHJldlZhbHVlID0gbmV3Q29vcmRpbmF0ZXNbY29vcmRpbmF0ZV07XG4gICAgICAgIHByZXZWYWx1ZXNbY29vcmRpbmF0ZV0gPSBwcmV2VmFsdWU7XG4gICAgICAgIGxldCBzdWJzY3JpYmVycyA9IG5leHRWYWx1ZVN1YnNjcmliZXJzW2Nvb3JkaW5hdGVdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3Vic2NyaWJlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBzdWJzY3JpYmVyID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvb3JkaW5hdGVzW3N1YnNjcmliZXIuY29vcmRpbmF0ZV0gKz0gcHJldlZhbHVlO1xuICAgICAgICAgICAgcHJldlZhbHVlID0gc3Vic2NyaWJlci5jb29yZGluYXRlc1tzdWJzY3JpYmVyLmNvb3JkaW5hdGVdO1xuICAgICAgICB9XG4gICAgICAgIG5leHRWYWx1ZVN1YnNjcmliZXJzW2Nvb3JkaW5hdGVdID0gW107XG4gICAgfVxuICAgIHJlc29sdmVDb29yZGluYXRlVmFsdWVEZXNjcmlwdGlvbih2YWx1ZSwgd2lyaW5nRGVzY3JpcHRpb24sIGksIG5ld0Nvb3JkaW5hdGVzLCBjb29yZGluYXRlLCBlbGVtZW50c01hcCwgbmV4dFZhbHVlU3Vic2NyaWJlcnMsIHByZXZWYWx1ZXMsIGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgdmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuZXdDb29yZGluYXRlc1tjb29yZGluYXRlXSArPSB0aGlzLnNjYWxlQ29vcmRpbmF0ZVZhbHVlKHZhbHVlLCBlbGVtZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgbmV4dFZhbHVlU3Vic2NyaWJlcnNbY29vcmRpbmF0ZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IG5ld0Nvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGU6IGNvb3JkaW5hdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcInByZXZcIikge1xuICAgICAgICAgICAgbGV0IHNjYWxlZFByZXZWYWx1ZSA9IHByZXZWYWx1ZXNbY29vcmRpbmF0ZV07XG4gICAgICAgICAgICBpZiAoc2NhbGVkUHJldlZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXROYW1lKCkgKyBcIjogZ3JhcGhpY2FsIGVsZW1lbnQgXCIgKyB3aXJpbmdEZXNjcmlwdGlvbi5uYW1lICsgXCIsIGNvb3JkaW5hdGVzIGluZGV4IFwiICsgaSArIFwiOiBubyBwcmV2aW91cyB2YWx1ZSB5ZXQgZm9yIFwiICsgY29vcmRpbmF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFZhbHVlU3Vic2NyaWJlcnNbY29vcmRpbmF0ZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZ2V0TmFtZSgpICsgXCI6IGdyYXBoaWNhbCBlbGVtZW50IFwiICsgd2lyaW5nRGVzY3JpcHRpb24ubmFtZSArIFwiLCBjb29yZGluYXRlcyBpbmRleCBcIiArIGkgKyBcIjogcHJldmlvdXMgXCIgKyBjb29yZGluYXRlICsgXCIgdmFsdWUgcmVmZXJlbmNlZCwgYnV0IHByZXZpb3VzIHZhbHVlIHJlZmVyZW5jZXMgbmV4dFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0Nvb3JkaW5hdGVzW2Nvb3JkaW5hdGVdICs9IHNjYWxlZFByZXZWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLmRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCByZWxhdGl2ZVJlZmVyZW5jZSA9IHZhbHVlO1xuICAgICAgICAgICAgbmV3Q29vcmRpbmF0ZXNbY29vcmRpbmF0ZV0gKz0gdGhpcy5zY2FsZUNvb3JkaW5hdGVWYWx1ZShyZWxhdGl2ZVJlZmVyZW5jZS5kZWx0YSwgZWxlbWVudEhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlQ29vcmRpbmF0ZVZhbHVlRGVzY3JpcHRpb24ocmVsYXRpdmVSZWZlcmVuY2UuZnJvbSwgd2lyaW5nRGVzY3JpcHRpb24sIGksIG5ld0Nvb3JkaW5hdGVzLCBjb29yZGluYXRlLCBlbGVtZW50c01hcCwgbmV4dFZhbHVlU3Vic2NyaWJlcnMsIHByZXZWYWx1ZXMsIGVsZW1lbnRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLm5hbWUpIHtcbiAgICAgICAgICAgIG5ld0Nvb3JkaW5hdGVzW2Nvb3JkaW5hdGVdICs9IHRoaXMucmVzb2x2ZUNvbm5lY3RvckNvb3JkaW5hdGVzUmVmZXJlbmNlKHZhbHVlLCBlbGVtZW50c01hcClbY29vcmRpbmF0ZV07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldE5hbWUoKSArIFwiOiBncmFwaGljYWwgZWxlbWVudCBcIiArIHdpcmluZ0Rlc2NyaXB0aW9uLm5hbWUgKyBcIiwgY29vcmRpbmF0ZXMgaW5kZXggXCIgKyBpICsgXCI6IHVua25vd24gY29vcmRpbmF0ZSB2YWx1ZSBkZXNjcmlwdGlvbiBmb3IgXCIgKyBjb29yZGluYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlQ29ubmVjdG9yQ29vcmRpbmF0ZXNSZWZlcmVuY2UocmVmZXJlbmNlLCBlbGVtZW50c01hcCkge1xuICAgICAgICBsZXQgcmVmZXJlbmNlZEVsZW1lbnQgPSBlbGVtZW50c01hcFtyZWZlcmVuY2UubmFtZV07XG4gICAgICAgIGlmICghcmVmZXJlbmNlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldE5hbWUoKSArIFwiOiBubyBzdWNoIHdpcmluZyBkZXNjcmlwdGlvbiBuYW1lICh5ZXQ7IHJlbWVtYmVyOiBubyBmb3J3YXJkIHJlZmVyZW5jZXMpOiBcIiArIHJlZmVyZW5jZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVsYXRpdmVDb29yZGluYXRlcyA9IHRoaXMucmVzb2x2ZU93blJlbGF0aXZlQ29ubmVjdG9yQ29vcmRpbmF0ZXNSZWZlcmVuY2UocmVmZXJlbmNlLCByZWZlcmVuY2VkRWxlbWVudCwgcmVmZXJlbmNlLm5hbWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcmVmZXJlbmNlZEVsZW1lbnQuYmFzZUNvb3JkaW5hdGVzLnggKyByZWxhdGl2ZUNvb3JkaW5hdGVzLngsXG4gICAgICAgICAgICB5OiByZWZlcmVuY2VkRWxlbWVudC5iYXNlQ29vcmRpbmF0ZXMueSArIHJlbGF0aXZlQ29vcmRpbmF0ZXMueVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXNvbHZlT3duUmVsYXRpdmVDb25uZWN0b3JDb29yZGluYXRlc1JlZmVyZW5jZShyZWZlcmVuY2UsIHJlZmVyZW5jZWRFbGVtZW50LCB3aXJpbmdEZXNjcmlwdGlvbk5hbWUpIHtcbiAgICAgICAgbGV0IGNvbm5lY3RvckNvb3JkaW5hdGVzID0gcmVmZXJlbmNlZEVsZW1lbnQuY29ubmVjdG9yQ29vcmRpbmF0ZXM7XG4gICAgICAgIGlmICghY29ubmVjdG9yQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldE5hbWUoKSArIFwiOiB3aXJpbmcgZGVzY3JpcHRpb24gbmFtZSBcIiArIHdpcmluZ0Rlc2NyaXB0aW9uTmFtZSArIFwiIGhhcyBubyBjb25uZWN0b3IgY29vcmRpbmF0ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvb3JkaW5hdGVzTGlzdCA9IGNvbm5lY3RvckNvb3JkaW5hdGVzW3JlZmVyZW5jZS5jb25uZWN0b3JdO1xuICAgICAgICBpZiAocmVmZXJlbmNlLmluZGV4ID49IGNvb3JkaW5hdGVzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldE5hbWUoKSArIFwiOiB3aXJpbmcgZGVzY3JpcHRpb24gbmFtZSBcIiArIHdpcmluZ0Rlc2NyaXB0aW9uTmFtZSArIFwiIGhhcyBubyBjb25uZWN0b3IgY29vcmRpbmF0ZXMgaW5kZXggXCIgKyByZWZlcmVuY2UuaW5kZXggKyBcIiBhdCBjb25uZWN0b3IgXCIgKyByZWZlcmVuY2UuY29ubmVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNMaXN0W3JlZmVyZW5jZS5pbmRleF07XG4gICAgfVxuICAgIHJlc29sdmVIZWlnaHQod2lyaW5nRGVzY3JpcHRpb24pIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IHdpcmluZ0Rlc2NyaXB0aW9uLmhlaWdodDtcbiAgICAgICAgaWYgKGhlaWdodCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXJpbmdEZXNjcmlwdGlvbi5lbGVtZW50LmdldERlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgZm9yIChsZXQgd2lyaW5nRGVzY3JpcHRpb24gb2YgdGhpcy53aXJpbmdEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHdpcmluZ0Rlc2NyaXB0aW9uLmVsZW1lbnQucHJlZml4TmFtZSh0aGlzLmdldE5hbWUoKSArIFwiL1wiKTtcbiAgICAgICAgICAgIHdpcmluZ0Rlc2NyaXB0aW9uLmVsZW1lbnQuaW5pdENvbm5lY3RvckNvb3JkaW5hdGVzKHRoaXMuc2NhbGVDb29yZGluYXRlVmFsdWUodGhpcy5yZXNvbHZlSGVpZ2h0KHdpcmluZ0Rlc2NyaXB0aW9uKSwgZWxlbWVudEhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbGVtZW50c01hcCA9IHt9O1xuICAgICAgICB0aGlzLmVsZW1lbnRXaXJpbmdEZXNjcmlwdGlvbnMgPSBuZXcgQXJyYXkodGhpcy53aXJpbmdEZXNjcmlwdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpcmluZ0Rlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHdpcmluZ0Rlc2NyaXB0aW9uID0gdGhpcy53aXJpbmdEZXNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICBsZXQgY2hpbGRDb29yZGluYXRlcyA9IG5ldyBBcnJheSh3aXJpbmdEZXNjcmlwdGlvbi5jb29yZGluYXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IHByZXZWYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHk6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBuZXh0VmFsdWVTdWJzY3JpYmVycyA9IHtcbiAgICAgICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgICAgICB5OiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRDb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvb3JkaW5hdGVzRGVzY3JpcHRpb24od2lyaW5nRGVzY3JpcHRpb24sIGNoaWxkQ29vcmRpbmF0ZXMsIGksIGVsZW1lbnRzTWFwLCBuZXh0VmFsdWVTdWJzY3JpYmVycywgcHJldlZhbHVlcywgZWxlbWVudEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFZhbHVlU3Vic2NyaWJlcnMueC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXROYW1lKCkgKyBcIjogZ3JhcGhpY2FsIGVsZW1lbnQgXCIgKyB3aXJpbmdEZXNjcmlwdGlvbi5uYW1lICsgXCI6IGZvcndhcmQgeCB2YWx1ZSByZWZlcmVuY2VzIGxlZnQsIGJ1dCBubyBtb3JlIGNvb3JkaW5hdGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRWYWx1ZVN1YnNjcmliZXJzLnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZ2V0TmFtZSgpICsgXCI6IGdyYXBoaWNhbCBlbGVtZW50IFwiICsgd2lyaW5nRGVzY3JpcHRpb24ubmFtZSArIFwiOiBmb3J3YXJkIHkgdmFsdWUgcmVmZXJlbmNlcyBsZWZ0LCBidXQgbm8gbW9yZSBjb29yZGluYXRlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGlsZEVsZW1lbnRIZWlnaHQgPSB0aGlzLnNjYWxlQ29vcmRpbmF0ZVZhbHVlKHRoaXMucmVzb2x2ZUhlaWdodCh3aXJpbmdEZXNjcmlwdGlvbiksIGVsZW1lbnRIZWlnaHQpO1xuICAgICAgICAgICAgd2lyaW5nRGVzY3JpcHRpb24uZWxlbWVudC5pbml0QmFzZUNvb3JkaW5hdGVzKGNoaWxkRWxlbWVudEhlaWdodCwgY2hpbGRDb29yZGluYXRlcyk7XG4gICAgICAgICAgICB3aXJpbmdEZXNjcmlwdGlvbi5lbGVtZW50LmluaXRFbGVtZW50KGNoaWxkRWxlbWVudEhlaWdodCwgY2hpbGRDb29yZGluYXRlcyk7XG4gICAgICAgICAgICBlbGVtZW50c01hcFt3aXJpbmdEZXNjcmlwdGlvbi5uYW1lXSA9IHdpcmluZ0Rlc2NyaXB0aW9uLmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRJbmZvc0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgd2lyaW5nRGVzY3JpcHRpb246IHdpcmluZ0Rlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRIZWlnaHQ6IGNoaWxkRWxlbWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogY2hpbGRDb29yZGluYXRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzTGlzdC5wdXNoKHdpcmluZ0Rlc2NyaXB0aW9uLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50V2lyaW5nRGVzY3JpcHRpb25zW2ldID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHdpcmluZ0Rlc2NyaXB0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogd2lyaW5nRGVzY3JpcHRpb24uZWxlbWVudC5lbGVtZW50LFxuICAgICAgICAgICAgICAgIGlucHV0czogd2lyaW5nRGVzY3JpcHRpb24uaW5wdXRzLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogd2lyaW5nRGVzY3JpcHRpb24uZXh0ZXJuYWxPdXRwdXRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tYmluZWRFbGVtZW50ID0gbmV3IENvbWJpbmVkRWxlbWVudF8xLkNvbWJpbmVkRWxlbWVudCh0aGlzLm5hbWUsIHRoaXMuZWxlbWVudFdpcmluZ0Rlc2NyaXB0aW9ucyk7XG4gICAgICAgIGxldCBjb25uZWN0b3JDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgIGlucHV0OiBbXSxcbiAgICAgICAgICAgIG91dHB1dDogW11cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgdmFsdWVMb2NhdGlvbkRlc2NyaXB0aW9uIG9mIHRoaXMuY29tYmluZWRFbGVtZW50LmlucHV0UmVjZWl2ZXJEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dEVsZW1lbnQgPSBlbGVtZW50c01hcFt2YWx1ZUxvY2F0aW9uRGVzY3JpcHRpb24ud2lyaW5nRGVzY3JpcHRpb25OYW1lXTtcbiAgICAgICAgICAgIGxldCBlbGVtZW50Q29ubmVjdG9yQ29vcmRpbmF0ZXMgPSBpbnB1dEVsZW1lbnQuY29ubmVjdG9yQ29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRDb25uZWN0b3JDb29yZGluYXRlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmdldE5hbWUoKSArIFwiOiBlbGVtZW50IFwiICsgaW5wdXRFbGVtZW50LmdldE5hbWUoKSArIFwiIHJlYWRzIGlucHV0LCBidXQgZG9lcyBub3QgcHJvdmlkZSBjb25uZWN0b3IgY29vcmRpbmF0ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5wdXRDb29yZGluYXRlcyA9IGVsZW1lbnRDb25uZWN0b3JDb29yZGluYXRlcy5pbnB1dFt2YWx1ZUxvY2F0aW9uRGVzY3JpcHRpb24uaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpbnB1dENvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZ2V0TmFtZSgpICsgXCI6IGVsZW1lbnQgXCIgKyBpbnB1dEVsZW1lbnQuZ2V0TmFtZSgpICsgXCIgcmVhZHMgaW5wdXQsIGJ1dCBkb2VzIG5vdCBwcm92aWRlIGNvbm5lY3RvciBjb29yZGluYXRlcyBmb3IgaW5wdXQgaW5kZXggXCIgKyB2YWx1ZUxvY2F0aW9uRGVzY3JpcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdG9yQ29vcmRpbmF0ZXMuaW5wdXQucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogaW5wdXRFbGVtZW50LmJhc2VDb29yZGluYXRlcy54ICsgaW5wdXRDb29yZGluYXRlcy54LFxuICAgICAgICAgICAgICAgIHk6IGlucHV0RWxlbWVudC5iYXNlQ29vcmRpbmF0ZXMueSArIGlucHV0Q29vcmRpbmF0ZXMueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdmFsdWVMb2NhdGlvbkRlc2NyaXB0aW9uIG9mIHRoaXMuY29tYmluZWRFbGVtZW50Lm91dHB1dFNvdXJjZURlc2NyaXB0aW9ucykge1xuICAgICAgICAgICAgbGV0IG91dHB1dEVsZW1lbnQgPSBlbGVtZW50c01hcFt2YWx1ZUxvY2F0aW9uRGVzY3JpcHRpb24ud2lyaW5nRGVzY3JpcHRpb25OYW1lXTtcbiAgICAgICAgICAgIGxldCBlbGVtZW50Q29ubmVjdG9yQ29vcmRpbmF0ZXMgPSBvdXRwdXRFbGVtZW50LmNvbm5lY3RvckNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50Q29ubmVjdG9yQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXROYW1lKCkgKyBcIjogZWxlbWVudCBcIiArIG91dHB1dEVsZW1lbnQuZ2V0TmFtZSgpICsgXCIgZGVsaXZlcnMgb3V0cHV0LCBidXQgZG9lcyBub3QgcHJvdmlkZSBjb25uZWN0b3IgY29vcmRpbmF0ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3V0cHV0Q29vcmRpbmF0ZXMgPSBlbGVtZW50Q29ubmVjdG9yQ29vcmRpbmF0ZXMub3V0cHV0W3ZhbHVlTG9jYXRpb25EZXNjcmlwdGlvbi5pbmRleF07XG4gICAgICAgICAgICBpZiAoIW91dHB1dENvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZ2V0TmFtZSgpICsgXCI6IGVsZW1lbnQgXCIgKyBvdXRwdXRFbGVtZW50LmdldE5hbWUoKSArIFwiIGRlbGl2ZXJzIG91dHB1dCwgYnV0IGRvZXMgbm90IHByb3ZpZGUgY29ubmVjdG9yIGNvb3JkaW5hdGVzIGZvciBvdXRwdXQgaW5kZXggXCIgKyB2YWx1ZUxvY2F0aW9uRGVzY3JpcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdG9yQ29vcmRpbmF0ZXMub3V0cHV0LnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IG91dHB1dEVsZW1lbnQuYmFzZUNvb3JkaW5hdGVzLnggKyBvdXRwdXRDb29yZGluYXRlcy54LFxuICAgICAgICAgICAgICAgIHk6IG91dHB1dEVsZW1lbnQuYmFzZUNvb3JkaW5hdGVzLnkgKyBvdXRwdXRDb29yZGluYXRlcy55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdG9yQ29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIG1ha2VCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdO1xuICAgIH1cbiAgICBtYWtlRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21iaW5lZEVsZW1lbnQ7XG4gICAgfVxuICAgIG1ha2VHcmFwaGljcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcywgZGF0YVNvdXJjZSkge1xuICAgICAgICBsZXQgZ3JhcGhpY3MgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5lbGVtZW50SW5mb3NMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudEluZm8gPSB0aGlzLmVsZW1lbnRJbmZvc0xpc3RbaV07XG4gICAgICAgICAgICBlbGVtZW50SW5mby53aXJpbmdEZXNjcmlwdGlvbi5lbGVtZW50LmluaXRHcmFwaGljcyhlbGVtZW50SW5mby5lbGVtZW50SGVpZ2h0LCBlbGVtZW50SW5mby5jb29yZGluYXRlcywgZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRHcmFwaGljcyA9IGVsZW1lbnRJbmZvLndpcmluZ0Rlc2NyaXB0aW9uLmVsZW1lbnQuZ3JhcGhpY3M7XG4gICAgICAgICAgICBpZiAoIWNoaWxkR3JhcGhpY3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXROYW1lKCkgKyBcIjogZWxlbWVudCBcIiArIGVsZW1lbnRJbmZvLndpcmluZ0Rlc2NyaXB0aW9uLm5hbWUgKyBcIiBmYWlscyB0byBwcm92aWRlIGdyYXBoaWNzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRHcmFwaGljcy54ID0gZWxlbWVudEluZm8ud2lyaW5nRGVzY3JpcHRpb24uZWxlbWVudC5iYXNlQ29vcmRpbmF0ZXMueDtcbiAgICAgICAgICAgIGNoaWxkR3JhcGhpY3MueSA9IGVsZW1lbnRJbmZvLndpcmluZ0Rlc2NyaXB0aW9uLmVsZW1lbnQuYmFzZUNvb3JkaW5hdGVzLnk7XG4gICAgICAgICAgICBncmFwaGljcy5hZGRDaGlsZChjaGlsZEdyYXBoaWNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhcGhpY3M7XG4gICAgfVxuICAgIHJlZHJhdyhwcm9ncmVzcykge1xuICAgICAgICBmb3IgKGxldCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHNMaXN0KSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlZHJhdyhwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCA9IENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/CombinedGraphicalElement.js\n");

/***/ }),

/***/ "./out/js/graphics/CompactCombinedGraphicalElement.js":
/*!************************************************************!*\
  !*** ./out/js/graphics/CompactCombinedGraphicalElement.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CombinedGraphicalElement_1 = __webpack_require__(/*! ./CombinedGraphicalElement */ \"./out/js/graphics/CombinedGraphicalElement.js\");\nclass CompactCombinedGraphicalElement {\n    constructor(name, totalHeight, detailed) {\n        this.name = name;\n        this.totalHeight = totalHeight;\n        this.detailed = detailed;\n    }\n    getName() {\n        return this.name;\n    }\n    prefixName(prefix) {\n        this.name = prefix + this.name;\n    }\n    initConnectorCoordinates(elementHeight) {\n        let wiringDescriptions = this.makeWiringDescriptions();\n        this.combinedGraphicalElement = new CombinedGraphicalElement_1.CombinedGraphicalElement(this.name, this.totalHeight, wiringDescriptions);\n        this.combinedGraphicalElement.initConnectorCoordinates(elementHeight);\n        this.compactConnectorCoordinates = this.makeConnectorCoordinates(elementHeight);\n        this.connectorCoordinates = this.detailed ? this.combinedGraphicalElement.connectorCoordinates : this.compactConnectorCoordinates;\n    }\n    initBaseCoordinates(elementHeight, coordinates) {\n        this.combinedGraphicalElement.initBaseCoordinates(elementHeight, coordinates);\n        this.compactBaseCoordinates = this.makeBaseCoordinates(elementHeight, coordinates);\n        this.baseCoordinates = this.detailed ? this.combinedGraphicalElement.baseCoordinates : this.compactBaseCoordinates;\n    }\n    initElement(elementHeight, coordinates) {\n        this.combinedGraphicalElement.initElement(elementHeight, coordinates);\n        this.element = this.combinedGraphicalElement.element;\n        this.onElement(elementHeight, coordinates);\n    }\n    initGraphics(elementHeight, coordinates, dataSource) {\n        this.combinedGraphicalElement.initGraphics(elementHeight, coordinates, dataSource);\n        this.compactGraphics = this.makeGraphics(elementHeight, coordinates, dataSource);\n        this.graphics = this.detailed ? this.combinedGraphicalElement.graphics : this.compactGraphics;\n    }\n    redraw(progress) {\n        if (this.detailed) {\n            this.combinedGraphicalElement.redraw(progress);\n        }\n        else {\n            this.doRedraw(progress);\n        }\n    }\n    getDefaultHeight() {\n        return this.detailed ? this.totalHeight : this.makeDefaultHeight();\n    }\n}\nexports.CompactCombinedGraphicalElement = CompactCombinedGraphicalElement;\n//# sourceMappingURL=CompactCombinedGraphicalElement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9Db21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50LmpzPzk2ODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0NvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNsYXNzIENvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHRvdGFsSGVpZ2h0LCBkZXRhaWxlZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnRvdGFsSGVpZ2h0ID0gdG90YWxIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGV0YWlsZWQgPSBkZXRhaWxlZDtcbiAgICB9XG4gICAgZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgcHJlZml4TmFtZShwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJlZml4ICsgdGhpcy5uYW1lO1xuICAgIH1cbiAgICBpbml0Q29ubmVjdG9yQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCkge1xuICAgICAgICBsZXQgd2lyaW5nRGVzY3JpcHRpb25zID0gdGhpcy5tYWtlV2lyaW5nRGVzY3JpcHRpb25zKCk7XG4gICAgICAgIHRoaXMuY29tYmluZWRHcmFwaGljYWxFbGVtZW50ID0gbmV3IENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCh0aGlzLm5hbWUsIHRoaXMudG90YWxIZWlnaHQsIHdpcmluZ0Rlc2NyaXB0aW9ucyk7XG4gICAgICAgIHRoaXMuY29tYmluZWRHcmFwaGljYWxFbGVtZW50LmluaXRDb25uZWN0b3JDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jb21wYWN0Q29ubmVjdG9yQ29vcmRpbmF0ZXMgPSB0aGlzLm1ha2VDb25uZWN0b3JDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jb25uZWN0b3JDb29yZGluYXRlcyA9IHRoaXMuZGV0YWlsZWQgPyB0aGlzLmNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudC5jb25uZWN0b3JDb29yZGluYXRlcyA6IHRoaXMuY29tcGFjdENvbm5lY3RvckNvb3JkaW5hdGVzO1xuICAgIH1cbiAgICBpbml0QmFzZUNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMuY29tYmluZWRHcmFwaGljYWxFbGVtZW50LmluaXRCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpO1xuICAgICAgICB0aGlzLmNvbXBhY3RCYXNlQ29vcmRpbmF0ZXMgPSB0aGlzLm1ha2VCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpO1xuICAgICAgICB0aGlzLmJhc2VDb29yZGluYXRlcyA9IHRoaXMuZGV0YWlsZWQgPyB0aGlzLmNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudC5iYXNlQ29vcmRpbmF0ZXMgOiB0aGlzLmNvbXBhY3RCYXNlQ29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIGluaXRFbGVtZW50KGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMuY29tYmluZWRHcmFwaGljYWxFbGVtZW50LmluaXRFbGVtZW50KGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQuZWxlbWVudDtcbiAgICAgICAgdGhpcy5vbkVsZW1lbnQoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICBpbml0R3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQuaW5pdEdyYXBoaWNzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzLCBkYXRhU291cmNlKTtcbiAgICAgICAgdGhpcy5jb21wYWN0R3JhcGhpY3MgPSB0aGlzLm1ha2VHcmFwaGljcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcywgZGF0YVNvdXJjZSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSB0aGlzLmRldGFpbGVkID8gdGhpcy5jb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQuZ3JhcGhpY3MgOiB0aGlzLmNvbXBhY3RHcmFwaGljcztcbiAgICB9XG4gICAgcmVkcmF3KHByb2dyZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLmRldGFpbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudC5yZWRyYXcocHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kb1JlZHJhdyhwcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVmYXVsdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWlsZWQgPyB0aGlzLnRvdGFsSGVpZ2h0IDogdGhpcy5tYWtlRGVmYXVsdEhlaWdodCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCA9IENvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/CompactCombinedGraphicalElement.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalAnd.js":
/*!*****************************************!*\
  !*** ./out/js/graphics/GraphicalAnd.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nclass GraphicalAnd extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, numInputs, detailed = false, defaultHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT, initialValue = false) {\n        super(name, numInputs * (GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT + GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE), detailed);\n        this.numInputs = numInputs;\n        this.defaultHeight = defaultHeight;\n        this.initialValue = initialValue;\n        let elements = [];\n        const elemDist = GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE;\n        for (let i = 0; i < numInputs; i++) {\n            let y = i * (GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT + GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE);\n            let wireDelta = elemDist + i * GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n            elements.push(`in_nor${i} nor init=${!initialValue} @0:${y} <${i} >n:p~n-${wireDelta}:n~out_nor=${!initialValue}`);\n            if ((i + 1) >= numInputs) {\n                elements.push(`out_nor nor init=${initialValue} @in_nor${i}/o0+${wireDelta + elemDist}:${y} 0>>`);\n            }\n        }\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    makeDefaultHeight() {\n        return this.defaultHeight;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.makeDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, this.numInputs);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.outputValueReader = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(0)());\n        let scale = elementHeight / this.makeDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"&\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    doRedraw(progress) {\n        let value = this.outputValueReader();\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR);\n    }\n}\nexports.GraphicalAnd = GraphicalAnd;\n//# sourceMappingURL=GraphicalAnd.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsQW5kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbEFuZC5qcz85NTBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xID0gcmVxdWlyZShcIi4vQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbE9yXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxPclwiKTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFtbWFyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9HcmFtbWFyUGFyc2VyXCIpO1xuY2xhc3MgR3JhcGhpY2FsQW5kIGV4dGVuZHMgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG51bUlucHV0cywgZGV0YWlsZWQgPSBmYWxzZSwgZGVmYXVsdEhlaWdodCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQsIGluaXRpYWxWYWx1ZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIG51bUlucHV0cyAqIChHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUICsgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFKSwgZGV0YWlsZWQpO1xuICAgICAgICB0aGlzLm51bUlucHV0cyA9IG51bUlucHV0cztcbiAgICAgICAgdGhpcy5kZWZhdWx0SGVpZ2h0ID0gZGVmYXVsdEhlaWdodDtcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIGxldCBlbGVtZW50cyA9IFtdO1xuICAgICAgICBjb25zdCBlbGVtRGlzdCA9IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbnB1dHM7IGkrKykge1xuICAgICAgICAgICAgbGV0IHkgPSBpICogKEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQgKyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UpO1xuICAgICAgICAgICAgbGV0IHdpcmVEZWx0YSA9IGVsZW1EaXN0ICsgaSAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRElTVEFOQ0U7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBpbl9ub3Ike2l9IG5vciBpbml0PSR7IWluaXRpYWxWYWx1ZX0gQDA6JHt5fSA8JHtpfSA+bjpwfm4tJHt3aXJlRGVsdGF9Om5+b3V0X25vcj0keyFpbml0aWFsVmFsdWV9YCk7XG4gICAgICAgICAgICBpZiAoKGkgKyAxKSA+PSBudW1JbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBvdXRfbm9yIG5vciBpbml0PSR7aW5pdGlhbFZhbHVlfSBAaW5fbm9yJHtpfS9vMCske3dpcmVEZWx0YSArIGVsZW1EaXN0fToke3l9IDA+PmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lyaW5nRGVzY3JpcHRpb25zID0gR3JhbW1hclBhcnNlcl8xLkdyYW1tYXJQYXJzZXIucGFyc2UoZWxlbWVudHMpLndpcmluZ0Rlc2NyaXB0aW9ucztcbiAgICB9XG4gICAgbWFrZURlZmF1bHRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRIZWlnaHQ7XG4gICAgfVxuICAgIG1ha2VXaXJpbmdEZXNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmluZ0Rlc2NyaXB0aW9ucztcbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50SGVpZ2h0O1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5tYWtlRGVmYXVsdEhlaWdodCgpO1xuICAgICAgICB0aGlzLndpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0TGluZVdpZHRoKHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VDb25uZWN0b3JDb29yZGluYXRlcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5udW1JbnB1dHMpO1xuICAgIH1cbiAgICBtYWtlQmFzZUNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlc1swXTtcbiAgICB9XG4gICAgb25FbGVtZW50KGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgfVxuICAgIG1ha2VHcmFwaGljcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcywgZGF0YVNvdXJjZSkge1xuICAgICAgICB0aGlzLm91dHB1dFZhbHVlUmVhZGVyID0gZGF0YVNvdXJjZS5nZXRBZGRyZXNzVmFsdWVSZWFkZXIodGhpcy5lbGVtZW50LmdldE91dHB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVyKDApKCkpO1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5tYWtlRGVmYXVsdEhlaWdodCgpO1xuICAgICAgICByZXR1cm4gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5tYWtlR3JhcGhpY3ModGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIFwiJlwiLCBzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgIH1cbiAgICBkb1JlZHJhdyhwcm9ncmVzcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLm91dHB1dFZhbHVlUmVhZGVyKCk7XG4gICAgICAgIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IucmVkcmF3KHRoaXMuZ3JhcGhpY3MsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmxpbmVXaWR0aCwgdmFsdWUgPyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ISUdIX0NPTE9SIDogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuTE9XX0NPTE9SKTtcbiAgICB9XG59XG5leHBvcnRzLkdyYXBoaWNhbEFuZCA9IEdyYXBoaWNhbEFuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbEFuZC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalAnd.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalCircuit.js":
/*!*********************************************!*\
  !*** ./out/js/graphics/GraphicalCircuit.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Circuit_1 = __webpack_require__(/*! ./../Circuit */ \"./out/js/Circuit.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GraphicalNor_1 = __webpack_require__(/*! ./GraphicalNor */ \"./out/js/graphics/GraphicalNor.js\");\nclass GraphicalCircuit {\n    constructor(graphicalElement, disableGraphics = false, stepsPerSecond = 50, delayPerWindowHeight = GraphicalWire_1.GraphicalWire.DEFAULT_DELAY_PER_WINDOW_HEIGHT, echoData = false, cyclesPerStep, additionalNorDelay) {\n        this.graphicalElement = graphicalElement;\n        this.disableGraphics = disableGraphics;\n        this.stepsPerSecond = stepsPerSecond;\n        this.delayPerWindowHeight = delayPerWindowHeight;\n        this.echoData = echoData;\n        this.cyclesPerStep = cyclesPerStep;\n        this.additionalNorDelay = additionalNorDelay;\n    }\n    init(echoFunctions = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let width;\n            let height;\n            try {\n                width = window.innerWidth;\n                height = window.innerHeight;\n            }\n            catch (e) {\n                width = 800;\n                height = 600;\n            }\n            GraphicalWire_1.GraphicalWire.DELAY_PER_PIXEL = this.delayPerWindowHeight / height;\n            if (this.additionalNorDelay !== undefined && this.additionalNorDelay >= 0) {\n                GraphicalNor_1.GraphicalNor.ADDITIONAL_DELAY = this.additionalNorDelay;\n            }\n            let coordinates = [{ x: 0, y: 0 }];\n            this.graphicalElement.initConnectorCoordinates(height);\n            this.graphicalElement.initBaseCoordinates(height, coordinates);\n            this.graphicalElement.initElement(height, coordinates);\n            this.circuit = new Circuit_1.Circuit(this.graphicalElement.element);\n            yield this.circuit.init(echoFunctions);\n            if (!this.disableGraphics) {\n                this.graphicalElement.initGraphics(height, coordinates, this.circuit.dataSource);\n            }\n            if (!this.disableGraphics) {\n                let graphics = this.graphicalElement.graphics;\n                if (!graphics) {\n                    throw new Error(\"graphical element fails to provide graphics\");\n                }\n                this.app = new PIXI.Application({\n                    width: width,\n                    height: height,\n                    antialias: true,\n                    transparent: true\n                });\n                this.app.stage.addChild(graphics);\n                this.graphicalElement.redraw(0);\n                if (this.stepsPerSecond > 0) {\n                    let intervalMsec = 1000 / this.stepsPerSecond;\n                    let msec = -1;\n                    let ticker = this.app.ticker.add(() => {\n                        if (msec < 0) {\n                            msec = 0;\n                            return;\n                        }\n                        msec += ticker.elapsedMS;\n                        while (msec >= intervalMsec) {\n                            msec -= intervalMsec;\n                            if (this.echoData) {\n                                console.log(`data source after step ${this.circuit.dataSource.n}:`);\n                                console.log(\"addresses\", this.circuit.dataSource.addressArray);\n                                console.log(\"data\", this.circuit.dataSource.array);\n                            }\n                            this.circuit.step(this.cyclesPerStep);\n                        }\n                        let progress = msec / intervalMsec;\n                        this.graphicalElement.redraw(progress);\n                    });\n                }\n            }\n        });\n    }\n}\nexports.GraphicalCircuit = GraphicalCircuit;\n//# sourceMappingURL=GraphicalCircuit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsQ2lyY3VpdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxDaXJjdWl0LmpzPzdlZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENpcmN1aXRfMSA9IHJlcXVpcmUoXCIuLy4uL0NpcmN1aXRcIik7XG5jb25zdCBHcmFwaGljYWxXaXJlXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxXaXJlXCIpO1xuY29uc3QgR3JhcGhpY2FsTm9yXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxOb3JcIik7XG5jbGFzcyBHcmFwaGljYWxDaXJjdWl0IHtcbiAgICBjb25zdHJ1Y3RvcihncmFwaGljYWxFbGVtZW50LCBkaXNhYmxlR3JhcGhpY3MgPSBmYWxzZSwgc3RlcHNQZXJTZWNvbmQgPSA1MCwgZGVsYXlQZXJXaW5kb3dIZWlnaHQgPSBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0RFTEFZX1BFUl9XSU5ET1dfSEVJR0hULCBlY2hvRGF0YSA9IGZhbHNlLCBjeWNsZXNQZXJTdGVwLCBhZGRpdGlvbmFsTm9yRGVsYXkpIHtcbiAgICAgICAgdGhpcy5ncmFwaGljYWxFbGVtZW50ID0gZ3JhcGhpY2FsRWxlbWVudDtcbiAgICAgICAgdGhpcy5kaXNhYmxlR3JhcGhpY3MgPSBkaXNhYmxlR3JhcGhpY3M7XG4gICAgICAgIHRoaXMuc3RlcHNQZXJTZWNvbmQgPSBzdGVwc1BlclNlY29uZDtcbiAgICAgICAgdGhpcy5kZWxheVBlcldpbmRvd0hlaWdodCA9IGRlbGF5UGVyV2luZG93SGVpZ2h0O1xuICAgICAgICB0aGlzLmVjaG9EYXRhID0gZWNob0RhdGE7XG4gICAgICAgIHRoaXMuY3ljbGVzUGVyU3RlcCA9IGN5Y2xlc1BlclN0ZXA7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbE5vckRlbGF5ID0gYWRkaXRpb25hbE5vckRlbGF5O1xuICAgIH1cbiAgICBpbml0KGVjaG9GdW5jdGlvbnMgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHdpZHRoO1xuICAgICAgICAgICAgbGV0IGhlaWdodDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gODAwO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IDYwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFTEFZX1BFUl9QSVhFTCA9IHRoaXMuZGVsYXlQZXJXaW5kb3dIZWlnaHQgLyBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRpdGlvbmFsTm9yRGVsYXkgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFkZGl0aW9uYWxOb3JEZWxheSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkFERElUSU9OQUxfREVMQVkgPSB0aGlzLmFkZGl0aW9uYWxOb3JEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb29yZGluYXRlcyA9IFt7IHg6IDAsIHk6IDAgfV07XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNhbEVsZW1lbnQuaW5pdENvbm5lY3RvckNvb3JkaW5hdGVzKGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNhbEVsZW1lbnQuaW5pdEJhc2VDb29yZGluYXRlcyhoZWlnaHQsIGNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY2FsRWxlbWVudC5pbml0RWxlbWVudChoZWlnaHQsIGNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIHRoaXMuY2lyY3VpdCA9IG5ldyBDaXJjdWl0XzEuQ2lyY3VpdCh0aGlzLmdyYXBoaWNhbEVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNpcmN1aXQuaW5pdChlY2hvRnVuY3Rpb25zKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlR3JhcGhpY3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNhbEVsZW1lbnQuaW5pdEdyYXBoaWNzKGhlaWdodCwgY29vcmRpbmF0ZXMsIHRoaXMuY2lyY3VpdC5kYXRhU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlR3JhcGhpY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZ3JhcGhpY3MgPSB0aGlzLmdyYXBoaWNhbEVsZW1lbnQuZ3JhcGhpY3M7XG4gICAgICAgICAgICAgICAgaWYgKCFncmFwaGljcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJncmFwaGljYWwgZWxlbWVudCBmYWlscyB0byBwcm92aWRlIGdyYXBoaWNzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFwcCA9IG5ldyBQSVhJLkFwcGxpY2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKGdyYXBoaWNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNhbEVsZW1lbnQucmVkcmF3KDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0ZXBzUGVyU2Vjb25kID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50ZXJ2YWxNc2VjID0gMTAwMCAvIHRoaXMuc3RlcHNQZXJTZWNvbmQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtc2VjID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aGlzLmFwcC50aWNrZXIuYWRkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2VjIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZWMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZWMgKz0gdGlja2VyLmVsYXBzZWRNUztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChtc2VjID49IGludGVydmFsTXNlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZWMgLT0gaW50ZXJ2YWxNc2VjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVjaG9EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBkYXRhIHNvdXJjZSBhZnRlciBzdGVwICR7dGhpcy5jaXJjdWl0LmRhdGFTb3VyY2Uubn06YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWRkcmVzc2VzXCIsIHRoaXMuY2lyY3VpdC5kYXRhU291cmNlLmFkZHJlc3NBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGF0YVwiLCB0aGlzLmNpcmN1aXQuZGF0YVNvdXJjZS5hcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2lyY3VpdC5zdGVwKHRoaXMuY3ljbGVzUGVyU3RlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSBtc2VjIC8gaW50ZXJ2YWxNc2VjO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljYWxFbGVtZW50LnJlZHJhdyhwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxDaXJjdWl0ID0gR3JhcGhpY2FsQ2lyY3VpdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbENpcmN1aXQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalCircuit.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalDFlipFlop.js":
/*!***********************************************!*\
  !*** ./out/js/graphics/GraphicalDFlipFlop.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalNor_1 = __webpack_require__(/*! ./GraphicalNor */ \"./out/js/graphics/GraphicalNor.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nclass GraphicalDFlipFlop extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, detailed = false, initialValue = false) {\n        super(name, 7 * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT, detailed);\n        this.initialValue = initialValue;\n        const elemDist = GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE;\n        const elemHeight = GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT;\n        const norWidth = GraphicalNor_1.GraphicalNor.DEFAULT_WIDTH;\n        const rNorX = 6 * elemDist + 2 * norWidth;\n        const rNorY = 0;\n        const rNorAfterY = rNorY + elemHeight;\n        const sNorY = rNorAfterY + elemHeight;\n        const e1Nor0Y = sNorY + 2 * elemHeight;\n        const e1Nor0AfterY = e1Nor0Y + elemHeight;\n        const e1Nor1Y = e1Nor0AfterY + elemHeight;\n        let elements = [];\n        elements.push(`r_nor nor init=false @${rNorX}:${rNorY} >p+${elemDist}:p~p:n~r/i0=false`);\n        elements.push(`d_split split @0:r_nor/i0 <0 >r_nor >p:n~d_nor`);\n        elements.push(`d_nor nor @d_split/o0+${elemDist}:d_split/o0+${elemDist} >p+${elemDist}:p~p:n~s_nor/i0`);\n        elements.push(`s_nor nor init=false @r_nor/i0:${sNorY} >p+${elemDist}:p~p:n~s/i1=false`);\n        elements.push(`e_nor nor init=true o0@d_nor/o0:s_nor/i1 <1 >e0_split=true`);\n        elements.push(`e0_split split @e_nor/o0+${elemDist}:e_nor/o0 >e_split=true >p:${e1Nor0AfterY}~n:${e1Nor1Y}~n-${elemDist}:n~e1_nor1=true`);\n        elements.push(`e1_nor0 nor @e_nor/i0:${e1Nor0Y} >p+${2 * elemDist}:p~p:n~e1_nor=true`);\n        elements.push(`e1_nor1 nor @e_nor/i0:${e1Nor1Y} >p+${elemDist}:p~p:${e1Nor1Y}~n:${e1Nor0AfterY}~n-${elemDist}:n~e1_nor0=false`);\n        elements.push(`e1_nor nor i0@e1_nor0/o0+${3 * elemDist}:e1_nor0/o0+${norWidth} >n:p~e1_split=false`);\n        elements.push(`e1_split split @s_nor/i2-${elemDist}:s_nor/i2 >s_nor/i2=false >p:n~r_nor/i2=false`);\n        elements.push(`e_split split @s_nor/i1-${2 * elemDist}:s_nor/i1 >s_nor=true >p:n~r_nor=true`);\n        elements.push(`r nor init=${initialValue} @r_nor/o0+${3 * elemDist}:${rNorY} >r_split=${initialValue}`);\n        elements.push(`s nor init=${!initialValue} @r/i0:${sNorY} >p+${elemDist}:p~p:${sNorY}~n:${rNorAfterY}~n-${elemDist}:n~r/i1=${!initialValue}`);\n        elements.push(`r_split split @r/o0+${elemDist}:r/o0 0>> >p:${rNorAfterY}~n:${sNorY}~n-${elemDist}:n~s/i0=${initialValue}`);\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    makeDefaultHeight() {\n        return GraphicalDFlipFlop.DEFAULT_HEIGHT;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(this.height);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(this.height);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, 2, 2);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.outputValueReader = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(0)());\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"D\");\n    }\n    doRedraw(progress) {\n        let value = this.outputValueReader();\n        this.graphics.clear();\n        this.graphics.lineStyle(this.lineWidth, value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR, 1);\n        this.graphics.drawRect(0, 0, this.width, this.height);\n    }\n}\nexports.GraphicalDFlipFlop = GraphicalDFlipFlop;\n(function (GraphicalDFlipFlop) {\n    GraphicalDFlipFlop.DEFAULT_HEIGHT = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT;\n})(GraphicalDFlipFlop = exports.GraphicalDFlipFlop || (exports.GraphicalDFlipFlop = {}));\n//# sourceMappingURL=GraphicalDFlipFlop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsREZsaXBGbG9wLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbERGbGlwRmxvcC5qcz84MDQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xID0gcmVxdWlyZShcIi4vQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbE5vcl8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsTm9yXCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY29uc3QgR3JhcGhpY2FsV2lyZV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsV2lyZVwiKTtcbmNvbnN0IEdyYW1tYXJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmFtbWFyL0dyYW1tYXJQYXJzZXJcIik7XG5jbGFzcyBHcmFwaGljYWxERmxpcEZsb3AgZXh0ZW5kcyBDb21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XzEuQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGV0YWlsZWQgPSBmYWxzZSwgaW5pdGlhbFZhbHVlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgNyAqIEdyYXBoaWNhbE5vcl8xLkdyYXBoaWNhbE5vci5ERUZBVUxUX0hFSUdIVCwgZGV0YWlsZWQpO1xuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgY29uc3QgZWxlbURpc3QgPSBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0U7XG4gICAgICAgIGNvbnN0IGVsZW1IZWlnaHQgPSBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQ7XG4gICAgICAgIGNvbnN0IG5vcldpZHRoID0gR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfV0lEVEg7XG4gICAgICAgIGNvbnN0IHJOb3JYID0gNiAqIGVsZW1EaXN0ICsgMiAqIG5vcldpZHRoO1xuICAgICAgICBjb25zdCByTm9yWSA9IDA7XG4gICAgICAgIGNvbnN0IHJOb3JBZnRlclkgPSByTm9yWSArIGVsZW1IZWlnaHQ7XG4gICAgICAgIGNvbnN0IHNOb3JZID0gck5vckFmdGVyWSArIGVsZW1IZWlnaHQ7XG4gICAgICAgIGNvbnN0IGUxTm9yMFkgPSBzTm9yWSArIDIgKiBlbGVtSGVpZ2h0O1xuICAgICAgICBjb25zdCBlMU5vcjBBZnRlclkgPSBlMU5vcjBZICsgZWxlbUhlaWdodDtcbiAgICAgICAgY29uc3QgZTFOb3IxWSA9IGUxTm9yMEFmdGVyWSArIGVsZW1IZWlnaHQ7XG4gICAgICAgIGxldCBlbGVtZW50cyA9IFtdO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGByX25vciBub3IgaW5pdD1mYWxzZSBAJHtyTm9yWH06JHtyTm9yWX0gPnArJHtlbGVtRGlzdH06cH5wOm5+ci9pMD1mYWxzZWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBkX3NwbGl0IHNwbGl0IEAwOnJfbm9yL2kwIDwwID5yX25vciA+cDpufmRfbm9yYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGRfbm9yIG5vciBAZF9zcGxpdC9vMCske2VsZW1EaXN0fTpkX3NwbGl0L28wKyR7ZWxlbURpc3R9ID5wKyR7ZWxlbURpc3R9OnB+cDpufnNfbm9yL2kwYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYHNfbm9yIG5vciBpbml0PWZhbHNlIEByX25vci9pMDoke3NOb3JZfSA+cCske2VsZW1EaXN0fTpwfnA6bn5zL2kxPWZhbHNlYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGVfbm9yIG5vciBpbml0PXRydWUgbzBAZF9ub3IvbzA6c19ub3IvaTEgPDEgPmUwX3NwbGl0PXRydWVgKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChgZTBfc3BsaXQgc3BsaXQgQGVfbm9yL28wKyR7ZWxlbURpc3R9OmVfbm9yL28wID5lX3NwbGl0PXRydWUgPnA6JHtlMU5vcjBBZnRlcll9fm46JHtlMU5vcjFZfX5uLSR7ZWxlbURpc3R9Om5+ZTFfbm9yMT10cnVlYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGUxX25vcjAgbm9yIEBlX25vci9pMDoke2UxTm9yMFl9ID5wKyR7MiAqIGVsZW1EaXN0fTpwfnA6bn5lMV9ub3I9dHJ1ZWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBlMV9ub3IxIG5vciBAZV9ub3IvaTA6JHtlMU5vcjFZfSA+cCske2VsZW1EaXN0fTpwfnA6JHtlMU5vcjFZfX5uOiR7ZTFOb3IwQWZ0ZXJZfX5uLSR7ZWxlbURpc3R9Om5+ZTFfbm9yMD1mYWxzZWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBlMV9ub3Igbm9yIGkwQGUxX25vcjAvbzArJHszICogZWxlbURpc3R9OmUxX25vcjAvbzArJHtub3JXaWR0aH0gPm46cH5lMV9zcGxpdD1mYWxzZWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBlMV9zcGxpdCBzcGxpdCBAc19ub3IvaTItJHtlbGVtRGlzdH06c19ub3IvaTIgPnNfbm9yL2kyPWZhbHNlID5wOm5+cl9ub3IvaTI9ZmFsc2VgKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChgZV9zcGxpdCBzcGxpdCBAc19ub3IvaTEtJHsyICogZWxlbURpc3R9OnNfbm9yL2kxID5zX25vcj10cnVlID5wOm5+cl9ub3I9dHJ1ZWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGByIG5vciBpbml0PSR7aW5pdGlhbFZhbHVlfSBAcl9ub3IvbzArJHszICogZWxlbURpc3R9OiR7ck5vcll9ID5yX3NwbGl0PSR7aW5pdGlhbFZhbHVlfWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBzIG5vciBpbml0PSR7IWluaXRpYWxWYWx1ZX0gQHIvaTA6JHtzTm9yWX0gPnArJHtlbGVtRGlzdH06cH5wOiR7c05vcll9fm46JHtyTm9yQWZ0ZXJZfX5uLSR7ZWxlbURpc3R9Om5+ci9pMT0keyFpbml0aWFsVmFsdWV9YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYHJfc3BsaXQgc3BsaXQgQHIvbzArJHtlbGVtRGlzdH06ci9vMCAwPj4gPnA6JHtyTm9yQWZ0ZXJZfX5uOiR7c05vcll9fm4tJHtlbGVtRGlzdH06bn5zL2kwPSR7aW5pdGlhbFZhbHVlfWApO1xuICAgICAgICB0aGlzLndpcmluZ0Rlc2NyaXB0aW9ucyA9IEdyYW1tYXJQYXJzZXJfMS5HcmFtbWFyUGFyc2VyLnBhcnNlKGVsZW1lbnRzKS53aXJpbmdEZXNjcmlwdGlvbnM7XG4gICAgfVxuICAgIG1ha2VEZWZhdWx0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gR3JhcGhpY2FsREZsaXBGbG9wLkRFRkFVTFRfSEVJR0hUO1xuICAgIH1cbiAgICBtYWtlV2lyaW5nRGVzY3JpcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJpbmdEZXNjcmlwdGlvbnM7XG4gICAgfVxuICAgIG1ha2VDb25uZWN0b3JDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZWxlbWVudEhlaWdodDtcbiAgICAgICAgdGhpcy53aWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgodGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0TGluZVdpZHRoKHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAyLCAyKTtcbiAgICB9XG4gICAgbWFrZUJhc2VDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF07XG4gICAgfVxuICAgIG9uRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRWYWx1ZVJlYWRlciA9IGRhdGFTb3VyY2UuZ2V0QWRkcmVzc1ZhbHVlUmVhZGVyKHRoaXMuZWxlbWVudC5nZXRPdXRwdXRWYWx1ZUFkZHJlc3NQcm92aWRlcigwKSgpKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUdyYXBoaWNzKHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCBcIkRcIik7XG4gICAgfVxuICAgIGRvUmVkcmF3KHByb2dyZXNzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMub3V0cHV0VmFsdWVSZWFkZXIoKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSh0aGlzLmxpbmVXaWR0aCwgdmFsdWUgPyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ISUdIX0NPTE9SIDogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuTE9XX0NPTE9SLCAxKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxERmxpcEZsb3AgPSBHcmFwaGljYWxERmxpcEZsb3A7XG4oZnVuY3Rpb24gKEdyYXBoaWNhbERGbGlwRmxvcCkge1xuICAgIEdyYXBoaWNhbERGbGlwRmxvcC5ERUZBVUxUX0hFSUdIVCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQ7XG59KShHcmFwaGljYWxERmxpcEZsb3AgPSBleHBvcnRzLkdyYXBoaWNhbERGbGlwRmxvcCB8fCAoZXhwb3J0cy5HcmFwaGljYWxERmxpcEZsb3AgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY2FsREZsaXBGbG9wLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalDFlipFlop.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalDecoder.js":
/*!*********************************************!*\
  !*** ./out/js/graphics/GraphicalDecoder.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GraphicalNor_1 = __webpack_require__(/*! ./GraphicalNor */ \"./out/js/graphics/GraphicalNor.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalDecoder extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, numInBits, detailed = false, mirrorConnectors = false, defaultHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT) {\n        super(name, numInBits * 2 * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT + GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT, detailed);\n        this.numInBits = numInBits;\n        this.mirrorConnectors = mirrorConnectors;\n        this.defaultHeight = defaultHeight;\n        let elements = [];\n        for (let i = 0; i < numInBits; i++) {\n            let y = (numInBits - 1 - i) * 2 * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT;\n            let yNor = y + GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT / 2 + 20;\n            let currentBitNotSetElement = `in${i} split @0:${y} <${i} >p:n~in_nor${i}`;\n            let currentBitSetElement = `in_nor${i} nor i0@20:${yNor}`;\n            for (let n = 0; n < Math.pow(2, numInBits); n++) {\n                let x = (n + 1) * 2 * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT + i * 2 * GraphicalWire_1.GraphicalWire.DEFAULT_HEIGHT;\n                let bitNotSet = !((n >> i) & 1);\n                if (bitNotSet) {\n                    if ((n + 1) >= Math.pow(2, numInBits)) {\n                        currentBitNotSetElement += ` >${x}:p~p:n~out_nor${n}`;\n                    }\n                    else {\n                        currentBitNotSetElement += ` >connector_split${i}_${n}`;\n                        elements.push(currentBitNotSetElement);\n                        currentBitNotSetElement = `connector_split${i}_${n} split @${x}:${y} >p:n~out_nor${n}`;\n                    }\n                }\n                else {\n                    if ((n + 1) >= Math.pow(2, numInBits)) {\n                        currentBitSetElement += ` >${x}:p~p:n~out_nor${n}`;\n                    }\n                    else {\n                        currentBitSetElement += ` >connector_split${i}_${n}`;\n                        elements.push(currentBitSetElement);\n                        currentBitSetElement = `connector_split${i}_${n} split @${x}:${yNor} >p:n~out_nor${n}`;\n                    }\n                }\n            }\n            elements.push(currentBitNotSetElement);\n            elements.push(currentBitSetElement);\n        }\n        for (let n = Math.pow(2, numInBits) - 1; n >= 0; n--) {\n            let x = (n + 1) * 2 * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT + numInBits * 2 * GraphicalWire_1.GraphicalWire.DEFAULT_HEIGHT;\n            let y = numInBits * 2 * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT;\n            elements.push(`out_nor${n} nor @${x}:${y} 0>>`);\n        }\n        elements.reverse();\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    makeDefaultHeight() {\n        return this.defaultHeight;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.makeDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, this.numInBits, Math.pow(2, this.numInBits), this.mirrorConnectors);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeGraphics(elementHeight, coordinates) {\n        let scale = elementHeight / this.makeDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"DC\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    doRedraw(progress) {\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, GraphicalDecoder.COMPACT_COLOR);\n    }\n}\nexports.GraphicalDecoder = GraphicalDecoder;\n(function (GraphicalDecoder) {\n    GraphicalDecoder.COMPACT_COLOR = 0x000000;\n})(GraphicalDecoder = exports.GraphicalDecoder || (exports.GraphicalDecoder = {}));\n//# sourceMappingURL=GraphicalDecoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsRGVjb2Rlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxEZWNvZGVyLmpzPzI3YjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBHcmFwaGljYWxOb3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE5vclwiKTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFtbWFyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9HcmFtbWFyUGFyc2VyXCIpO1xuY29uc3QgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xID0gcmVxdWlyZShcIi4vQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbE9yXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxPclwiKTtcbmNsYXNzIEdyYXBoaWNhbERlY29kZXIgZXh0ZW5kcyBDb21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XzEuQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgbnVtSW5CaXRzLCBkZXRhaWxlZCA9IGZhbHNlLCBtaXJyb3JDb25uZWN0b3JzID0gZmFsc2UsIGRlZmF1bHRIZWlnaHQgPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIG51bUluQml0cyAqIDIgKiBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQgKyBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQsIGRldGFpbGVkKTtcbiAgICAgICAgdGhpcy5udW1JbkJpdHMgPSBudW1JbkJpdHM7XG4gICAgICAgIHRoaXMubWlycm9yQ29ubmVjdG9ycyA9IG1pcnJvckNvbm5lY3RvcnM7XG4gICAgICAgIHRoaXMuZGVmYXVsdEhlaWdodCA9IGRlZmF1bHRIZWlnaHQ7XG4gICAgICAgIGxldCBlbGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluQml0czsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeSA9IChudW1JbkJpdHMgLSAxIC0gaSkgKiAyICogR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUO1xuICAgICAgICAgICAgbGV0IHlOb3IgPSB5ICsgR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUIC8gMiArIDIwO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRCaXROb3RTZXRFbGVtZW50ID0gYGluJHtpfSBzcGxpdCBAMDoke3l9IDwke2l9ID5wOm5+aW5fbm9yJHtpfWA7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJpdFNldEVsZW1lbnQgPSBgaW5fbm9yJHtpfSBub3IgaTBAMjA6JHt5Tm9yfWA7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IE1hdGgucG93KDIsIG51bUluQml0cyk7IG4rKykge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gKG4gKyAxKSAqIDIgKiBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQgKyBpICogMiAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfSEVJR0hUO1xuICAgICAgICAgICAgICAgIGxldCBiaXROb3RTZXQgPSAhKChuID4+IGkpICYgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGJpdE5vdFNldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKG4gKyAxKSA+PSBNYXRoLnBvdygyLCBudW1JbkJpdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qml0Tm90U2V0RWxlbWVudCArPSBgID4ke3h9OnB+cDpufm91dF9ub3Ike259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXROb3RTZXRFbGVtZW50ICs9IGAgPmNvbm5lY3Rvcl9zcGxpdCR7aX1fJHtufWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGN1cnJlbnRCaXROb3RTZXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXROb3RTZXRFbGVtZW50ID0gYGNvbm5lY3Rvcl9zcGxpdCR7aX1fJHtufSBzcGxpdCBAJHt4fToke3l9ID5wOm5+b3V0X25vciR7bn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKG4gKyAxKSA+PSBNYXRoLnBvdygyLCBudW1JbkJpdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qml0U2V0RWxlbWVudCArPSBgID4ke3h9OnB+cDpufm91dF9ub3Ike259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXRTZXRFbGVtZW50ICs9IGAgPmNvbm5lY3Rvcl9zcGxpdCR7aX1fJHtufWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGN1cnJlbnRCaXRTZXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCaXRTZXRFbGVtZW50ID0gYGNvbm5lY3Rvcl9zcGxpdCR7aX1fJHtufSBzcGxpdCBAJHt4fToke3lOb3J9ID5wOm5+b3V0X25vciR7bn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHMucHVzaChjdXJyZW50Qml0Tm90U2V0RWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGN1cnJlbnRCaXRTZXRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuID0gTWF0aC5wb3coMiwgbnVtSW5CaXRzKSAtIDE7IG4gPj0gMDsgbi0tKSB7XG4gICAgICAgICAgICBsZXQgeCA9IChuICsgMSkgKiAyICogR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUICsgbnVtSW5CaXRzICogMiAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfSEVJR0hUO1xuICAgICAgICAgICAgbGV0IHkgPSBudW1JbkJpdHMgKiAyICogR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChgb3V0X25vciR7bn0gbm9yIEAke3h9OiR7eX0gMD4+YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMucmV2ZXJzZSgpO1xuICAgICAgICB0aGlzLndpcmluZ0Rlc2NyaXB0aW9ucyA9IEdyYW1tYXJQYXJzZXJfMS5HcmFtbWFyUGFyc2VyLnBhcnNlKGVsZW1lbnRzKS53aXJpbmdEZXNjcmlwdGlvbnM7XG4gICAgfVxuICAgIG1ha2VEZWZhdWx0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0SGVpZ2h0O1xuICAgIH1cbiAgICBtYWtlV2lyaW5nRGVzY3JpcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJpbmdEZXNjcmlwdGlvbnM7XG4gICAgfVxuICAgIG1ha2VDb25uZWN0b3JDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZWxlbWVudEhlaWdodDtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMubWFrZURlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgoc2NhbGUgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKTtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldExpbmVXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICByZXR1cm4gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5tYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMubnVtSW5CaXRzLCBNYXRoLnBvdygyLCB0aGlzLm51bUluQml0cyksIHRoaXMubWlycm9yQ29ubmVjdG9ycyk7XG4gICAgfVxuICAgIG1ha2VCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdO1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMubWFrZURlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUdyYXBoaWNzKHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCBcIkRDXCIsIHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgfVxuICAgIG9uRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgIH1cbiAgICBkb1JlZHJhdyhwcm9ncmVzcykge1xuICAgICAgICBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLnJlZHJhdyh0aGlzLmdyYXBoaWNzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5saW5lV2lkdGgsIEdyYXBoaWNhbERlY29kZXIuQ09NUEFDVF9DT0xPUik7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxEZWNvZGVyID0gR3JhcGhpY2FsRGVjb2RlcjtcbihmdW5jdGlvbiAoR3JhcGhpY2FsRGVjb2Rlcikge1xuICAgIEdyYXBoaWNhbERlY29kZXIuQ09NUEFDVF9DT0xPUiA9IDB4MDAwMDAwO1xufSkoR3JhcGhpY2FsRGVjb2RlciA9IGV4cG9ydHMuR3JhcGhpY2FsRGVjb2RlciB8fCAoZXhwb3J0cy5HcmFwaGljYWxEZWNvZGVyID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbERlY29kZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalDecoder.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalFullAdder.js":
/*!***********************************************!*\
  !*** ./out/js/graphics/GraphicalFullAdder.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalFullAdder extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, detailed = false, defaultElementHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT, additionalAndOutput = false) {\n        super(name, 2 * (2 * defaultElementHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE) + defaultElementHeight + 4 * GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE + GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE, detailed);\n        this.defaultElementHeight = defaultElementHeight;\n        let elements = [];\n        const wireDist = GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const elemX = 3 * wireDist;\n        const orY = 2 * defaultElementHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE + 2 * GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE + GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const lHaY = orY + defaultElementHeight + 2 * GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const aboveOrWiresY = orY - GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE - GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const belowOrWireY = lHaY - GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        elements.push(`or or overrideHeight=${defaultElementHeight} @${elemX}:${orY} 0>>`);\n        elements.push(`upper_ha ha detailed=true overrideHeight=${defaultElementHeight}${additionalAndOutput ? \" additionalAndOutput=true\" : \"\"} @0:0 <0+1\n${additionalAndOutput ? `1>> 0>` : `0>p+${3 * wireDist}:p~`}p:${aboveOrWiresY + wireDist}~${elemX - 2 * wireDist}:p~p:n~or/i0\n>p+${2 * wireDist}:p~p:${aboveOrWiresY}~${elemX - 3 * wireDist}:p~p:n~lower_ha/i0`);\n        elements.push(`lower_ha ha detailed=true overrideHeight=${defaultElementHeight} @0:${lHaY} 1<2 1>> >p+${2 * wireDist}:p~p:${belowOrWireY}~${elemX - 2 * wireDist}:p~p:n~or/i1`);\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    makeDefaultHeight() {\n        return this.defaultElementHeight;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.makeDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, 3, 2);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeGraphics(elementHeight, coordinates) {\n        let scale = elementHeight / this.makeDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"FA\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    doRedraw(progress) {\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, GraphicalDecoder.COMPACT_COLOR);\n    }\n}\nexports.GraphicalFullAdder = GraphicalFullAdder;\nvar GraphicalDecoder;\n(function (GraphicalDecoder) {\n    GraphicalDecoder.COMPACT_COLOR = 0x000000;\n})(GraphicalDecoder = exports.GraphicalDecoder || (exports.GraphicalDecoder = {}));\n//# sourceMappingURL=GraphicalFullAdder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsRnVsbEFkZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbEZ1bGxBZGRlci5qcz8xNGFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgR3JhcGhpY2FsV2lyZV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsV2lyZVwiKTtcbmNvbnN0IEdyYW1tYXJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmFtbWFyL0dyYW1tYXJQYXJzZXJcIik7XG5jb25zdCBDb21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XzEgPSByZXF1aXJlKFwiLi9Db21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsRnVsbEFkZGVyIGV4dGVuZHMgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRldGFpbGVkID0gZmFsc2UsIGRlZmF1bHRFbGVtZW50SGVpZ2h0ID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCwgYWRkaXRpb25hbEFuZE91dHB1dCA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIDIgKiAoMiAqIGRlZmF1bHRFbGVtZW50SGVpZ2h0ICsgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0UpICsgZGVmYXVsdEVsZW1lbnRIZWlnaHQgKyA0ICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0UgKyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0RJU1RBTkNFLCBkZXRhaWxlZCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVsZW1lbnRIZWlnaHQgPSBkZWZhdWx0RWxlbWVudEhlaWdodDtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGNvbnN0IHdpcmVEaXN0ID0gR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9ESVNUQU5DRTtcbiAgICAgICAgY29uc3QgZWxlbVggPSAzICogd2lyZURpc3Q7XG4gICAgICAgIGNvbnN0IG9yWSA9IDIgKiBkZWZhdWx0RWxlbWVudEhlaWdodCArIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFICsgMiAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFICsgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9ESVNUQU5DRTtcbiAgICAgICAgY29uc3QgbEhhWSA9IG9yWSArIGRlZmF1bHRFbGVtZW50SGVpZ2h0ICsgMiAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFO1xuICAgICAgICBjb25zdCBhYm92ZU9yV2lyZXNZID0gb3JZIC0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0UgLSBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0RJU1RBTkNFO1xuICAgICAgICBjb25zdCBiZWxvd09yV2lyZVkgPSBsSGFZIC0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0U7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYG9yIG9yIG92ZXJyaWRlSGVpZ2h0PSR7ZGVmYXVsdEVsZW1lbnRIZWlnaHR9IEAke2VsZW1YfToke29yWX0gMD4+YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYHVwcGVyX2hhIGhhIGRldGFpbGVkPXRydWUgb3ZlcnJpZGVIZWlnaHQ9JHtkZWZhdWx0RWxlbWVudEhlaWdodH0ke2FkZGl0aW9uYWxBbmRPdXRwdXQgPyBcIiBhZGRpdGlvbmFsQW5kT3V0cHV0PXRydWVcIiA6IFwiXCJ9IEAwOjAgPDArMVxuJHthZGRpdGlvbmFsQW5kT3V0cHV0ID8gYDE+PiAwPmAgOiBgMD5wKyR7MyAqIHdpcmVEaXN0fTpwfmB9cDoke2Fib3ZlT3JXaXJlc1kgKyB3aXJlRGlzdH1+JHtlbGVtWCAtIDIgKiB3aXJlRGlzdH06cH5wOm5+b3IvaTBcbj5wKyR7MiAqIHdpcmVEaXN0fTpwfnA6JHthYm92ZU9yV2lyZXNZfX4ke2VsZW1YIC0gMyAqIHdpcmVEaXN0fTpwfnA6bn5sb3dlcl9oYS9pMGApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBsb3dlcl9oYSBoYSBkZXRhaWxlZD10cnVlIG92ZXJyaWRlSGVpZ2h0PSR7ZGVmYXVsdEVsZW1lbnRIZWlnaHR9IEAwOiR7bEhhWX0gMTwyIDE+PiA+cCskezIgKiB3aXJlRGlzdH06cH5wOiR7YmVsb3dPcldpcmVZfX4ke2VsZW1YIC0gMiAqIHdpcmVEaXN0fTpwfnA6bn5vci9pMWApO1xuICAgICAgICB0aGlzLndpcmluZ0Rlc2NyaXB0aW9ucyA9IEdyYW1tYXJQYXJzZXJfMS5HcmFtbWFyUGFyc2VyLnBhcnNlKGVsZW1lbnRzKS53aXJpbmdEZXNjcmlwdGlvbnM7XG4gICAgfVxuICAgIG1ha2VEZWZhdWx0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RWxlbWVudEhlaWdodDtcbiAgICB9XG4gICAgbWFrZVdpcmluZ0Rlc2NyaXB0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyaW5nRGVzY3JpcHRpb25zO1xuICAgIH1cbiAgICBtYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIGxldCBzY2FsZSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLm1ha2VEZWZhdWx0SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMud2lkdGggPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldFdpZHRoKHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRMaW5lV2lkdGgoc2NhbGUgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAzLCAyKTtcbiAgICB9XG4gICAgbWFrZUJhc2VDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF07XG4gICAgfVxuICAgIG1ha2VHcmFwaGljcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5tYWtlRGVmYXVsdEhlaWdodCgpO1xuICAgICAgICByZXR1cm4gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5tYWtlR3JhcGhpY3ModGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIFwiRkFcIiwgc2NhbGUgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKTtcbiAgICB9XG4gICAgb25FbGVtZW50KGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgfVxuICAgIGRvUmVkcmF3KHByb2dyZXNzKSB7XG4gICAgICAgIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IucmVkcmF3KHRoaXMuZ3JhcGhpY3MsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmxpbmVXaWR0aCwgR3JhcGhpY2FsRGVjb2Rlci5DT01QQUNUX0NPTE9SKTtcbiAgICB9XG59XG5leHBvcnRzLkdyYXBoaWNhbEZ1bGxBZGRlciA9IEdyYXBoaWNhbEZ1bGxBZGRlcjtcbnZhciBHcmFwaGljYWxEZWNvZGVyO1xuKGZ1bmN0aW9uIChHcmFwaGljYWxEZWNvZGVyKSB7XG4gICAgR3JhcGhpY2FsRGVjb2Rlci5DT01QQUNUX0NPTE9SID0gMHgwMDAwMDA7XG59KShHcmFwaGljYWxEZWNvZGVyID0gZXhwb3J0cy5HcmFwaGljYWxEZWNvZGVyIHx8IChleHBvcnRzLkdyYXBoaWNhbERlY29kZXIgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY2FsRnVsbEFkZGVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalFullAdder.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalHalfAdder.js":
/*!***********************************************!*\
  !*** ./out/js/graphics/GraphicalHalfAdder.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalHalfAdder extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, detailed = false, defaultElementHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT, additionalAndOutput = false) {\n        super(name, 2 * defaultElementHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE, detailed);\n        this.defaultElementHeight = defaultElementHeight;\n        let elements = [];\n        const wireDist = GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const elemX = 3 * wireDist;\n        const xorY = defaultElementHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        elements.push(`and and overrideHeight=${defaultElementHeight} @${elemX}:0 ${additionalAndOutput ? \">and_split\" : \"0>>\"}`);\n        if (additionalAndOutput) {\n            elements.push(`and_split split @and/o0+${3 * wireDist}:and/o0 0>> 1>>`);\n        }\n        elements.push(`xor xor overrideHeight=${defaultElementHeight} @${elemX}:${xorY} 0>>`);\n        elements.push(`a_split split @${wireDist}:and/i0 <0 >and >p:n~xor`);\n        elements.push(`b_split split @0:and/i1 <1 >and >p:n~xor`);\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    makeDefaultHeight() {\n        return this.defaultElementHeight;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.makeDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, 2, 2);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeGraphics(elementHeight, coordinates) {\n        let scale = elementHeight / this.makeDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"HA\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    doRedraw(progress) {\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, GraphicalDecoder.COMPACT_COLOR);\n    }\n}\nexports.GraphicalHalfAdder = GraphicalHalfAdder;\nvar GraphicalDecoder;\n(function (GraphicalDecoder) {\n    GraphicalDecoder.COMPACT_COLOR = 0x000000;\n})(GraphicalDecoder = exports.GraphicalDecoder || (exports.GraphicalDecoder = {}));\n//# sourceMappingURL=GraphicalHalfAdder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsSGFsZkFkZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbEhhbGZBZGRlci5qcz80YzhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgR3JhcGhpY2FsV2lyZV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsV2lyZVwiKTtcbmNvbnN0IEdyYW1tYXJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmFtbWFyL0dyYW1tYXJQYXJzZXJcIik7XG5jb25zdCBDb21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XzEgPSByZXF1aXJlKFwiLi9Db21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsSGFsZkFkZGVyIGV4dGVuZHMgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRldGFpbGVkID0gZmFsc2UsIGRlZmF1bHRFbGVtZW50SGVpZ2h0ID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCwgYWRkaXRpb25hbEFuZE91dHB1dCA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIDIgKiBkZWZhdWx0RWxlbWVudEhlaWdodCArIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFLCBkZXRhaWxlZCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVsZW1lbnRIZWlnaHQgPSBkZWZhdWx0RWxlbWVudEhlaWdodDtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGNvbnN0IHdpcmVEaXN0ID0gR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9ESVNUQU5DRTtcbiAgICAgICAgY29uc3QgZWxlbVggPSAzICogd2lyZURpc3Q7XG4gICAgICAgIGNvbnN0IHhvclkgPSBkZWZhdWx0RWxlbWVudEhlaWdodCArIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBhbmQgYW5kIG92ZXJyaWRlSGVpZ2h0PSR7ZGVmYXVsdEVsZW1lbnRIZWlnaHR9IEAke2VsZW1YfTowICR7YWRkaXRpb25hbEFuZE91dHB1dCA/IFwiPmFuZF9zcGxpdFwiIDogXCIwPj5cIn1gKTtcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxBbmRPdXRwdXQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYGFuZF9zcGxpdCBzcGxpdCBAYW5kL28wKyR7MyAqIHdpcmVEaXN0fTphbmQvbzAgMD4+IDE+PmApO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYHhvciB4b3Igb3ZlcnJpZGVIZWlnaHQ9JHtkZWZhdWx0RWxlbWVudEhlaWdodH0gQCR7ZWxlbVh9OiR7eG9yWX0gMD4+YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGFfc3BsaXQgc3BsaXQgQCR7d2lyZURpc3R9OmFuZC9pMCA8MCA+YW5kID5wOm5+eG9yYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGJfc3BsaXQgc3BsaXQgQDA6YW5kL2kxIDwxID5hbmQgPnA6bn54b3JgKTtcbiAgICAgICAgdGhpcy53aXJpbmdEZXNjcmlwdGlvbnMgPSBHcmFtbWFyUGFyc2VyXzEuR3JhbW1hclBhcnNlci5wYXJzZShlbGVtZW50cykud2lyaW5nRGVzY3JpcHRpb25zO1xuICAgIH1cbiAgICBtYWtlRGVmYXVsdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVsZW1lbnRIZWlnaHQ7XG4gICAgfVxuICAgIG1ha2VXaXJpbmdEZXNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmluZ0Rlc2NyaXB0aW9ucztcbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50SGVpZ2h0O1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5tYWtlRGVmYXVsdEhlaWdodCgpO1xuICAgICAgICB0aGlzLndpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0TGluZVdpZHRoKHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VDb25uZWN0b3JDb29yZGluYXRlcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMiwgMik7XG4gICAgfVxuICAgIG1ha2VCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdO1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMubWFrZURlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUdyYXBoaWNzKHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCBcIkhBXCIsIHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgfVxuICAgIG9uRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgIH1cbiAgICBkb1JlZHJhdyhwcm9ncmVzcykge1xuICAgICAgICBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLnJlZHJhdyh0aGlzLmdyYXBoaWNzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5saW5lV2lkdGgsIEdyYXBoaWNhbERlY29kZXIuQ09NUEFDVF9DT0xPUik7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxIYWxmQWRkZXIgPSBHcmFwaGljYWxIYWxmQWRkZXI7XG52YXIgR3JhcGhpY2FsRGVjb2RlcjtcbihmdW5jdGlvbiAoR3JhcGhpY2FsRGVjb2Rlcikge1xuICAgIEdyYXBoaWNhbERlY29kZXIuQ09NUEFDVF9DT0xPUiA9IDB4MDAwMDAwO1xufSkoR3JhcGhpY2FsRGVjb2RlciA9IGV4cG9ydHMuR3JhcGhpY2FsRGVjb2RlciB8fCAoZXhwb3J0cy5HcmFwaGljYWxEZWNvZGVyID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbEhhbGZBZGRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalHalfAdder.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalJKFlipFlop.js":
/*!************************************************!*\
  !*** ./out/js/graphics/GraphicalJKFlipFlop.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalNor_1 = __webpack_require__(/*! ./GraphicalNor */ \"./out/js/graphics/GraphicalNor.js\");\nconst GraphicalManyNors_1 = __webpack_require__(/*! ./GraphicalManyNors */ \"./out/js/graphics/GraphicalManyNors.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GraphicalRSFlipFlop_1 = __webpack_require__(/*! ./GraphicalRSFlipFlop */ \"./out/js/graphics/GraphicalRSFlipFlop.js\");\nconst GraphicalAnd_1 = __webpack_require__(/*! ./GraphicalAnd */ \"./out/js/graphics/GraphicalAnd.js\");\nconst GraphicalSplit_1 = __webpack_require__(/*! ./GraphicalSplit */ \"./out/js/graphics/GraphicalSplit.js\");\nconst GraphicalSinkTerminal_1 = __webpack_require__(/*! ./GraphicalSinkTerminal */ \"./out/js/graphics/GraphicalSinkTerminal.js\");\nclass GraphicalJKFlipFlop extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, detailed = false, initialValue = false) {\n        super(name, 7 * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT, detailed);\n        this.initialValue = initialValue;\n        this.wiringDescriptions = [\n            {\n                name: \"CLK_SPLIT\",\n                element: new GraphicalSplit_1.GraphicalSplit(\"CLK_SPLIT0\", 2, 1),\n                height: \"auto\",\n                inputs: [{ name: \"outside\", outputIndex: 1 }],\n                externalOutputs: [],\n                coordinates: [{\n                        x: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                        y: 3 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT,\n                    }]\n            },\n            {\n                name: \"CLK_NOT\",\n                element: new GraphicalManyNors_1.GraphicalManyNors(\"CLK_NOT0\", 3, initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"CLK_SPLIT_to_CLK_NOT\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [{\n                        x: {\n                            delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                            from: { name: \"CLK_SPLIT\", connector: \"output\", index: 0\n                            },\n                        },\n                        y: 4.5 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT,\n                    }],\n            },\n            {\n                name: \"CLK_AND\",\n                element: new GraphicalAnd_1.GraphicalAnd(\"CLK_AND0\", 2, initialValue),\n                height: \"auto\",\n                inputs: [\n                    { name: \"CLK_SPLIT_to_CLK_AND\", outputIndex: 0 },\n                    { name: \"CLK_NOT_to_CLK_AND\", outputIndex: 0 },\n                ],\n                externalOutputs: [],\n                coordinates: [{\n                        x: {\n                            delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                            from: { name: \"CLK_NOT\", connector: \"output\", index: 0 },\n                        },\n                        y: {\n                            delta: -(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT / 3),\n                            from: { name: \"CLK_SPLIT\", connector: \"output\", index: 0 },\n                        },\n                    }]\n            },\n            {\n                name: \"CLK_OUT\",\n                element: new GraphicalSplit_1.GraphicalSplit(\"CLK_SPLIT1\", 2, 1),\n                height: \"auto\",\n                inputs: [{ name: \"CLK_AND_to_CLK_OUT\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [{\n                        x: {\n                            delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                            from: { name: \"CLK_AND\", connector: \"output\", index: 0 },\n                        },\n                        y: { name: \"CLK_AND\", connector: \"output\", index: 0 },\n                    }],\n            },\n            {\n                name: \"K_AND\",\n                element: new GraphicalAnd_1.GraphicalAnd(\"K_AND0\", 3, initialValue),\n                height: \"auto\",\n                inputs: [\n                    { name: \"Q_to_K_AND\", outputIndex: 0 },\n                    { name: \"outside\", outputIndex: 2 },\n                    { name: \"CLK_OUT_to_K_AND\", outputIndex: 0 },\n                ],\n                externalOutputs: [],\n                coordinates: [{\n                        x: 8 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                        y: GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT,\n                    }]\n            },\n            {\n                name: \"J_AND\",\n                element: new GraphicalAnd_1.GraphicalAnd(\"J_AND0\", 3, initialValue),\n                height: \"auto\",\n                inputs: [\n                    { name: \"CLK_OUT_to_J_AND\", outputIndex: 0 },\n                    { name: \"outside\", outputIndex: 0 },\n                    { name: \"Qn_to_J_AND\", outputIndex: 0 },\n                ],\n                externalOutputs: [],\n                coordinates: [{\n                        x: 8 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                        y: 5 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT,\n                    }]\n            },\n            {\n                name: \"RSFLIPFLOP\",\n                element: new GraphicalRSFlipFlop_1.GraphicalRSFlipFlop(\"RSFLIPFLOP0\", initialValue),\n                height: \"auto\",\n                inputs: [\n                    { name: \"K_AND_to_RSFF\", outputIndex: 0 },\n                    { name: \"J_AND_to_RSFF\", outputIndex: 0 },\n                ],\n                externalOutputs: [0, 1],\n                coordinates: [{\n                        x: 10 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                        y: 2 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT,\n                    }]\n            },\n            {\n                name: \"Q_SINK\",\n                element: new GraphicalSinkTerminal_1.GraphicalSinkTerminal(\"Q_SINK0\"),\n                height: \"auto\",\n                inputs: [\n                    { name: \"RSFF_to_Q_SINK\", outputIndex: 0 },\n                ],\n                externalOutputs: [],\n                coordinates: [{\n                        x: 16 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                        y: 2.5 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT,\n                    }]\n            },\n            {\n                name: \"Qn_SINK\",\n                element: new GraphicalSinkTerminal_1.GraphicalSinkTerminal(\"Qn_SINK0\"),\n                height: \"auto\",\n                inputs: [\n                    { name: \"RSFF_to_Qn_SINK\", outputIndex: 0 },\n                ],\n                externalOutputs: [],\n                coordinates: [{\n                        x: 16 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                        y: 4.5 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT,\n                    }]\n            },\n            {\n                name: \"CLK_SPLIT_to_CLK_NOT\",\n                element: new GraphicalWire_1.GraphicalWire(\"CLK_SPLIT_to_CLK_NOT0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"CLK_SPLIT\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"CLK_SPLIT\", connector: \"output\", index: 0 },\n                    { x: \"prev\", y: \"next\" },\n                    { name: \"CLK_NOT\", connector: \"input\", index: 0 }\n                ]\n            },\n            {\n                name: \"CLK_SPLIT_to_CLK_AND\",\n                element: new GraphicalWire_1.GraphicalWire(\"CLK_SPLIT_to_CLK_AND0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"CLK_SPLIT\", outputIndex: 1 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"CLK_SPLIT\", connector: \"output\", index: 0 },\n                    { name: \"CLK_AND\", connector: \"input\", index: 0 }\n                ]\n            },\n            {\n                name: \"CLK_NOT_to_CLK_AND\",\n                element: new GraphicalWire_1.GraphicalWire(\"CLK_NOT_to_CLK_AND0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"CLK_NOT\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"CLK_NOT\", connector: \"output\", index: 0 },\n                    { x: { delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2, from: \"prev\" }, y: \"prev\" },\n                    { x: \"prev\", y: { delta: -(GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT / 2 + GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2), from: \"prev\" } },\n                    { x: { delta: -(GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2 + GraphicalNor_1.GraphicalNor.DEFAULT_WIDTH), from: \"prev\" }, y: \"prev\" },\n                    { x: \"prev\", y: { delta: -GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 4, from: \"prev\" } },\n                    { x: { delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2 + GraphicalNor_1.GraphicalNor.DEFAULT_WIDTH, from: \"prev\" }, y: \"prev\" },\n                    { x: \"prev\", y: { delta: -GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 4, from: \"prev\" } },\n                    { x: { delta: -(GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2 + GraphicalNor_1.GraphicalNor.DEFAULT_WIDTH), from: \"prev\" }, y: \"prev\" },\n                    { x: \"prev\", y: { delta: -GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 4, from: \"prev\" } },\n                    { x: { delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2 + GraphicalNor_1.GraphicalNor.DEFAULT_WIDTH, from: \"prev\" }, y: \"prev\" },\n                    { x: \"prev\", y: { delta: -GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 4, from: \"prev\" } },\n                    { x: { delta: -(GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2 + GraphicalNor_1.GraphicalNor.DEFAULT_WIDTH), from: \"prev\" }, y: \"prev\" },\n                    { x: \"prev\", y: \"next\" },\n                    { name: \"CLK_AND\", connector: \"input\", index: 1 }\n                ]\n            },\n            {\n                name: \"CLK_AND_to_CLK_OUT\",\n                element: new GraphicalWire_1.GraphicalWire(\"CLK_AND_to_CLK_OUT0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"CLK_AND\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"CLK_AND\", connector: \"output\", index: 0 },\n                    { name: \"CLK_OUT\", connector: \"input\", index: 0 },\n                ]\n            },\n            {\n                name: \"CLK_OUT_to_K_AND\",\n                element: new GraphicalWire_1.GraphicalWire(\"CLK_OUT_to_K_AND0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"CLK_OUT\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"CLK_OUT\", connector: \"output\", index: 0 },\n                    { x: \"prev\", y: \"next\" },\n                    { name: \"K_AND\", connector: \"input\", index: 2 },\n                ]\n            },\n            {\n                name: \"CLK_OUT_to_J_AND\",\n                element: new GraphicalWire_1.GraphicalWire(\"CLK_OUT_to_J_AND0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"CLK_OUT\", outputIndex: 1 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"CLK_OUT\", connector: \"output\", index: 0 },\n                    { x: \"prev\", y: \"next\" },\n                    { name: \"J_AND\", connector: \"input\", index: 0 },\n                ]\n            },\n            {\n                name: \"K_AND_to_RSFF\",\n                element: new GraphicalWire_1.GraphicalWire(\"K_AND_to_RSFF0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"K_AND\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"K_AND\", connector: \"output\", index: 0 },\n                    { x: { delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2, from: \"prev\" }, y: \"prev\" },\n                    { x: { delta: -GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2, from: \"next\" }, y: \"next\" },\n                    { name: \"RSFLIPFLOP\", connector: \"input\", index: 0 },\n                ]\n            },\n            {\n                name: \"J_AND_to_RSFF\",\n                element: new GraphicalWire_1.GraphicalWire(\"J_AND_to_RSFF0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"J_AND\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"J_AND\", connector: \"output\", index: 0 },\n                    { x: { delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2, from: \"prev\" }, y: \"prev\" },\n                    { x: { delta: -GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE / 2, from: \"next\" }, y: \"next\" },\n                    { name: \"RSFLIPFLOP\", connector: \"input\", index: 1 },\n                ]\n            },\n            {\n                name: \"Q_to_K_AND\",\n                element: new GraphicalWire_1.GraphicalWire(\"Q_to_K_AND0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"RSFLIPFLOP\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"RSFLIPFLOP\", connector: \"output\", index: 0 },\n                    { x: \"prev\", y: GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT / 2 },\n                    { x: 7 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE, y: GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT / 2 },\n                    { x: 7 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE, y: \"next\" },\n                    { name: \"K_AND\", connector: \"input\", index: 0 },\n                ]\n            },\n            {\n                name: \"Qn_to_J_AND\",\n                element: new GraphicalWire_1.GraphicalWire(\"Qn_to_J_AND0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"RSFLIPFLOP\", outputIndex: 1 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"RSFLIPFLOP\", connector: \"output\", index: 1 },\n                    { x: \"prev\", y: 6.5 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT },\n                    { x: 7 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE, y: 6.5 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT },\n                    { x: 7 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE, y: \"next\" },\n                    { name: \"J_AND\", connector: \"input\", index: 2 },\n                ]\n            },\n            {\n                name: \"RSFF_to_Q_SINK\",\n                element: new GraphicalWire_1.GraphicalWire(\"RSFF_to_Q_SINK0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"RSFLIPFLOP\", outputIndex: 0 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"RSFLIPFLOP\", connector: \"output\", index: 0 },\n                    { name: \"Q_SINK\", connector: \"input\", index: 0 },\n                ]\n            },\n            {\n                name: \"RSFF_to_Qn_SINK\",\n                element: new GraphicalWire_1.GraphicalWire(\"RSFF_to_Qn_SINK0\", initialValue),\n                height: \"auto\",\n                inputs: [{ name: \"RSFLIPFLOP\", outputIndex: 1 }],\n                externalOutputs: [],\n                coordinates: [\n                    { name: \"RSFLIPFLOP\", connector: \"output\", index: 1 },\n                    { name: \"Qn_SINK\", connector: \"input\", index: 0 },\n                ]\n            },\n        ];\n    }\n    makeDefaultHeight() {\n        return GraphicalJKFlipFlop.DEFAULT_HEIGHT;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(this.height);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(this.height);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, 3, 2);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.outputValueReader = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(0)());\n        let graphics = new PIXI.Graphics();\n        let textSizeReferenceHeight = this.height * 0.6;\n        let textJ = new PIXI.Text(\"J\", {\n            fontSize: textSizeReferenceHeight / 5,\n            fontFamily: \"Arial\",\n            fill: GraphicalOr_1.GraphicalOr.TEXT_COLOR\n        });\n        let textK = new PIXI.Text(\"K\", {\n            fontSize: textSizeReferenceHeight / 5,\n            fontFamily: \"Arial\",\n            fill: GraphicalOr_1.GraphicalOr.TEXT_COLOR\n        });\n        let textCLK = new PIXI.Text(\"CLK\", {\n            fontSize: textSizeReferenceHeight / 5,\n            fontFamily: \"Arial\",\n            fill: GraphicalOr_1.GraphicalOr.TEXT_COLOR\n        });\n        let textQ = new PIXI.Text(\"Q\", {\n            fontSize: textSizeReferenceHeight / 5,\n            fontFamily: \"Arial\",\n            fill: GraphicalOr_1.GraphicalOr.TEXT_COLOR\n        });\n        let textQn = new PIXI.Text(\"Qn\", {\n            fontSize: textSizeReferenceHeight / 5,\n            fontFamily: \"Arial\",\n            fill: GraphicalOr_1.GraphicalOr.TEXT_COLOR\n        });\n        textJ.anchor.set(0, 0.5);\n        textJ.x = 10;\n        textJ.y = this.height / 4;\n        textK.anchor.set(0, 0.5);\n        textK.x = 10;\n        textK.y = 3 * this.height / 4;\n        textCLK.anchor.set(0, 0.5);\n        textCLK.x = 10 + this.width / 6;\n        textCLK.y = this.height / 2;\n        textQ.anchor.set(1, 0.5);\n        textQ.x = this.width - 10;\n        textQ.y = this.height / 4;\n        textQn.anchor.set(1, 0.5);\n        textQn.x = this.width - 10;\n        textQn.y = 3 * this.height / 4;\n        graphics.addChild(textJ);\n        graphics.addChild(textK);\n        graphics.addChild(textCLK);\n        graphics.addChild(textQ);\n        graphics.addChild(textQn);\n        return graphics;\n    }\n    doRedraw(progress) {\n        let value = this.outputValueReader();\n        this.graphics.clear();\n        this.graphics.lineStyle(this.lineWidth / 2, value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR, 1);\n        this.graphics.drawRect(0, 0, this.width, this.height);\n        this.graphics.moveTo(0, this.height / 2 - this.height / 10);\n        this.graphics.lineTo(this.width / 6, this.height / 2);\n        this.graphics.lineTo(0, this.height / 2 + this.height / 10);\n    }\n}\nexports.GraphicalJKFlipFlop = GraphicalJKFlipFlop;\n(function (GraphicalJKFlipFlop) {\n    GraphicalJKFlipFlop.DEFAULT_HEIGHT = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT * 2;\n})(GraphicalJKFlipFlop = exports.GraphicalJKFlipFlop || (exports.GraphicalJKFlipFlop = {}));\n//# sourceMappingURL=GraphicalJKFlipFlop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsSktGbGlwRmxvcC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxKS0ZsaXBGbG9wLmpzP2RmZWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XzEgPSByZXF1aXJlKFwiLi9Db21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsTm9yXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxOb3JcIik7XG5jb25zdCBHcmFwaGljYWxNYW55Tm9yc18xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsTWFueU5vcnNcIik7XG5jb25zdCBHcmFwaGljYWxPcl8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsT3JcIik7XG5jb25zdCBHcmFwaGljYWxXaXJlXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxXaXJlXCIpO1xuY29uc3QgR3JhcGhpY2FsUlNGbGlwRmxvcF8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsUlNGbGlwRmxvcFwiKTtcbmNvbnN0IEdyYXBoaWNhbEFuZF8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsQW5kXCIpO1xuY29uc3QgR3JhcGhpY2FsU3BsaXRfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFNwbGl0XCIpO1xuY29uc3QgR3JhcGhpY2FsU2lua1Rlcm1pbmFsXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxTaW5rVGVybWluYWxcIik7XG5jbGFzcyBHcmFwaGljYWxKS0ZsaXBGbG9wIGV4dGVuZHMgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRldGFpbGVkID0gZmFsc2UsIGluaXRpYWxWYWx1ZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIDcgKiBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQsIGRldGFpbGVkKTtcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIHRoaXMud2lyaW5nRGVzY3JpcHRpb25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ0xLX1NQTElUXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbFNwbGl0XzEuR3JhcGhpY2FsU3BsaXQoXCJDTEtfU1BMSVQwXCIsIDIsIDEpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIm91dHNpZGVcIiwgb3V0cHV0SW5kZXg6IDEgfV0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDMgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hULFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNMS19OT1RcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsTWFueU5vcnNfMS5HcmFwaGljYWxNYW55Tm9ycyhcIkNMS19OT1QwXCIsIDMsIGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwiQ0xLX1NQTElUX3RvX0NMS19OT1RcIiwgb3V0cHV0SW5kZXg6IDAgfV0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHsgbmFtZTogXCJDTEtfU1BMSVRcIiwgY29ubmVjdG9yOiBcIm91dHB1dFwiLCBpbmRleDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogNC41ICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ0xLX0FORFwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxBbmRfMS5HcmFwaGljYWxBbmQoXCJDTEtfQU5EMFwiLCAyLCBpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDTEtfU1BMSVRfdG9fQ0xLX0FORFwiLCBvdXRwdXRJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ0xLX05PVF90b19DTEtfQU5EXCIsIG91dHB1dEluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogeyBuYW1lOiBcIkNMS19OT1RcIiwgY29ubmVjdG9yOiBcIm91dHB1dFwiLCBpbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YTogLShHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUIC8gMyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogeyBuYW1lOiBcIkNMS19TUExJVFwiLCBjb25uZWN0b3I6IFwib3V0cHV0XCIsIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNMS19PVVRcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsU3BsaXRfMS5HcmFwaGljYWxTcGxpdChcIkNMS19TUExJVDFcIiwgMiwgMSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwiQ0xLX0FORF90b19DTEtfT1VUXCIsIG91dHB1dEluZGV4OiAwIH1dLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB7IG5hbWU6IFwiQ0xLX0FORFwiLCBjb25uZWN0b3I6IFwib3V0cHV0XCIsIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeyBuYW1lOiBcIkNMS19BTkRcIiwgY29ubmVjdG9yOiBcIm91dHB1dFwiLCBpbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJLX0FORFwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxBbmRfMS5HcmFwaGljYWxBbmQoXCJLX0FORDBcIiwgMywgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUV90b19LX0FORFwiLCBvdXRwdXRJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwib3V0c2lkZVwiLCBvdXRwdXRJbmRleDogMiB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ0xLX09VVF90b19LX0FORFwiLCBvdXRwdXRJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDggKiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hULFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkpfQU5EXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbEFuZF8xLkdyYXBoaWNhbEFuZChcIkpfQU5EMFwiLCAzLCBpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDTEtfT1VUX3RvX0pfQU5EXCIsIG91dHB1dEluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJvdXRzaWRlXCIsIG91dHB1dEluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJRbl90b19KX0FORFwiLCBvdXRwdXRJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDggKiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiA1ICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCxcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJSU0ZMSVBGTE9QXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbFJTRmxpcEZsb3BfMS5HcmFwaGljYWxSU0ZsaXBGbG9wKFwiUlNGTElQRkxPUDBcIiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiS19BTkRfdG9fUlNGRlwiLCBvdXRwdXRJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiSl9BTkRfdG9fUlNGRlwiLCBvdXRwdXRJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbMCwgMV0sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAxMCAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDIgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hULFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlFfU0lOS1wiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxTaW5rVGVybWluYWxfMS5HcmFwaGljYWxTaW5rVGVybWluYWwoXCJRX1NJTkswXCIpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJSU0ZGX3RvX1FfU0lOS1wiLCBvdXRwdXRJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDE2ICogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMi41ICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCxcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJRbl9TSU5LXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbFNpbmtUZXJtaW5hbF8xLkdyYXBoaWNhbFNpbmtUZXJtaW5hbChcIlFuX1NJTkswXCIpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJSU0ZGX3RvX1FuX1NJTktcIiwgb3V0cHV0SW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAxNiAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDQuNSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQsXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ0xLX1NQTElUX3RvX0NMS19OT1RcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJDTEtfU1BMSVRfdG9fQ0xLX05PVDBcIiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW3sgbmFtZTogXCJDTEtfU1BMSVRcIiwgb3V0cHV0SW5kZXg6IDAgfV0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ0xLX1NQTElUXCIsIGNvbm5lY3RvcjogXCJvdXRwdXRcIiwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBcInByZXZcIiwgeTogXCJuZXh0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNMS19OT1RcIiwgY29ubmVjdG9yOiBcImlucHV0XCIsIGluZGV4OiAwIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ0xLX1NQTElUX3RvX0NMS19BTkRcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJDTEtfU1BMSVRfdG9fQ0xLX0FORDBcIiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW3sgbmFtZTogXCJDTEtfU1BMSVRcIiwgb3V0cHV0SW5kZXg6IDEgfV0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ0xLX1NQTElUXCIsIGNvbm5lY3RvcjogXCJvdXRwdXRcIiwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNMS19BTkRcIiwgY29ubmVjdG9yOiBcImlucHV0XCIsIGluZGV4OiAwIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ0xLX05PVF90b19DTEtfQU5EXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlKFwiQ0xLX05PVF90b19DTEtfQU5EMFwiLCBpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIkNMS19OT1RcIiwgb3V0cHV0SW5kZXg6IDAgfV0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ0xLX05PVFwiLCBjb25uZWN0b3I6IFwib3V0cHV0XCIsIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogeyBkZWx0YTogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFIC8gMiwgZnJvbTogXCJwcmV2XCIgfSwgeTogXCJwcmV2XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBcInByZXZcIiwgeTogeyBkZWx0YTogLShHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQgLyAyICsgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFIC8gMiksIGZyb206IFwicHJldlwiIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB7IGRlbHRhOiAtKEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSAvIDIgKyBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9XSURUSCksIGZyb206IFwicHJldlwiIH0sIHk6IFwicHJldlwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogXCJwcmV2XCIsIHk6IHsgZGVsdGE6IC1HcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UgLyA0LCBmcm9tOiBcInByZXZcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogeyBkZWx0YTogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFIC8gMiArIEdyYXBoaWNhbE5vcl8xLkdyYXBoaWNhbE5vci5ERUZBVUxUX1dJRFRILCBmcm9tOiBcInByZXZcIiB9LCB5OiBcInByZXZcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IFwicHJldlwiLCB5OiB7IGRlbHRhOiAtR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFIC8gNCwgZnJvbTogXCJwcmV2XCIgfSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHsgZGVsdGE6IC0oR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFIC8gMiArIEdyYXBoaWNhbE5vcl8xLkdyYXBoaWNhbE5vci5ERUZBVUxUX1dJRFRIKSwgZnJvbTogXCJwcmV2XCIgfSwgeTogXCJwcmV2XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBcInByZXZcIiwgeTogeyBkZWx0YTogLUdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSAvIDQsIGZyb206IFwicHJldlwiIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB7IGRlbHRhOiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UgLyAyICsgR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfV0lEVEgsIGZyb206IFwicHJldlwiIH0sIHk6IFwicHJldlwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogXCJwcmV2XCIsIHk6IHsgZGVsdGE6IC1HcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UgLyA0LCBmcm9tOiBcInByZXZcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogeyBkZWx0YTogLShHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UgLyAyICsgR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfV0lEVEgpLCBmcm9tOiBcInByZXZcIiB9LCB5OiBcInByZXZcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IFwicHJldlwiLCB5OiBcIm5leHRcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ0xLX0FORFwiLCBjb25uZWN0b3I6IFwiaW5wdXRcIiwgaW5kZXg6IDEgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDTEtfQU5EX3RvX0NMS19PVVRcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJDTEtfQU5EX3RvX0NMS19PVVQwXCIsIGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwiQ0xLX0FORFwiLCBvdXRwdXRJbmRleDogMCB9XSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDTEtfQU5EXCIsIGNvbm5lY3RvcjogXCJvdXRwdXRcIiwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIkNMS19PVVRcIiwgY29ubmVjdG9yOiBcImlucHV0XCIsIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNMS19PVVRfdG9fS19BTkRcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJDTEtfT1VUX3RvX0tfQU5EMFwiLCBpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIkNMS19PVVRcIiwgb3V0cHV0SW5kZXg6IDAgfV0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiQ0xLX09VVFwiLCBjb25uZWN0b3I6IFwib3V0cHV0XCIsIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogXCJwcmV2XCIsIHk6IFwibmV4dFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJLX0FORFwiLCBjb25uZWN0b3I6IFwiaW5wdXRcIiwgaW5kZXg6IDIgfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ0xLX09VVF90b19KX0FORFwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZShcIkNMS19PVVRfdG9fSl9BTkQwXCIsIGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwiQ0xLX09VVFwiLCBvdXRwdXRJbmRleDogMSB9XSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJDTEtfT1VUXCIsIGNvbm5lY3RvcjogXCJvdXRwdXRcIiwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBcInByZXZcIiwgeTogXCJuZXh0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIkpfQU5EXCIsIGNvbm5lY3RvcjogXCJpbnB1dFwiLCBpbmRleDogMCB9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJLX0FORF90b19SU0ZGXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlKFwiS19BTkRfdG9fUlNGRjBcIiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW3sgbmFtZTogXCJLX0FORFwiLCBvdXRwdXRJbmRleDogMCB9XSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJLX0FORFwiLCBjb25uZWN0b3I6IFwib3V0cHV0XCIsIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogeyBkZWx0YTogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFIC8gMiwgZnJvbTogXCJwcmV2XCIgfSwgeTogXCJwcmV2XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB7IGRlbHRhOiAtR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFIC8gMiwgZnJvbTogXCJuZXh0XCIgfSwgeTogXCJuZXh0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJTRkxJUEZMT1BcIiwgY29ubmVjdG9yOiBcImlucHV0XCIsIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkpfQU5EX3RvX1JTRkZcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJKX0FORF90b19SU0ZGMFwiLCBpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIkpfQU5EXCIsIG91dHB1dEluZGV4OiAwIH1dLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIkpfQU5EXCIsIGNvbm5lY3RvcjogXCJvdXRwdXRcIiwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB7IGRlbHRhOiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UgLyAyLCBmcm9tOiBcInByZXZcIiB9LCB5OiBcInByZXZcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHsgZGVsdGE6IC1HcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UgLyAyLCBmcm9tOiBcIm5leHRcIiB9LCB5OiBcIm5leHRcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUlNGTElQRkxPUFwiLCBjb25uZWN0b3I6IFwiaW5wdXRcIiwgaW5kZXg6IDEgfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiUV90b19LX0FORFwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZShcIlFfdG9fS19BTkQwXCIsIGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwiUlNGTElQRkxPUFwiLCBvdXRwdXRJbmRleDogMCB9XSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJSU0ZMSVBGTE9QXCIsIGNvbm5lY3RvcjogXCJvdXRwdXRcIiwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBcInByZXZcIiwgeTogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCAvIDIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiA3ICogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFLCB5OiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUIC8gMiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IDcgKiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UsIHk6IFwibmV4dFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJLX0FORFwiLCBjb25uZWN0b3I6IFwiaW5wdXRcIiwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiUW5fdG9fSl9BTkRcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJRbl90b19KX0FORDBcIiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW3sgbmFtZTogXCJSU0ZMSVBGTE9QXCIsIG91dHB1dEluZGV4OiAxIH1dLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJTRkxJUEZMT1BcIiwgY29ubmVjdG9yOiBcIm91dHB1dFwiLCBpbmRleDogMSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IFwicHJldlwiLCB5OiA2LjUgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogNyAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSwgeTogNi41ICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IDcgKiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UsIHk6IFwibmV4dFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJKX0FORFwiLCBjb25uZWN0b3I6IFwiaW5wdXRcIiwgaW5kZXg6IDIgfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiUlNGRl90b19RX1NJTktcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJSU0ZGX3RvX1FfU0lOSzBcIiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW3sgbmFtZTogXCJSU0ZMSVBGTE9QXCIsIG91dHB1dEluZGV4OiAwIH1dLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIlJTRkxJUEZMT1BcIiwgY29ubmVjdG9yOiBcIm91dHB1dFwiLCBpbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IFwiUV9TSU5LXCIsIGNvbm5lY3RvcjogXCJpbnB1dFwiLCBpbmRleDogMCB9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJSU0ZGX3RvX1FuX1NJTktcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJSU0ZGX3RvX1FuX1NJTkswXCIsIGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwiUlNGTElQRkxPUFwiLCBvdXRwdXRJbmRleDogMSB9XSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogXCJSU0ZMSVBGTE9QXCIsIGNvbm5lY3RvcjogXCJvdXRwdXRcIiwgaW5kZXg6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiBcIlFuX1NJTktcIiwgY29ubmVjdG9yOiBcImlucHV0XCIsIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbWFrZURlZmF1bHRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxKS0ZsaXBGbG9wLkRFRkFVTFRfSEVJR0hUO1xuICAgIH1cbiAgICBtYWtlV2lyaW5nRGVzY3JpcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJpbmdEZXNjcmlwdGlvbnM7XG4gICAgfVxuICAgIG1ha2VDb25uZWN0b3JDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZWxlbWVudEhlaWdodDtcbiAgICAgICAgdGhpcy53aWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgodGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0TGluZVdpZHRoKHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAzLCAyKTtcbiAgICB9XG4gICAgbWFrZUJhc2VDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF07XG4gICAgfVxuICAgIG9uRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRWYWx1ZVJlYWRlciA9IGRhdGFTb3VyY2UuZ2V0QWRkcmVzc1ZhbHVlUmVhZGVyKHRoaXMuZWxlbWVudC5nZXRPdXRwdXRWYWx1ZUFkZHJlc3NQcm92aWRlcigwKSgpKTtcbiAgICAgICAgbGV0IGdyYXBoaWNzID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcbiAgICAgICAgbGV0IHRleHRTaXplUmVmZXJlbmNlSGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiAwLjY7XG4gICAgICAgIGxldCB0ZXh0SiA9IG5ldyBQSVhJLlRleHQoXCJKXCIsIHtcbiAgICAgICAgICAgIGZvbnRTaXplOiB0ZXh0U2l6ZVJlZmVyZW5jZUhlaWdodCAvIDUsXG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gICAgICAgICAgICBmaWxsOiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLlRFWFRfQ09MT1JcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0ZXh0SyA9IG5ldyBQSVhJLlRleHQoXCJLXCIsIHtcbiAgICAgICAgICAgIGZvbnRTaXplOiB0ZXh0U2l6ZVJlZmVyZW5jZUhlaWdodCAvIDUsXG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gICAgICAgICAgICBmaWxsOiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLlRFWFRfQ09MT1JcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0ZXh0Q0xLID0gbmV3IFBJWEkuVGV4dChcIkNMS1wiLCB7XG4gICAgICAgICAgICBmb250U2l6ZTogdGV4dFNpemVSZWZlcmVuY2VIZWlnaHQgLyA1LFxuICAgICAgICAgICAgZm9udEZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICAgICAgZmlsbDogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5URVhUX0NPTE9SXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGV4dFEgPSBuZXcgUElYSS5UZXh0KFwiUVwiLCB7XG4gICAgICAgICAgICBmb250U2l6ZTogdGV4dFNpemVSZWZlcmVuY2VIZWlnaHQgLyA1LFxuICAgICAgICAgICAgZm9udEZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICAgICAgZmlsbDogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5URVhUX0NPTE9SXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGV4dFFuID0gbmV3IFBJWEkuVGV4dChcIlFuXCIsIHtcbiAgICAgICAgICAgIGZvbnRTaXplOiB0ZXh0U2l6ZVJlZmVyZW5jZUhlaWdodCAvIDUsXG4gICAgICAgICAgICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gICAgICAgICAgICBmaWxsOiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLlRFWFRfQ09MT1JcbiAgICAgICAgfSk7XG4gICAgICAgIHRleHRKLmFuY2hvci5zZXQoMCwgMC41KTtcbiAgICAgICAgdGV4dEoueCA9IDEwO1xuICAgICAgICB0ZXh0Si55ID0gdGhpcy5oZWlnaHQgLyA0O1xuICAgICAgICB0ZXh0Sy5hbmNob3Iuc2V0KDAsIDAuNSk7XG4gICAgICAgIHRleHRLLnggPSAxMDtcbiAgICAgICAgdGV4dEsueSA9IDMgKiB0aGlzLmhlaWdodCAvIDQ7XG4gICAgICAgIHRleHRDTEsuYW5jaG9yLnNldCgwLCAwLjUpO1xuICAgICAgICB0ZXh0Q0xLLnggPSAxMCArIHRoaXMud2lkdGggLyA2O1xuICAgICAgICB0ZXh0Q0xLLnkgPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIHRleHRRLmFuY2hvci5zZXQoMSwgMC41KTtcbiAgICAgICAgdGV4dFEueCA9IHRoaXMud2lkdGggLSAxMDtcbiAgICAgICAgdGV4dFEueSA9IHRoaXMuaGVpZ2h0IC8gNDtcbiAgICAgICAgdGV4dFFuLmFuY2hvci5zZXQoMSwgMC41KTtcbiAgICAgICAgdGV4dFFuLnggPSB0aGlzLndpZHRoIC0gMTA7XG4gICAgICAgIHRleHRRbi55ID0gMyAqIHRoaXMuaGVpZ2h0IC8gNDtcbiAgICAgICAgZ3JhcGhpY3MuYWRkQ2hpbGQodGV4dEopO1xuICAgICAgICBncmFwaGljcy5hZGRDaGlsZCh0ZXh0Syk7XG4gICAgICAgIGdyYXBoaWNzLmFkZENoaWxkKHRleHRDTEspO1xuICAgICAgICBncmFwaGljcy5hZGRDaGlsZCh0ZXh0USk7XG4gICAgICAgIGdyYXBoaWNzLmFkZENoaWxkKHRleHRRbik7XG4gICAgICAgIHJldHVybiBncmFwaGljcztcbiAgICB9XG4gICAgZG9SZWRyYXcocHJvZ3Jlc3MpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5vdXRwdXRWYWx1ZVJlYWRlcigpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKHRoaXMubGluZVdpZHRoIC8gMiwgdmFsdWUgPyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ISUdIX0NPTE9SIDogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuTE9XX0NPTE9SLCAxKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubW92ZVRvKDAsIHRoaXMuaGVpZ2h0IC8gMiAtIHRoaXMuaGVpZ2h0IC8gMTApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVUbyh0aGlzLndpZHRoIC8gNiwgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oMCwgdGhpcy5oZWlnaHQgLyAyICsgdGhpcy5oZWlnaHQgLyAxMCk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxKS0ZsaXBGbG9wID0gR3JhcGhpY2FsSktGbGlwRmxvcDtcbihmdW5jdGlvbiAoR3JhcGhpY2FsSktGbGlwRmxvcCkge1xuICAgIEdyYXBoaWNhbEpLRmxpcEZsb3AuREVGQVVMVF9IRUlHSFQgPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUICogMjtcbn0pKEdyYXBoaWNhbEpLRmxpcEZsb3AgPSBleHBvcnRzLkdyYXBoaWNhbEpLRmxpcEZsb3AgfHwgKGV4cG9ydHMuR3JhcGhpY2FsSktGbGlwRmxvcCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljYWxKS0ZsaXBGbG9wLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalJKFlipFlop.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalManyNors.js":
/*!**********************************************!*\
  !*** ./out/js/graphics/GraphicalManyNors.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst GraphicalNor_1 = __webpack_require__(/*! ./GraphicalNor */ \"./out/js/graphics/GraphicalNor.js\");\nclass GraphicalManyNors extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, num, detailed = false, init = false) {\n        super(name, GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT, detailed);\n        this.drawCircle = (num % 2) !== 0;\n        let elements = [];\n        const elemDist = GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        if ((num % 2) === 0) {\n            init = !init;\n        }\n        for (let i = 0; i < num; i++) {\n            elements.push(`nor${i} nor init=${init} @${i > 0 ? `nor${i - 1}/o0+${elemDist}` : \"0\"}:0${i <= 0 ? \" <0\" : \"\"} ${(i + 1) >= num ? \"0>>\" : `>nor${i + 1}=${init}`}`);\n            init = !init;\n        }\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    makeDefaultHeight() {\n        return GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        let scale = elementHeight / this.getDefaultHeight();\n        this.height = elementHeight;\n        this.orWidth = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT);\n        this.notRadius = scale * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT / 12;\n        this.notCenterX = this.orWidth + this.notRadius;\n        this.notCenterY = this.height / 2;\n        this.width = this.orWidth + (this.drawCircle ? 2 * this.notRadius : 0);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, 1, 1);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.outputValueReader = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(0)());\n        let scale = elementHeight / this.getDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.orWidth, undefined, scale * GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT);\n    }\n    doRedraw(progress) {\n        let value = this.outputValueReader();\n        this.graphics.clear();\n        this.graphics.lineStyle(this.lineWidth, value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR, 1);\n        this.graphics.drawRect(0, 0, this.orWidth, this.height);\n        if (this.drawCircle) {\n            this.graphics.drawCircle(this.notCenterX, this.notCenterY, this.notRadius);\n        }\n    }\n}\nexports.GraphicalManyNors = GraphicalManyNors;\n//# sourceMappingURL=GraphicalManyNors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTWFueU5vcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTWFueU5vcnMuanM/MTQ3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0NvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRcIik7XG5jb25zdCBHcmFwaGljYWxPcl8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsT3JcIik7XG5jb25zdCBHcmFwaGljYWxXaXJlXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxXaXJlXCIpO1xuY29uc3QgR3JhbW1hclBhcnNlcl8xID0gcmVxdWlyZShcIi4uL2dyYW1tYXIvR3JhbW1hclBhcnNlclwiKTtcbmNvbnN0IEdyYXBoaWNhbE5vcl8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsTm9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsTWFueU5vcnMgZXh0ZW5kcyBDb21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XzEuQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgbnVtLCBkZXRhaWxlZCA9IGZhbHNlLCBpbml0ID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hULCBkZXRhaWxlZCk7XG4gICAgICAgIHRoaXMuZHJhd0NpcmNsZSA9IChudW0gJSAyKSAhPT0gMDtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGNvbnN0IGVsZW1EaXN0ID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0U7XG4gICAgICAgIGlmICgobnVtICUgMikgPT09IDApIHtcbiAgICAgICAgICAgIGluaXQgPSAhaW5pdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBub3Ike2l9IG5vciBpbml0PSR7aW5pdH0gQCR7aSA+IDAgPyBgbm9yJHtpIC0gMX0vbzArJHtlbGVtRGlzdH1gIDogXCIwXCJ9OjAke2kgPD0gMCA/IFwiIDwwXCIgOiBcIlwifSAkeyhpICsgMSkgPj0gbnVtID8gXCIwPj5cIiA6IGA+bm9yJHtpICsgMX09JHtpbml0fWB9YCk7XG4gICAgICAgICAgICBpbml0ID0gIWluaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aXJpbmdEZXNjcmlwdGlvbnMgPSBHcmFtbWFyUGFyc2VyXzEuR3JhbW1hclBhcnNlci5wYXJzZShlbGVtZW50cykud2lyaW5nRGVzY3JpcHRpb25zO1xuICAgIH1cbiAgICBtYWtlRGVmYXVsdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE5vcl8xLkdyYXBoaWNhbE5vci5ERUZBVUxUX0hFSUdIVDtcbiAgICB9XG4gICAgbWFrZVdpcmluZ0Rlc2NyaXB0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyaW5nRGVzY3JpcHRpb25zO1xuICAgIH1cbiAgICBtYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCkge1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5nZXREZWZhdWx0SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZWxlbWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5vcldpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE5vcl8xLkdyYXBoaWNhbE5vci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRMaW5lV2lkdGgoc2NhbGUgKiBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICB0aGlzLm5vdFJhZGl1cyA9IHNjYWxlICogR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUIC8gMTI7XG4gICAgICAgIHRoaXMubm90Q2VudGVyWCA9IHRoaXMub3JXaWR0aCArIHRoaXMubm90UmFkaXVzO1xuICAgICAgICB0aGlzLm5vdENlbnRlclkgPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLm9yV2lkdGggKyAodGhpcy5kcmF3Q2lyY2xlID8gMiAqIHRoaXMubm90UmFkaXVzIDogMCk7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VDb25uZWN0b3JDb29yZGluYXRlcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMSwgMSk7XG4gICAgfVxuICAgIG1ha2VCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdO1xuICAgIH1cbiAgICBvbkVsZW1lbnQoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICB9XG4gICAgbWFrZUdyYXBoaWNzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzLCBkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0VmFsdWVSZWFkZXIgPSBkYXRhU291cmNlLmdldEFkZHJlc3NWYWx1ZVJlYWRlcih0aGlzLmVsZW1lbnQuZ2V0T3V0cHV0VmFsdWVBZGRyZXNzUHJvdmlkZXIoMCkoKSk7XG4gICAgICAgIGxldCBzY2FsZSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdldERlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUdyYXBoaWNzKHRoaXMuaGVpZ2h0LCB0aGlzLm9yV2lkdGgsIHVuZGVmaW5lZCwgc2NhbGUgKiBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQpO1xuICAgIH1cbiAgICBkb1JlZHJhdyhwcm9ncmVzcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLm91dHB1dFZhbHVlUmVhZGVyKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lU3R5bGUodGhpcy5saW5lV2lkdGgsIHZhbHVlID8gR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuSElHSF9DT0xPUiA6IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkxPV19DT0xPUiwgMSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgdGhpcy5vcldpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLmRyYXdDaXJjbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd0NpcmNsZSh0aGlzLm5vdENlbnRlclgsIHRoaXMubm90Q2VudGVyWSwgdGhpcy5ub3RSYWRpdXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxNYW55Tm9ycyA9IEdyYXBoaWNhbE1hbnlOb3JzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY2FsTWFueU5vcnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalManyNors.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalMicro16.js":
/*!*********************************************!*\
  !*** ./out/js/graphics/GraphicalMicro16.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CombinedGraphicalElement_1 = __webpack_require__(/*! ./CombinedGraphicalElement */ \"./out/js/graphics/CombinedGraphicalElement.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalMicro16 extends CombinedGraphicalElement_1.CombinedGraphicalElement {\n    constructor(name, code, instructionDelay, aluDelay, registersDelay) {\n        let elements = [];\n        const wireDist = GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const busDist = 10;\n        const elemWidth = GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        const elemHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT;\n        const micX = 450;\n        const aluX = micX;\n        const clockX = 1100;\n        const storeX = aluX + 900;\n        const instRegX = storeX + 4 * busDist;\n        const micY = 100;\n        const storeY = 50;\n        const clockY = 100;\n        const aluY = 260;\n        const aBusY = aluY - 2 * busDist + busDist;\n        const bBusY = aluY - 3 * busDist + busDist;\n        const storeAfterY = storeY + 4 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT + wireDist;\n        elements.push(`regs micro16regs @0:60 0+15>p+${2 * busDist + 6 * wireDist}:p~p:${aBusY}~n:p~n+${busDist}:n~alu/i0 16+15>p+${busDist}:p~p:${bBusY}~n:p~n+${2 * busDist}:n~alu/i16`);\n        elements.push(`alu micro16alu @${aluX}:${aluY} 0+15>p-${busDist}:p~p:p+50~n:p~regs/i0 16>p+${2 * elemWidth + 2 * wireDist}:p~p:${storeAfterY + 4 * wireDist}~n:p~mic/i9`);\n        elements.push(`mic micro16mic @${micX}:${micY} 0+7>p:${storeAfterY + 2 * busDist}~n:p~n-${busDist}:n~store`);\n        let delayParams = `${(instructionDelay !== undefined) ? ` instructionDelay=${instructionDelay}` : \"\"}${(aluDelay !== undefined) ? ` aluDelay=${aluDelay}` : \"\"}${(registersDelay !== undefined) ? ` registersDelay=${registersDelay}` : \"\"}`;\n        elements.push(`clock micro16clock${delayParams} @${clockX}:${clockY}\n>p+${6 * wireDist}:p~p:n~n:n+${2 * wireDist}~n-${2 * wireDist}:n~instruction_reg/i32\n>p+${4 * wireDist}:p~p:instruction_reg/i32+${4 * wireDist}~n:p~alu/o16+${2 * elemWidth + 0 * wireDist}:n~alu/i32\n>p+${2 * wireDist}:p~p:p+${elemHeight}~p-${elemWidth + 4 * wireDist}:p~p:n~s_mic_enable_split`);\n        elements.push(`store micro16store code=${code} @${storeX}:${storeY} 0+31>instruction_reg`);\n        elements.push(`instruction_reg reg overrideHeight=${4 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT} i15@${instRegX}:store/o15\n1>n:p~alu/o16+${2 * elemWidth + 7 * wireDist}:n~n:n-${elemHeight}~n-${2 * wireDist}:n~alu/i37\n2>n:p~alu/o16+${2 * elemWidth + 8 * wireDist}:n~n:n+${elemHeight}~n-${2 * wireDist}:n~alu/i38\n3>n:p~alu/o16+${2 * elemWidth + 5 * wireDist}:n~alu/i34\n4>n:p~alu/o16+${2 * elemWidth + 4 * wireDist}:n~alu/i33\n5>n:p~alu/o16+${2 * elemWidth + 10 * wireDist}:n~alu/i35\n6>n:p~alu/o16+${2 * elemWidth + 11 * wireDist}:n~alu/i36\n12>p+${2 * wireDist}:p~p:n~n:regs/i17-${elemHeight + 2 * busDist + 2 * wireDist}~n+${5 * wireDist}:n~regs/i20\n13>p+${3 * wireDist}:p~p:n~n:regs/i17-${elemHeight + 2 * busDist + 3 * wireDist}~n+${4 * wireDist}:n~regs/i19\n14>p+${4 * wireDist}:p~p:n~n:regs/i17-${elemHeight + 2 * busDist + 4 * wireDist}~n+${3 * wireDist}:n~regs/i18\n15>p+${5 * wireDist}:p~p:n~n:regs/i17-${elemHeight + 2 * busDist + 5 * wireDist}~n+${2 * wireDist}:n~regs/i17\n16>p+${7 * wireDist}:p~p:n~n:regs/i21-${elemHeight + 2 * busDist - 8 * wireDist}~n+${10 * wireDist}:n~regs/i28\n17>p+${8 * wireDist}:p~p:n~n:regs/i21-${elemHeight + 2 * busDist - 7 * wireDist}~n+${9 * wireDist}:n~regs/i27\n18>p+${9 * wireDist}:p~p:n~n:regs/i21-${elemHeight + 2 * busDist - 6 * wireDist}~n+${8 * wireDist}:n~regs/i26\n19>p+${10 * wireDist}:p~p:n~n:regs/i21-${elemHeight + 2 * busDist - 5 * wireDist}~n+${7 * wireDist}:n~regs/i25\n20>p+${12 * wireDist}:p~p:n~n:regs/i21-${elemHeight + 2 * busDist - 3 * wireDist}~n+${5 * wireDist}:n~regs/i24\n21>p+${13 * wireDist}:p~p:n~n:regs/i21-${elemHeight + 2 * busDist - 2 * wireDist}~n+${4 * wireDist}:n~regs/i23\n22>p+${14 * wireDist}:p~p:n~n:regs/i21-${elemHeight + 2 * busDist - 1 * wireDist}~n+${3 * wireDist}:n~regs/i22\n23>p+${15 * wireDist}:p~p:n~n:regs/i21-${elemHeight + 2 * busDist - 0 * wireDist}~n+${2 * wireDist}:n~regs/i21\n24+7>p+${busDist}:p~p:${storeAfterY + 3 * busDist}~n:p~n+${2 * busDist + wireDist}:n~mic/i0`);\n        elements.push(`s_mic_enable_split split @mic/i8+${2 * wireDist}:${micY - 2 * busDist} >p:n~mic/i8 >regs/i25+${12 * wireDist}:p~p:n~n:n+${3 * wireDist}~n+${2 * wireDist}:n~regs/i16`);\n        super(name, 600, GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions);\n    }\n}\nexports.GraphicalMicro16 = GraphicalMicro16;\n//# sourceMappingURL=GraphicalMicro16.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTWljcm8xNi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxNaWNybzE2LmpzPzMxZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0NvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFtbWFyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9HcmFtbWFyUGFyc2VyXCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsTWljcm8xNiBleHRlbmRzIENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgY29kZSwgaW5zdHJ1Y3Rpb25EZWxheSwgYWx1RGVsYXksIHJlZ2lzdGVyc0RlbGF5KSB7XG4gICAgICAgIGxldCBlbGVtZW50cyA9IFtdO1xuICAgICAgICBjb25zdCB3aXJlRGlzdCA9IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRElTVEFOQ0U7XG4gICAgICAgIGNvbnN0IGJ1c0Rpc3QgPSAxMDtcbiAgICAgICAgY29uc3QgZWxlbVdpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKTtcbiAgICAgICAgY29uc3QgZWxlbUhlaWdodCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQ7XG4gICAgICAgIGNvbnN0IG1pY1ggPSA0NTA7XG4gICAgICAgIGNvbnN0IGFsdVggPSBtaWNYO1xuICAgICAgICBjb25zdCBjbG9ja1ggPSAxMTAwO1xuICAgICAgICBjb25zdCBzdG9yZVggPSBhbHVYICsgOTAwO1xuICAgICAgICBjb25zdCBpbnN0UmVnWCA9IHN0b3JlWCArIDQgKiBidXNEaXN0O1xuICAgICAgICBjb25zdCBtaWNZID0gMTAwO1xuICAgICAgICBjb25zdCBzdG9yZVkgPSA1MDtcbiAgICAgICAgY29uc3QgY2xvY2tZID0gMTAwO1xuICAgICAgICBjb25zdCBhbHVZID0gMjYwO1xuICAgICAgICBjb25zdCBhQnVzWSA9IGFsdVkgLSAyICogYnVzRGlzdCArIGJ1c0Rpc3Q7XG4gICAgICAgIGNvbnN0IGJCdXNZID0gYWx1WSAtIDMgKiBidXNEaXN0ICsgYnVzRGlzdDtcbiAgICAgICAgY29uc3Qgc3RvcmVBZnRlclkgPSBzdG9yZVkgKyA0ICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCArIHdpcmVEaXN0O1xuICAgICAgICBlbGVtZW50cy5wdXNoKGByZWdzIG1pY3JvMTZyZWdzIEAwOjYwIDArMTU+cCskezIgKiBidXNEaXN0ICsgNiAqIHdpcmVEaXN0fTpwfnA6JHthQnVzWX1+bjpwfm4rJHtidXNEaXN0fTpufmFsdS9pMCAxNisxNT5wKyR7YnVzRGlzdH06cH5wOiR7YkJ1c1l9fm46cH5uKyR7MiAqIGJ1c0Rpc3R9Om5+YWx1L2kxNmApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBhbHUgbWljcm8xNmFsdSBAJHthbHVYfToke2FsdVl9IDArMTU+cC0ke2J1c0Rpc3R9OnB+cDpwKzUwfm46cH5yZWdzL2kwIDE2PnArJHsyICogZWxlbVdpZHRoICsgMiAqIHdpcmVEaXN0fTpwfnA6JHtzdG9yZUFmdGVyWSArIDQgKiB3aXJlRGlzdH1+bjpwfm1pYy9pOWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBtaWMgbWljcm8xNm1pYyBAJHttaWNYfToke21pY1l9IDArNz5wOiR7c3RvcmVBZnRlclkgKyAyICogYnVzRGlzdH1+bjpwfm4tJHtidXNEaXN0fTpufnN0b3JlYCk7XG4gICAgICAgIGxldCBkZWxheVBhcmFtcyA9IGAkeyhpbnN0cnVjdGlvbkRlbGF5ICE9PSB1bmRlZmluZWQpID8gYCBpbnN0cnVjdGlvbkRlbGF5PSR7aW5zdHJ1Y3Rpb25EZWxheX1gIDogXCJcIn0keyhhbHVEZWxheSAhPT0gdW5kZWZpbmVkKSA/IGAgYWx1RGVsYXk9JHthbHVEZWxheX1gIDogXCJcIn0keyhyZWdpc3RlcnNEZWxheSAhPT0gdW5kZWZpbmVkKSA/IGAgcmVnaXN0ZXJzRGVsYXk9JHtyZWdpc3RlcnNEZWxheX1gIDogXCJcIn1gO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBjbG9jayBtaWNybzE2Y2xvY2ske2RlbGF5UGFyYW1zfSBAJHtjbG9ja1h9OiR7Y2xvY2tZfVxuPnArJHs2ICogd2lyZURpc3R9OnB+cDpufm46biskezIgKiB3aXJlRGlzdH1+bi0kezIgKiB3aXJlRGlzdH06bn5pbnN0cnVjdGlvbl9yZWcvaTMyXG4+cCskezQgKiB3aXJlRGlzdH06cH5wOmluc3RydWN0aW9uX3JlZy9pMzIrJHs0ICogd2lyZURpc3R9fm46cH5hbHUvbzE2KyR7MiAqIGVsZW1XaWR0aCArIDAgKiB3aXJlRGlzdH06bn5hbHUvaTMyXG4+cCskezIgKiB3aXJlRGlzdH06cH5wOnArJHtlbGVtSGVpZ2h0fX5wLSR7ZWxlbVdpZHRoICsgNCAqIHdpcmVEaXN0fTpwfnA6bn5zX21pY19lbmFibGVfc3BsaXRgKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChgc3RvcmUgbWljcm8xNnN0b3JlIGNvZGU9JHtjb2RlfSBAJHtzdG9yZVh9OiR7c3RvcmVZfSAwKzMxPmluc3RydWN0aW9uX3JlZ2ApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBpbnN0cnVjdGlvbl9yZWcgcmVnIG92ZXJyaWRlSGVpZ2h0PSR7NCAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFR9IGkxNUAke2luc3RSZWdYfTpzdG9yZS9vMTVcbjE+bjpwfmFsdS9vMTYrJHsyICogZWxlbVdpZHRoICsgNyAqIHdpcmVEaXN0fTpufm46bi0ke2VsZW1IZWlnaHR9fm4tJHsyICogd2lyZURpc3R9Om5+YWx1L2kzN1xuMj5uOnB+YWx1L28xNiskezIgKiBlbGVtV2lkdGggKyA4ICogd2lyZURpc3R9Om5+bjpuKyR7ZWxlbUhlaWdodH1+bi0kezIgKiB3aXJlRGlzdH06bn5hbHUvaTM4XG4zPm46cH5hbHUvbzE2KyR7MiAqIGVsZW1XaWR0aCArIDUgKiB3aXJlRGlzdH06bn5hbHUvaTM0XG40Pm46cH5hbHUvbzE2KyR7MiAqIGVsZW1XaWR0aCArIDQgKiB3aXJlRGlzdH06bn5hbHUvaTMzXG41Pm46cH5hbHUvbzE2KyR7MiAqIGVsZW1XaWR0aCArIDEwICogd2lyZURpc3R9Om5+YWx1L2kzNVxuNj5uOnB+YWx1L28xNiskezIgKiBlbGVtV2lkdGggKyAxMSAqIHdpcmVEaXN0fTpufmFsdS9pMzZcbjEyPnArJHsyICogd2lyZURpc3R9OnB+cDpufm46cmVncy9pMTctJHtlbGVtSGVpZ2h0ICsgMiAqIGJ1c0Rpc3QgKyAyICogd2lyZURpc3R9fm4rJHs1ICogd2lyZURpc3R9Om5+cmVncy9pMjBcbjEzPnArJHszICogd2lyZURpc3R9OnB+cDpufm46cmVncy9pMTctJHtlbGVtSGVpZ2h0ICsgMiAqIGJ1c0Rpc3QgKyAzICogd2lyZURpc3R9fm4rJHs0ICogd2lyZURpc3R9Om5+cmVncy9pMTlcbjE0PnArJHs0ICogd2lyZURpc3R9OnB+cDpufm46cmVncy9pMTctJHtlbGVtSGVpZ2h0ICsgMiAqIGJ1c0Rpc3QgKyA0ICogd2lyZURpc3R9fm4rJHszICogd2lyZURpc3R9Om5+cmVncy9pMThcbjE1PnArJHs1ICogd2lyZURpc3R9OnB+cDpufm46cmVncy9pMTctJHtlbGVtSGVpZ2h0ICsgMiAqIGJ1c0Rpc3QgKyA1ICogd2lyZURpc3R9fm4rJHsyICogd2lyZURpc3R9Om5+cmVncy9pMTdcbjE2PnArJHs3ICogd2lyZURpc3R9OnB+cDpufm46cmVncy9pMjEtJHtlbGVtSGVpZ2h0ICsgMiAqIGJ1c0Rpc3QgLSA4ICogd2lyZURpc3R9fm4rJHsxMCAqIHdpcmVEaXN0fTpufnJlZ3MvaTI4XG4xNz5wKyR7OCAqIHdpcmVEaXN0fTpwfnA6bn5uOnJlZ3MvaTIxLSR7ZWxlbUhlaWdodCArIDIgKiBidXNEaXN0IC0gNyAqIHdpcmVEaXN0fX5uKyR7OSAqIHdpcmVEaXN0fTpufnJlZ3MvaTI3XG4xOD5wKyR7OSAqIHdpcmVEaXN0fTpwfnA6bn5uOnJlZ3MvaTIxLSR7ZWxlbUhlaWdodCArIDIgKiBidXNEaXN0IC0gNiAqIHdpcmVEaXN0fX5uKyR7OCAqIHdpcmVEaXN0fTpufnJlZ3MvaTI2XG4xOT5wKyR7MTAgKiB3aXJlRGlzdH06cH5wOm5+bjpyZWdzL2kyMS0ke2VsZW1IZWlnaHQgKyAyICogYnVzRGlzdCAtIDUgKiB3aXJlRGlzdH1+biskezcgKiB3aXJlRGlzdH06bn5yZWdzL2kyNVxuMjA+cCskezEyICogd2lyZURpc3R9OnB+cDpufm46cmVncy9pMjEtJHtlbGVtSGVpZ2h0ICsgMiAqIGJ1c0Rpc3QgLSAzICogd2lyZURpc3R9fm4rJHs1ICogd2lyZURpc3R9Om5+cmVncy9pMjRcbjIxPnArJHsxMyAqIHdpcmVEaXN0fTpwfnA6bn5uOnJlZ3MvaTIxLSR7ZWxlbUhlaWdodCArIDIgKiBidXNEaXN0IC0gMiAqIHdpcmVEaXN0fX5uKyR7NCAqIHdpcmVEaXN0fTpufnJlZ3MvaTIzXG4yMj5wKyR7MTQgKiB3aXJlRGlzdH06cH5wOm5+bjpyZWdzL2kyMS0ke2VsZW1IZWlnaHQgKyAyICogYnVzRGlzdCAtIDEgKiB3aXJlRGlzdH1+biskezMgKiB3aXJlRGlzdH06bn5yZWdzL2kyMlxuMjM+cCskezE1ICogd2lyZURpc3R9OnB+cDpufm46cmVncy9pMjEtJHtlbGVtSGVpZ2h0ICsgMiAqIGJ1c0Rpc3QgLSAwICogd2lyZURpc3R9fm4rJHsyICogd2lyZURpc3R9Om5+cmVncy9pMjFcbjI0Kzc+cCske2J1c0Rpc3R9OnB+cDoke3N0b3JlQWZ0ZXJZICsgMyAqIGJ1c0Rpc3R9fm46cH5uKyR7MiAqIGJ1c0Rpc3QgKyB3aXJlRGlzdH06bn5taWMvaTBgKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChgc19taWNfZW5hYmxlX3NwbGl0IHNwbGl0IEBtaWMvaTgrJHsyICogd2lyZURpc3R9OiR7bWljWSAtIDIgKiBidXNEaXN0fSA+cDpufm1pYy9pOCA+cmVncy9pMjUrJHsxMiAqIHdpcmVEaXN0fTpwfnA6bn5uOm4rJHszICogd2lyZURpc3R9fm4rJHsyICogd2lyZURpc3R9Om5+cmVncy9pMTZgKTtcbiAgICAgICAgc3VwZXIobmFtZSwgNjAwLCBHcmFtbWFyUGFyc2VyXzEuR3JhbW1hclBhcnNlci5wYXJzZShlbGVtZW50cykud2lyaW5nRGVzY3JpcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLkdyYXBoaWNhbE1pY3JvMTYgPSBHcmFwaGljYWxNaWNybzE2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY2FsTWljcm8xNi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalMicro16.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalMicro16Alu.js":
/*!************************************************!*\
  !*** ./out/js/graphics/GraphicalMicro16Alu.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CombinedGraphicalElement_1 = __webpack_require__(/*! ./CombinedGraphicalElement */ \"./out/js/graphics/CombinedGraphicalElement.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalMicro16Alu extends CombinedGraphicalElement_1.CombinedGraphicalElement {\n    constructor(name) {\n        let elements = [];\n        const wireDist = GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const busDist = GraphicalWire_1.GraphicalWire.DEFAULT_BUS_DISTANCE;\n        const elemSpace = GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const elemHeight = Math.floor(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT / 2);\n        const regsHeight = (16 + 1) * wireDist;\n        const zeroNorHeight = 2 * regsHeight;\n        const notsHeight = elemHeight;\n        const decHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT;\n        const fasHeight = 2 * (2 * elemHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE) + elemHeight + 4 * GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE + GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const muxHeight = (4 * 17 + 1) * wireDist;\n        const shifterElementsHeight = elemHeight;\n        const outSplitHeight = regsHeight;\n        const logicOrsHeight = decHeight;\n        const muxWidth = GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        const regsWidth = GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        const fasWidth = 3 * GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE + GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT) + 3 * GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const fasAndSpacesWidth = fasWidth + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const shifterBlockWidth = 5 * wireDist + GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT) + 5 * wireDist;\n        const logicOrsWidth = GraphicalOr_1.GraphicalOr.getWidth(logicOrsHeight);\n        const displayWidth = 2 * regsWidth;\n        const muxX = 18 * wireDist;\n        const zeroNorX = muxX;\n        const muxAfterX = muxX + muxWidth;\n        const calcX = muxAfterX + 2 * GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE + 19 * wireDist + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const displaySplitX = calcX + 16 * fasWidth + 16 * GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE + 4 * wireDist;\n        const regsX = displaySplitX + displayWidth;\n        const decX = displaySplitX;\n        const shifterX = muxX;\n        const outSplitX = 0;\n        const shifterNorX = decX;\n        const muxY = 0;\n        const zeroNorY = muxY + muxHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const aRegY = muxY;\n        const aNotsY = aRegY + regsHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE + 16 * wireDist + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const bRegY = aNotsY + notsHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const faY = bRegY + regsHeight + decHeight;\n        const belowFaWiresY = faY + fasHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const logicWiresY = belowFaWiresY + 18 * wireDist;\n        const shifterInWiresY = logicWiresY + 3 * wireDist;\n        const shifterElementsY = shifterInWiresY + 18 * wireDist;\n        const shifterControlWiresY = shifterElementsY + 4 * shifterElementsHeight + 6 * elemSpace;\n        const outSplitY = shifterControlWiresY + 2 * wireDist + elemSpace;\n        const shifterNorY = outSplitY;\n        let aRegWires = [];\n        let bRegWires = [];\n        let aDisplaySplitWires = [];\n        let bDisplaySplitWires = [];\n        let muxWires = [];\n        elements.push(`out_split split line=true overrideHeight=${outSplitHeight} displayValue=belowRight @${outSplitX}:${outSplitY} 0+15>>`);\n        for (let i = 0; i < 16; i++) {\n            muxWires.push(`>n:p~mux_split${i}`);\n        }\n        elements.push(`mux mux overrideHeight=${muxHeight} mirrorConnectors=true @${muxX}:${muxY} ${muxWires.join(\" \")}`);\n        elements.push(`zero_nor nor overrideHeight=${zeroNorHeight} @${zeroNorX}:${zeroNorY} >${muxAfterX + 4 * wireDist}:p~p:${logicWiresY}~n-${2 * wireDist}:p~n:p~n-${3 * wireDist}:n~logic_z_or/i1`);\n        for (let i = 0; i < 16; i++) {\n            let shifterWire = ` >p:${shifterInWiresY + (15 - i) * wireDist}~n:p~shifter_split${i}`;\n            if (i >= 15) {\n                elements.push(`negative_split split @zero_nor/i${i}-${(17 - i) * wireDist}:${zeroNorY + zeroNorHeight + 2 * wireDist}${shifterWire} >${muxAfterX + 3 * wireDist}:p~p:n~logic_n_or/i0`);\n                shifterWire = ` >negative_split`;\n            }\n            elements.push(`mux_split${i} split @zero_nor/i${i}-${(17 - i) * wireDist}:zero_nor/i${i} >zero_nor/i${i}${shifterWire}`);\n        }\n        elements.push(`logic_n_or or i0@${decX}:${logicWiresY + wireDist} <38 >p+${3 * wireDist}:p~p:n~logic_and/i1`);\n        elements.push(`logic_z_or or i0@${decX}:logic_n_or/i0-${logicOrsHeight + elemSpace} <37 >p+${2 * wireDist}:p~p:n~logic_and/i0`);\n        elements.push(`logic_and and o0@logic_z_or/o0+${logicOrsWidth + 5 * wireDist}:logic_z_or/o0 0>>`);\n        for (let i = 0; i < 16; i++) {\n            let x = calcX + i * fasAndSpacesWidth;\n            elements.push(`not${i} nor overrideHeight=${notsHeight} @${x + 2 * wireDist}:${aNotsY} >p+${2 * wireDist}:p~p:n~mux/i${i + 17}`);\n            let cWire = i >= 15 ? \"\" : (i > 0) ? ` 0>p+${3 * wireDist}:p~p:n~add${i + 1}/i2` : ` 0>p:n~add${i + 1}/i2`;\n            elements.push(`add${i} ${(i > 0) ? \"fa\" : \"ha\"} detailed=true overrideHeight=${elemHeight} additionalAndOutput=true @${x}:${faY}${cWire}\n1>p:n~mux/i${i + 51}\n2>p+${2 * wireDist}:p~p:${belowFaWiresY + (i + 1) * wireDist}~${muxAfterX + (21 - i) * wireDist}:p~p:n~mux/i${i + 34}`);\n            elements.push(`a_split${i} split @add${i}/i1:mux/i${i} >not_split${i} >mux/i${i}`);\n            elements.push(`not_split${i} split @a_split${i}/i0:not${i}/i0 >add${i}/i1 >not${i}`);\n            aRegWires.push(`>areg_display_split/i${i}`);\n            bRegWires.push(`>breg_display_split/i${i}`);\n            aDisplaySplitWires.push(`>a_split${i}`);\n            bDisplaySplitWires.push(`>n:p~add${i}/i0`);\n        }\n        elements.push(`areg reg overrideHeight=${regsHeight} mirrorConnectors=true @${regsX}:${aRegY} <0+15 ${aRegWires.join(\" \")}`);\n        elements.push(`breg reg overrideHeight=${regsHeight} mirrorConnectors=true @${regsX}:${bRegY} <16+15 ${bRegWires.join(\" \")}`);\n        elements.push(`areg_display_split split line=true overrideHeight=${regsHeight} displayValue=belowRight i7@${displaySplitX}:areg/o7 ${aDisplaySplitWires.join(\" \")}`);\n        elements.push(`breg_display_split split line=true overrideHeight=${regsHeight} displayValue=aboveRight i7@${displaySplitX}:breg/o7 ${bDisplaySplitWires.join(\" \")}`);\n        elements.push(`regs_enable_split split @areg/i16+${2 * wireDist}:areg/i16 <32 >areg/i16 >p:n~breg/i16`);\n        elements.push(`dec decoder mirrorConnectors=true o2@${decX}:mux/i67 <33+1\n>p-${2 * wireDist}:p~p:n~mux/i16\n>p-${4 * wireDist}:p~${Math.floor(calcX + 1.5 * fasAndSpacesWidth)}:n~mux/i50\n>mux/i67\n>p-${3 * wireDist}:p~p:n~mux/i33`);\n        for (let i = 0; i < 16; i++) {\n            let x = shifterX + i * shifterBlockWidth + 5 * wireDist;\n            let fwdY = shifterElementsY;\n            let bwdY = fwdY + shifterElementsHeight + 2 * elemSpace;\n            let defY = bwdY + shifterElementsHeight + 2 * elemSpace;\n            let orY = defY + shifterElementsHeight + elemSpace;\n            let fwdWireY = bwdY - elemSpace;\n            let bwdWireY = defY - elemSpace;\n            let splitTargets = [];\n            elements.push(`shifter_forward_and${i} and overrideHeight=${shifterElementsHeight} @${x}:${fwdY}` + ((i < 15) ? ` >p+${4 * wireDist}:p~p:${fwdWireY}~n:p~n+${3 * wireDist}:n~shifter_or${i + 1}/i1` : \"\"));\n            elements.push(`shifter_backward_and${i} and overrideHeight=${shifterElementsHeight} @${x}:${bwdY}` + ((i > 0) ? ` >p+${2 * wireDist}:p~p:${bwdWireY}~n:p~n+${4 * wireDist}:n~shifter_or${i - 1}` : \"\"));\n            elements.push(`shifter_and${i} and overrideHeight=${shifterElementsHeight} @${x}:${defY} >p+${2 * wireDist}:p~p:n~shifter_or${i}/i0`);\n            elements.push(`shifter_split${i} split @shifter_forward_and${i}/i0-${2 * wireDist}:shifter_forward_and${i}/i0 >shifter_forward_and${i} >shifter_backward_split${i}`);\n            elements.push(`shifter_backward_split${i} split @shifter_backward_and${i}/i0-${2 * wireDist}:shifter_backward_and${i}/i0 >shifter_backward_and${i} >p:n~shifter_and${i}`);\n            elements.push(`shifter_or${i} or mirrorConnectors=true overrideHeight=${shifterElementsHeight} @${x}:${orY} >p-${5 * wireDist}:p~p:n~out_split`);\n            if (i > 0) {\n                let modifiers = [\"forward_\", \"backward_\", \"\"];\n                for (let j = 0; j < modifiers.length; j++) {\n                    let modifier = modifiers[j];\n                    let target = (i > 1) ? `${modifier}control_split${i - 1}` : `n:p~n-${(4 - j) * wireDist}:n~shifter_${modifier}and${i - 1}`;\n                    elements.push(`${modifier}control_split${i} split @${x - (4 - j) * wireDist}:${shifterControlWiresY + j * wireDist} >p:n~shifter_${modifier}and${i} >${target}`);\n                }\n            }\n        }\n        elements.push(`shifter_nor nor mirrorConnectors=true @${shifterNorX}:${shifterNorY} >p-${2 * wireDist}:p~p:n~control_split15`);\n        elements.push(`shifter_nor_forward_split split @shifter_nor/i0+${3 * wireDist}:shifter_nor/i0 <35 >shifter_nor/i0 >p:n~forward_control_split15`);\n        elements.push(`shifter_nor_backward_split split @shifter_nor/i1+${2 * wireDist}:shifter_nor/i1 <36 >shifter_nor/i1 >p:n~backward_control_split15`);\n        super(name, outSplitY + outSplitHeight, GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions);\n    }\n}\nexports.GraphicalMicro16Alu = GraphicalMicro16Alu;\n//# sourceMappingURL=GraphicalMicro16Alu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTWljcm8xNkFsdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxNaWNybzE2QWx1LmpzPzRjNDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0NvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFtbWFyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9HcmFtbWFyUGFyc2VyXCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsTWljcm8xNkFsdSBleHRlbmRzIENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBsZXQgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgY29uc3Qgd2lyZURpc3QgPSBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0RJU1RBTkNFO1xuICAgICAgICBjb25zdCBidXNEaXN0ID0gR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9CVVNfRElTVEFOQ0U7XG4gICAgICAgIGNvbnN0IGVsZW1TcGFjZSA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFO1xuICAgICAgICBjb25zdCBlbGVtSGVpZ2h0ID0gTWF0aC5mbG9vcihHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUIC8gMik7XG4gICAgICAgIGNvbnN0IHJlZ3NIZWlnaHQgPSAoMTYgKyAxKSAqIHdpcmVEaXN0O1xuICAgICAgICBjb25zdCB6ZXJvTm9ySGVpZ2h0ID0gMiAqIHJlZ3NIZWlnaHQ7XG4gICAgICAgIGNvbnN0IG5vdHNIZWlnaHQgPSBlbGVtSGVpZ2h0O1xuICAgICAgICBjb25zdCBkZWNIZWlnaHQgPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUO1xuICAgICAgICBjb25zdCBmYXNIZWlnaHQgPSAyICogKDIgKiBlbGVtSGVpZ2h0ICsgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0UpICsgZWxlbUhlaWdodCArIDQgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfRUxFTUVOVF9TUEFDRSArIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRElTVEFOQ0U7XG4gICAgICAgIGNvbnN0IG11eEhlaWdodCA9ICg0ICogMTcgKyAxKSAqIHdpcmVEaXN0O1xuICAgICAgICBjb25zdCBzaGlmdGVyRWxlbWVudHNIZWlnaHQgPSBlbGVtSGVpZ2h0O1xuICAgICAgICBjb25zdCBvdXRTcGxpdEhlaWdodCA9IHJlZ3NIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGxvZ2ljT3JzSGVpZ2h0ID0gZGVjSGVpZ2h0O1xuICAgICAgICBjb25zdCBtdXhXaWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgoR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIGNvbnN0IHJlZ3NXaWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgoR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIGNvbnN0IGZhc1dpZHRoID0gMyAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRElTVEFOQ0UgKyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldFdpZHRoKEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpICsgMyAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRElTVEFOQ0U7XG4gICAgICAgIGNvbnN0IGZhc0FuZFNwYWNlc1dpZHRoID0gZmFzV2lkdGggKyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfRUxFTUVOVF9TUEFDRTtcbiAgICAgICAgY29uc3Qgc2hpZnRlckJsb2NrV2lkdGggPSA1ICogd2lyZURpc3QgKyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldFdpZHRoKEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpICsgNSAqIHdpcmVEaXN0O1xuICAgICAgICBjb25zdCBsb2dpY09yc1dpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChsb2dpY09yc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IDIgKiByZWdzV2lkdGg7XG4gICAgICAgIGNvbnN0IG11eFggPSAxOCAqIHdpcmVEaXN0O1xuICAgICAgICBjb25zdCB6ZXJvTm9yWCA9IG11eFg7XG4gICAgICAgIGNvbnN0IG11eEFmdGVyWCA9IG11eFggKyBtdXhXaWR0aDtcbiAgICAgICAgY29uc3QgY2FsY1ggPSBtdXhBZnRlclggKyAyICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0UgKyAxOSAqIHdpcmVEaXN0ICsgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0U7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlTcGxpdFggPSBjYWxjWCArIDE2ICogZmFzV2lkdGggKyAxNiAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFICsgNCAqIHdpcmVEaXN0O1xuICAgICAgICBjb25zdCByZWdzWCA9IGRpc3BsYXlTcGxpdFggKyBkaXNwbGF5V2lkdGg7XG4gICAgICAgIGNvbnN0IGRlY1ggPSBkaXNwbGF5U3BsaXRYO1xuICAgICAgICBjb25zdCBzaGlmdGVyWCA9IG11eFg7XG4gICAgICAgIGNvbnN0IG91dFNwbGl0WCA9IDA7XG4gICAgICAgIGNvbnN0IHNoaWZ0ZXJOb3JYID0gZGVjWDtcbiAgICAgICAgY29uc3QgbXV4WSA9IDA7XG4gICAgICAgIGNvbnN0IHplcm9Ob3JZID0gbXV4WSArIG11eEhlaWdodCArIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFO1xuICAgICAgICBjb25zdCBhUmVnWSA9IG11eFk7XG4gICAgICAgIGNvbnN0IGFOb3RzWSA9IGFSZWdZICsgcmVnc0hlaWdodCArIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFICsgMTYgKiB3aXJlRGlzdCArIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9FTEVNRU5UX1NQQUNFO1xuICAgICAgICBjb25zdCBiUmVnWSA9IGFOb3RzWSArIG5vdHNIZWlnaHQgKyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfRUxFTUVOVF9TUEFDRTtcbiAgICAgICAgY29uc3QgZmFZID0gYlJlZ1kgKyByZWdzSGVpZ2h0ICsgZGVjSGVpZ2h0O1xuICAgICAgICBjb25zdCBiZWxvd0ZhV2lyZXNZID0gZmFZICsgZmFzSGVpZ2h0ICsgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0VMRU1FTlRfU1BBQ0U7XG4gICAgICAgIGNvbnN0IGxvZ2ljV2lyZXNZID0gYmVsb3dGYVdpcmVzWSArIDE4ICogd2lyZURpc3Q7XG4gICAgICAgIGNvbnN0IHNoaWZ0ZXJJbldpcmVzWSA9IGxvZ2ljV2lyZXNZICsgMyAqIHdpcmVEaXN0O1xuICAgICAgICBjb25zdCBzaGlmdGVyRWxlbWVudHNZID0gc2hpZnRlckluV2lyZXNZICsgMTggKiB3aXJlRGlzdDtcbiAgICAgICAgY29uc3Qgc2hpZnRlckNvbnRyb2xXaXJlc1kgPSBzaGlmdGVyRWxlbWVudHNZICsgNCAqIHNoaWZ0ZXJFbGVtZW50c0hlaWdodCArIDYgKiBlbGVtU3BhY2U7XG4gICAgICAgIGNvbnN0IG91dFNwbGl0WSA9IHNoaWZ0ZXJDb250cm9sV2lyZXNZICsgMiAqIHdpcmVEaXN0ICsgZWxlbVNwYWNlO1xuICAgICAgICBjb25zdCBzaGlmdGVyTm9yWSA9IG91dFNwbGl0WTtcbiAgICAgICAgbGV0IGFSZWdXaXJlcyA9IFtdO1xuICAgICAgICBsZXQgYlJlZ1dpcmVzID0gW107XG4gICAgICAgIGxldCBhRGlzcGxheVNwbGl0V2lyZXMgPSBbXTtcbiAgICAgICAgbGV0IGJEaXNwbGF5U3BsaXRXaXJlcyA9IFtdO1xuICAgICAgICBsZXQgbXV4V2lyZXMgPSBbXTtcbiAgICAgICAgZWxlbWVudHMucHVzaChgb3V0X3NwbGl0IHNwbGl0IGxpbmU9dHJ1ZSBvdmVycmlkZUhlaWdodD0ke291dFNwbGl0SGVpZ2h0fSBkaXNwbGF5VmFsdWU9YmVsb3dSaWdodCBAJHtvdXRTcGxpdFh9OiR7b3V0U3BsaXRZfSAwKzE1Pj5gKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBtdXhXaXJlcy5wdXNoKGA+bjpwfm11eF9zcGxpdCR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGBtdXggbXV4IG92ZXJyaWRlSGVpZ2h0PSR7bXV4SGVpZ2h0fSBtaXJyb3JDb25uZWN0b3JzPXRydWUgQCR7bXV4WH06JHttdXhZfSAke211eFdpcmVzLmpvaW4oXCIgXCIpfWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGB6ZXJvX25vciBub3Igb3ZlcnJpZGVIZWlnaHQ9JHt6ZXJvTm9ySGVpZ2h0fSBAJHt6ZXJvTm9yWH06JHt6ZXJvTm9yWX0gPiR7bXV4QWZ0ZXJYICsgNCAqIHdpcmVEaXN0fTpwfnA6JHtsb2dpY1dpcmVzWX1+bi0kezIgKiB3aXJlRGlzdH06cH5uOnB+bi0kezMgKiB3aXJlRGlzdH06bn5sb2dpY196X29yL2kxYCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNoaWZ0ZXJXaXJlID0gYCA+cDoke3NoaWZ0ZXJJbldpcmVzWSArICgxNSAtIGkpICogd2lyZURpc3R9fm46cH5zaGlmdGVyX3NwbGl0JHtpfWA7XG4gICAgICAgICAgICBpZiAoaSA+PSAxNSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYG5lZ2F0aXZlX3NwbGl0IHNwbGl0IEB6ZXJvX25vci9pJHtpfS0keygxNyAtIGkpICogd2lyZURpc3R9OiR7emVyb05vclkgKyB6ZXJvTm9ySGVpZ2h0ICsgMiAqIHdpcmVEaXN0fSR7c2hpZnRlcldpcmV9ID4ke211eEFmdGVyWCArIDMgKiB3aXJlRGlzdH06cH5wOm5+bG9naWNfbl9vci9pMGApO1xuICAgICAgICAgICAgICAgIHNoaWZ0ZXJXaXJlID0gYCA+bmVnYXRpdmVfc3BsaXRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHMucHVzaChgbXV4X3NwbGl0JHtpfSBzcGxpdCBAemVyb19ub3IvaSR7aX0tJHsoMTcgLSBpKSAqIHdpcmVEaXN0fTp6ZXJvX25vci9pJHtpfSA+emVyb19ub3IvaSR7aX0ke3NoaWZ0ZXJXaXJlfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGxvZ2ljX25fb3Igb3IgaTBAJHtkZWNYfToke2xvZ2ljV2lyZXNZICsgd2lyZURpc3R9IDwzOCA+cCskezMgKiB3aXJlRGlzdH06cH5wOm5+bG9naWNfYW5kL2kxYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGxvZ2ljX3pfb3Igb3IgaTBAJHtkZWNYfTpsb2dpY19uX29yL2kwLSR7bG9naWNPcnNIZWlnaHQgKyBlbGVtU3BhY2V9IDwzNyA+cCskezIgKiB3aXJlRGlzdH06cH5wOm5+bG9naWNfYW5kL2kwYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGxvZ2ljX2FuZCBhbmQgbzBAbG9naWNfel9vci9vMCske2xvZ2ljT3JzV2lkdGggKyA1ICogd2lyZURpc3R9OmxvZ2ljX3pfb3IvbzAgMD4+YCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgbGV0IHggPSBjYWxjWCArIGkgKiBmYXNBbmRTcGFjZXNXaWR0aDtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYG5vdCR7aX0gbm9yIG92ZXJyaWRlSGVpZ2h0PSR7bm90c0hlaWdodH0gQCR7eCArIDIgKiB3aXJlRGlzdH06JHthTm90c1l9ID5wKyR7MiAqIHdpcmVEaXN0fTpwfnA6bn5tdXgvaSR7aSArIDE3fWApO1xuICAgICAgICAgICAgbGV0IGNXaXJlID0gaSA+PSAxNSA/IFwiXCIgOiAoaSA+IDApID8gYCAwPnArJHszICogd2lyZURpc3R9OnB+cDpufmFkZCR7aSArIDF9L2kyYCA6IGAgMD5wOm5+YWRkJHtpICsgMX0vaTJgO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChgYWRkJHtpfSAkeyhpID4gMCkgPyBcImZhXCIgOiBcImhhXCJ9IGRldGFpbGVkPXRydWUgb3ZlcnJpZGVIZWlnaHQ9JHtlbGVtSGVpZ2h0fSBhZGRpdGlvbmFsQW5kT3V0cHV0PXRydWUgQCR7eH06JHtmYVl9JHtjV2lyZX1cbjE+cDpufm11eC9pJHtpICsgNTF9XG4yPnArJHsyICogd2lyZURpc3R9OnB+cDoke2JlbG93RmFXaXJlc1kgKyAoaSArIDEpICogd2lyZURpc3R9fiR7bXV4QWZ0ZXJYICsgKDIxIC0gaSkgKiB3aXJlRGlzdH06cH5wOm5+bXV4L2kke2kgKyAzNH1gKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYGFfc3BsaXQke2l9IHNwbGl0IEBhZGQke2l9L2kxOm11eC9pJHtpfSA+bm90X3NwbGl0JHtpfSA+bXV4L2kke2l9YCk7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBub3Rfc3BsaXQke2l9IHNwbGl0IEBhX3NwbGl0JHtpfS9pMDpub3Qke2l9L2kwID5hZGQke2l9L2kxID5ub3Qke2l9YCk7XG4gICAgICAgICAgICBhUmVnV2lyZXMucHVzaChgPmFyZWdfZGlzcGxheV9zcGxpdC9pJHtpfWApO1xuICAgICAgICAgICAgYlJlZ1dpcmVzLnB1c2goYD5icmVnX2Rpc3BsYXlfc3BsaXQvaSR7aX1gKTtcbiAgICAgICAgICAgIGFEaXNwbGF5U3BsaXRXaXJlcy5wdXNoKGA+YV9zcGxpdCR7aX1gKTtcbiAgICAgICAgICAgIGJEaXNwbGF5U3BsaXRXaXJlcy5wdXNoKGA+bjpwfmFkZCR7aX0vaTBgKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGBhcmVnIHJlZyBvdmVycmlkZUhlaWdodD0ke3JlZ3NIZWlnaHR9IG1pcnJvckNvbm5lY3RvcnM9dHJ1ZSBAJHtyZWdzWH06JHthUmVnWX0gPDArMTUgJHthUmVnV2lyZXMuam9pbihcIiBcIil9YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGJyZWcgcmVnIG92ZXJyaWRlSGVpZ2h0PSR7cmVnc0hlaWdodH0gbWlycm9yQ29ubmVjdG9ycz10cnVlIEAke3JlZ3NYfToke2JSZWdZfSA8MTYrMTUgJHtiUmVnV2lyZXMuam9pbihcIiBcIil9YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGFyZWdfZGlzcGxheV9zcGxpdCBzcGxpdCBsaW5lPXRydWUgb3ZlcnJpZGVIZWlnaHQ9JHtyZWdzSGVpZ2h0fSBkaXNwbGF5VmFsdWU9YmVsb3dSaWdodCBpN0Ake2Rpc3BsYXlTcGxpdFh9OmFyZWcvbzcgJHthRGlzcGxheVNwbGl0V2lyZXMuam9pbihcIiBcIil9YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGJyZWdfZGlzcGxheV9zcGxpdCBzcGxpdCBsaW5lPXRydWUgb3ZlcnJpZGVIZWlnaHQ9JHtyZWdzSGVpZ2h0fSBkaXNwbGF5VmFsdWU9YWJvdmVSaWdodCBpN0Ake2Rpc3BsYXlTcGxpdFh9OmJyZWcvbzcgJHtiRGlzcGxheVNwbGl0V2lyZXMuam9pbihcIiBcIil9YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYHJlZ3NfZW5hYmxlX3NwbGl0IHNwbGl0IEBhcmVnL2kxNiskezIgKiB3aXJlRGlzdH06YXJlZy9pMTYgPDMyID5hcmVnL2kxNiA+cDpufmJyZWcvaTE2YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGRlYyBkZWNvZGVyIG1pcnJvckNvbm5lY3RvcnM9dHJ1ZSBvMkAke2RlY1h9Om11eC9pNjcgPDMzKzFcbj5wLSR7MiAqIHdpcmVEaXN0fTpwfnA6bn5tdXgvaTE2XG4+cC0kezQgKiB3aXJlRGlzdH06cH4ke01hdGguZmxvb3IoY2FsY1ggKyAxLjUgKiBmYXNBbmRTcGFjZXNXaWR0aCl9Om5+bXV4L2k1MFxuPm11eC9pNjdcbj5wLSR7MyAqIHdpcmVEaXN0fTpwfnA6bn5tdXgvaTMzYCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgbGV0IHggPSBzaGlmdGVyWCArIGkgKiBzaGlmdGVyQmxvY2tXaWR0aCArIDUgKiB3aXJlRGlzdDtcbiAgICAgICAgICAgIGxldCBmd2RZID0gc2hpZnRlckVsZW1lbnRzWTtcbiAgICAgICAgICAgIGxldCBid2RZID0gZndkWSArIHNoaWZ0ZXJFbGVtZW50c0hlaWdodCArIDIgKiBlbGVtU3BhY2U7XG4gICAgICAgICAgICBsZXQgZGVmWSA9IGJ3ZFkgKyBzaGlmdGVyRWxlbWVudHNIZWlnaHQgKyAyICogZWxlbVNwYWNlO1xuICAgICAgICAgICAgbGV0IG9yWSA9IGRlZlkgKyBzaGlmdGVyRWxlbWVudHNIZWlnaHQgKyBlbGVtU3BhY2U7XG4gICAgICAgICAgICBsZXQgZndkV2lyZVkgPSBid2RZIC0gZWxlbVNwYWNlO1xuICAgICAgICAgICAgbGV0IGJ3ZFdpcmVZID0gZGVmWSAtIGVsZW1TcGFjZTtcbiAgICAgICAgICAgIGxldCBzcGxpdFRhcmdldHMgPSBbXTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYHNoaWZ0ZXJfZm9yd2FyZF9hbmQke2l9IGFuZCBvdmVycmlkZUhlaWdodD0ke3NoaWZ0ZXJFbGVtZW50c0hlaWdodH0gQCR7eH06JHtmd2RZfWAgKyAoKGkgPCAxNSkgPyBgID5wKyR7NCAqIHdpcmVEaXN0fTpwfnA6JHtmd2RXaXJlWX1+bjpwfm4rJHszICogd2lyZURpc3R9Om5+c2hpZnRlcl9vciR7aSArIDF9L2kxYCA6IFwiXCIpKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYHNoaWZ0ZXJfYmFja3dhcmRfYW5kJHtpfSBhbmQgb3ZlcnJpZGVIZWlnaHQ9JHtzaGlmdGVyRWxlbWVudHNIZWlnaHR9IEAke3h9OiR7YndkWX1gICsgKChpID4gMCkgPyBgID5wKyR7MiAqIHdpcmVEaXN0fTpwfnA6JHtid2RXaXJlWX1+bjpwfm4rJHs0ICogd2lyZURpc3R9Om5+c2hpZnRlcl9vciR7aSAtIDF9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYHNoaWZ0ZXJfYW5kJHtpfSBhbmQgb3ZlcnJpZGVIZWlnaHQ9JHtzaGlmdGVyRWxlbWVudHNIZWlnaHR9IEAke3h9OiR7ZGVmWX0gPnArJHsyICogd2lyZURpc3R9OnB+cDpufnNoaWZ0ZXJfb3Ike2l9L2kwYCk7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBzaGlmdGVyX3NwbGl0JHtpfSBzcGxpdCBAc2hpZnRlcl9mb3J3YXJkX2FuZCR7aX0vaTAtJHsyICogd2lyZURpc3R9OnNoaWZ0ZXJfZm9yd2FyZF9hbmQke2l9L2kwID5zaGlmdGVyX2ZvcndhcmRfYW5kJHtpfSA+c2hpZnRlcl9iYWNrd2FyZF9zcGxpdCR7aX1gKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYHNoaWZ0ZXJfYmFja3dhcmRfc3BsaXQke2l9IHNwbGl0IEBzaGlmdGVyX2JhY2t3YXJkX2FuZCR7aX0vaTAtJHsyICogd2lyZURpc3R9OnNoaWZ0ZXJfYmFja3dhcmRfYW5kJHtpfS9pMCA+c2hpZnRlcl9iYWNrd2FyZF9hbmQke2l9ID5wOm5+c2hpZnRlcl9hbmQke2l9YCk7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBzaGlmdGVyX29yJHtpfSBvciBtaXJyb3JDb25uZWN0b3JzPXRydWUgb3ZlcnJpZGVIZWlnaHQ9JHtzaGlmdGVyRWxlbWVudHNIZWlnaHR9IEAke3h9OiR7b3JZfSA+cC0kezUgKiB3aXJlRGlzdH06cH5wOm5+b3V0X3NwbGl0YCk7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZXJzID0gW1wiZm9yd2FyZF9cIiwgXCJiYWNrd2FyZF9cIiwgXCJcIl07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtb2RpZmllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVyID0gbW9kaWZpZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gKGkgPiAxKSA/IGAke21vZGlmaWVyfWNvbnRyb2xfc3BsaXQke2kgLSAxfWAgOiBgbjpwfm4tJHsoNCAtIGopICogd2lyZURpc3R9Om5+c2hpZnRlcl8ke21vZGlmaWVyfWFuZCR7aSAtIDF9YDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChgJHttb2RpZmllcn1jb250cm9sX3NwbGl0JHtpfSBzcGxpdCBAJHt4IC0gKDQgLSBqKSAqIHdpcmVEaXN0fToke3NoaWZ0ZXJDb250cm9sV2lyZXNZICsgaiAqIHdpcmVEaXN0fSA+cDpufnNoaWZ0ZXJfJHttb2RpZmllcn1hbmQke2l9ID4ke3RhcmdldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMucHVzaChgc2hpZnRlcl9ub3Igbm9yIG1pcnJvckNvbm5lY3RvcnM9dHJ1ZSBAJHtzaGlmdGVyTm9yWH06JHtzaGlmdGVyTm9yWX0gPnAtJHsyICogd2lyZURpc3R9OnB+cDpufmNvbnRyb2xfc3BsaXQxNWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBzaGlmdGVyX25vcl9mb3J3YXJkX3NwbGl0IHNwbGl0IEBzaGlmdGVyX25vci9pMCskezMgKiB3aXJlRGlzdH06c2hpZnRlcl9ub3IvaTAgPDM1ID5zaGlmdGVyX25vci9pMCA+cDpufmZvcndhcmRfY29udHJvbF9zcGxpdDE1YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYHNoaWZ0ZXJfbm9yX2JhY2t3YXJkX3NwbGl0IHNwbGl0IEBzaGlmdGVyX25vci9pMSskezIgKiB3aXJlRGlzdH06c2hpZnRlcl9ub3IvaTEgPDM2ID5zaGlmdGVyX25vci9pMSA+cDpufmJhY2t3YXJkX2NvbnRyb2xfc3BsaXQxNWApO1xuICAgICAgICBzdXBlcihuYW1lLCBvdXRTcGxpdFkgKyBvdXRTcGxpdEhlaWdodCwgR3JhbW1hclBhcnNlcl8xLkdyYW1tYXJQYXJzZXIucGFyc2UoZWxlbWVudHMpLndpcmluZ0Rlc2NyaXB0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxNaWNybzE2QWx1ID0gR3JhcGhpY2FsTWljcm8xNkFsdTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbE1pY3JvMTZBbHUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalMicro16Alu.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalMicro16Clock.js":
/*!**************************************************!*\
  !*** ./out/js/graphics/GraphicalMicro16Clock.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Micro16Clock_1 = __webpack_require__(/*! ../elements/Micro16Clock */ \"./out/js/elements/Micro16Clock.js\");\nconst StubGraphicalElement_1 = __webpack_require__(/*! ./StubGraphicalElement */ \"./out/js/graphics/StubGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalMultiplexer_1 = __webpack_require__(/*! ./GraphicalMultiplexer */ \"./out/js/graphics/GraphicalMultiplexer.js\");\nclass GraphicalMicro16Clock extends StubGraphicalElement_1.StubGraphicalElement {\n    constructor(name, instructionDelay, aluDelay, registersDelay) {\n        super(name);\n        this.instructionDelay = instructionDelay;\n        this.aluDelay = aluDelay;\n        this.registersDelay = registersDelay;\n    }\n    getDefaultHeight() {\n        return GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.getDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, 0, 3, false);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeElement(elementHeight, coordinates) {\n        return new Micro16Clock_1.Micro16Clock(this.getName(), this.instructionDelay, this.aluDelay, this.registersDelay);\n    }\n    makeGraphics(elementHeight, coordinates) {\n        let scale = elementHeight / this.getDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"CK\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    redraw(progress) {\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, GraphicalMultiplexer_1.GraphicalDecoder.COMPACT_COLOR);\n    }\n}\nexports.GraphicalMicro16Clock = GraphicalMicro16Clock;\n//# sourceMappingURL=GraphicalMicro16Clock.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTWljcm8xNkNsb2NrLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbE1pY3JvMTZDbG9jay5qcz8yM2VlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTWljcm8xNkNsb2NrXzEgPSByZXF1aXJlKFwiLi4vZWxlbWVudHMvTWljcm8xNkNsb2NrXCIpO1xuY29uc3QgU3R1YkdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL1N0dWJHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY29uc3QgR3JhcGhpY2FsTXVsdGlwbGV4ZXJfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE11bHRpcGxleGVyXCIpO1xuY2xhc3MgR3JhcGhpY2FsTWljcm8xNkNsb2NrIGV4dGVuZHMgU3R1YkdyYXBoaWNhbEVsZW1lbnRfMS5TdHViR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgaW5zdHJ1Y3Rpb25EZWxheSwgYWx1RGVsYXksIHJlZ2lzdGVyc0RlbGF5KSB7XG4gICAgICAgIHN1cGVyKG5hbWUpO1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uRGVsYXkgPSBpbnN0cnVjdGlvbkRlbGF5O1xuICAgICAgICB0aGlzLmFsdURlbGF5ID0gYWx1RGVsYXk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJzRGVsYXkgPSByZWdpc3RlcnNEZWxheTtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQ7XG4gICAgfVxuICAgIG1ha2VDb25uZWN0b3JDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZWxlbWVudEhlaWdodDtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMuZ2V0RGVmYXVsdEhlaWdodCgpO1xuICAgICAgICB0aGlzLndpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0TGluZVdpZHRoKHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VDb25uZWN0b3JDb29yZGluYXRlcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgMywgZmFsc2UpO1xuICAgIH1cbiAgICBtYWtlQmFzZUNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlc1swXTtcbiAgICB9XG4gICAgbWFrZUVsZW1lbnQoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNaWNybzE2Q2xvY2tfMS5NaWNybzE2Q2xvY2sodGhpcy5nZXROYW1lKCksIHRoaXMuaW5zdHJ1Y3Rpb25EZWxheSwgdGhpcy5hbHVEZWxheSwgdGhpcy5yZWdpc3RlcnNEZWxheSk7XG4gICAgfVxuICAgIG1ha2VHcmFwaGljcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5nZXREZWZhdWx0SGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VHcmFwaGljcyh0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgXCJDS1wiLCBzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgIH1cbiAgICByZWRyYXcocHJvZ3Jlc3MpIHtcbiAgICAgICAgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5yZWRyYXcodGhpcy5ncmFwaGljcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMubGluZVdpZHRoLCBHcmFwaGljYWxNdWx0aXBsZXhlcl8xLkdyYXBoaWNhbERlY29kZXIuQ09NUEFDVF9DT0xPUik7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxNaWNybzE2Q2xvY2sgPSBHcmFwaGljYWxNaWNybzE2Q2xvY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljYWxNaWNybzE2Q2xvY2suanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalMicro16Clock.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalMicro16Mic.js":
/*!************************************************!*\
  !*** ./out/js/graphics/GraphicalMicro16Mic.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CombinedGraphicalElement_1 = __webpack_require__(/*! ./CombinedGraphicalElement */ \"./out/js/graphics/CombinedGraphicalElement.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalMicro16Mic extends CombinedGraphicalElement_1.CombinedGraphicalElement {\n    constructor(name) {\n        let elements = [];\n        const wireDist = GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const elemSpace = GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const busDist = GraphicalWire_1.GraphicalWire.DEFAULT_BUS_DISTANCE;\n        const elemWidth = GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        const haWidth = 3 * wireDist + elemWidth + 3 * wireDist;\n        const elemHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT;\n        const muxHeight = elemHeight;\n        const haElemHeight = elemHeight / 2;\n        const regHeight = elemHeight;\n        const faHeight = 2 * haElemHeight + elemSpace;\n        const haX = 0;\n        const distributorX = haX + 8 * haWidth;\n        const regX = distributorX + 4 * busDist;\n        const collectorX = haX;\n        const muxX = regX + elemWidth + busDist + 3 * wireDist;\n        const jumpNotX = muxX;\n        const busY = 0;\n        const distributorY = busY + busDist;\n        const regY = distributorY;\n        const faY = regY + regHeight + elemSpace;\n        const collectorY = faY + faHeight + elemSpace;\n        const jumpNotY = regY + regHeight + 4 * wireDist;\n        let distributorWires = [];\n        for (let i = 0; i < 8; i++) {\n            let x = haX + i * haWidth;\n            if (i < 1) {\n            }\n            else {\n                elements.push(`add${i} ha detailed=true overrideHeight=${haElemHeight} @${x}:${faY} 1>p+${2 * wireDist}:p~p:n~collector/i${i}` + ((i < 7) ? ` 0>p+${1 * wireDist}:p~p:n~add${i + 1}/i1` : \"\"));\n            }\n            distributorWires.push(`>n:p~add${i}/i0`);\n        }\n        elements.push(`add0 split @${haX}:add1/i1 >add1/i1 >p:n~nor0`);\n        elements.push(`nor0 nor overrideHeight=${haElemHeight} i0@${haX + 1 * wireDist}:add1/o1 >p+${2 * wireDist}:p~p:n~collector/i0`);\n        elements.push(`reg reg mirrorConnectors=true @${regX}:${regY} 8<8 0+7>out_split`);\n        elements.push(`distributor split line=true @${distributorX}:${distributorY} ${distributorWires.join(\" \")}`);\n        elements.push(`out_split split @distributor/i3+${2 * busDist}:distributor/i3 0+7>> 8+7>distributor`);\n        elements.push(`collector split line=true @${collectorX}:${collectorY} 0+7>p-${busDist}:p~p:${busY}~n:p~n+${busDist}:n~mux/i0`);\n        elements.push(`mux mux mirrorConnectors=true overrideHeight=${muxHeight} o3@${muxX}:reg/i3 9<0+7 0+7>reg`);\n        elements.push(`jump_not nor @${jumpNotX}:${jumpNotY} >p+${3 * wireDist}:p~p:n~mux/i8`);\n        elements.push(`jump_split split @jump_not/i0-${2 * wireDist}:jump_not/i0 <9 >jump_not >p:${jumpNotY - 2 * wireDist}~n:p~n+${2 * wireDist}:n~mux/i17`);\n        super(name, collectorY + elemHeight, GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions);\n    }\n}\nexports.GraphicalMicro16Mic = GraphicalMicro16Mic;\n//# sourceMappingURL=GraphicalMicro16Mic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTWljcm8xNk1pYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxNaWNybzE2TWljLmpzPzc4ODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0NvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFtbWFyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9HcmFtbWFyUGFyc2VyXCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsTWljcm8xNk1pYyBleHRlbmRzIENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBsZXQgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgY29uc3Qgd2lyZURpc3QgPSBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0RJU1RBTkNFO1xuICAgICAgICBjb25zdCBlbGVtU3BhY2UgPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfRUxFTUVOVF9TUEFDRTtcbiAgICAgICAgY29uc3QgYnVzRGlzdCA9IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfQlVTX0RJU1RBTkNFO1xuICAgICAgICBjb25zdCBlbGVtV2lkdGggPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldFdpZHRoKEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICBjb25zdCBoYVdpZHRoID0gMyAqIHdpcmVEaXN0ICsgZWxlbVdpZHRoICsgMyAqIHdpcmVEaXN0O1xuICAgICAgICBjb25zdCBlbGVtSGVpZ2h0ID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVDtcbiAgICAgICAgY29uc3QgbXV4SGVpZ2h0ID0gZWxlbUhlaWdodDtcbiAgICAgICAgY29uc3QgaGFFbGVtSGVpZ2h0ID0gZWxlbUhlaWdodCAvIDI7XG4gICAgICAgIGNvbnN0IHJlZ0hlaWdodCA9IGVsZW1IZWlnaHQ7XG4gICAgICAgIGNvbnN0IGZhSGVpZ2h0ID0gMiAqIGhhRWxlbUhlaWdodCArIGVsZW1TcGFjZTtcbiAgICAgICAgY29uc3QgaGFYID0gMDtcbiAgICAgICAgY29uc3QgZGlzdHJpYnV0b3JYID0gaGFYICsgOCAqIGhhV2lkdGg7XG4gICAgICAgIGNvbnN0IHJlZ1ggPSBkaXN0cmlidXRvclggKyA0ICogYnVzRGlzdDtcbiAgICAgICAgY29uc3QgY29sbGVjdG9yWCA9IGhhWDtcbiAgICAgICAgY29uc3QgbXV4WCA9IHJlZ1ggKyBlbGVtV2lkdGggKyBidXNEaXN0ICsgMyAqIHdpcmVEaXN0O1xuICAgICAgICBjb25zdCBqdW1wTm90WCA9IG11eFg7XG4gICAgICAgIGNvbnN0IGJ1c1kgPSAwO1xuICAgICAgICBjb25zdCBkaXN0cmlidXRvclkgPSBidXNZICsgYnVzRGlzdDtcbiAgICAgICAgY29uc3QgcmVnWSA9IGRpc3RyaWJ1dG9yWTtcbiAgICAgICAgY29uc3QgZmFZID0gcmVnWSArIHJlZ0hlaWdodCArIGVsZW1TcGFjZTtcbiAgICAgICAgY29uc3QgY29sbGVjdG9yWSA9IGZhWSArIGZhSGVpZ2h0ICsgZWxlbVNwYWNlO1xuICAgICAgICBjb25zdCBqdW1wTm90WSA9IHJlZ1kgKyByZWdIZWlnaHQgKyA0ICogd2lyZURpc3Q7XG4gICAgICAgIGxldCBkaXN0cmlidXRvcldpcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeCA9IGhhWCArIGkgKiBoYVdpZHRoO1xuICAgICAgICAgICAgaWYgKGkgPCAxKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBhZGQke2l9IGhhIGRldGFpbGVkPXRydWUgb3ZlcnJpZGVIZWlnaHQ9JHtoYUVsZW1IZWlnaHR9IEAke3h9OiR7ZmFZfSAxPnArJHsyICogd2lyZURpc3R9OnB+cDpufmNvbGxlY3Rvci9pJHtpfWAgKyAoKGkgPCA3KSA/IGAgMD5wKyR7MSAqIHdpcmVEaXN0fTpwfnA6bn5hZGQke2kgKyAxfS9pMWAgOiBcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0cmlidXRvcldpcmVzLnB1c2goYD5uOnB+YWRkJHtpfS9pMGApO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGFkZDAgc3BsaXQgQCR7aGFYfTphZGQxL2kxID5hZGQxL2kxID5wOm5+bm9yMGApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBub3IwIG5vciBvdmVycmlkZUhlaWdodD0ke2hhRWxlbUhlaWdodH0gaTBAJHtoYVggKyAxICogd2lyZURpc3R9OmFkZDEvbzEgPnArJHsyICogd2lyZURpc3R9OnB+cDpufmNvbGxlY3Rvci9pMGApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGByZWcgcmVnIG1pcnJvckNvbm5lY3RvcnM9dHJ1ZSBAJHtyZWdYfToke3JlZ1l9IDg8OCAwKzc+b3V0X3NwbGl0YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGRpc3RyaWJ1dG9yIHNwbGl0IGxpbmU9dHJ1ZSBAJHtkaXN0cmlidXRvclh9OiR7ZGlzdHJpYnV0b3JZfSAke2Rpc3RyaWJ1dG9yV2lyZXMuam9pbihcIiBcIil9YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYG91dF9zcGxpdCBzcGxpdCBAZGlzdHJpYnV0b3IvaTMrJHsyICogYnVzRGlzdH06ZGlzdHJpYnV0b3IvaTMgMCs3Pj4gOCs3PmRpc3RyaWJ1dG9yYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGNvbGxlY3RvciBzcGxpdCBsaW5lPXRydWUgQCR7Y29sbGVjdG9yWH06JHtjb2xsZWN0b3JZfSAwKzc+cC0ke2J1c0Rpc3R9OnB+cDoke2J1c1l9fm46cH5uKyR7YnVzRGlzdH06bn5tdXgvaTBgKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChgbXV4IG11eCBtaXJyb3JDb25uZWN0b3JzPXRydWUgb3ZlcnJpZGVIZWlnaHQ9JHttdXhIZWlnaHR9IG8zQCR7bXV4WH06cmVnL2kzIDk8MCs3IDArNz5yZWdgKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChganVtcF9ub3Qgbm9yIEAke2p1bXBOb3RYfToke2p1bXBOb3RZfSA+cCskezMgKiB3aXJlRGlzdH06cH5wOm5+bXV4L2k4YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGp1bXBfc3BsaXQgc3BsaXQgQGp1bXBfbm90L2kwLSR7MiAqIHdpcmVEaXN0fTpqdW1wX25vdC9pMCA8OSA+anVtcF9ub3QgPnA6JHtqdW1wTm90WSAtIDIgKiB3aXJlRGlzdH1+bjpwfm4rJHsyICogd2lyZURpc3R9Om5+bXV4L2kxN2ApO1xuICAgICAgICBzdXBlcihuYW1lLCBjb2xsZWN0b3JZICsgZWxlbUhlaWdodCwgR3JhbW1hclBhcnNlcl8xLkdyYW1tYXJQYXJzZXIucGFyc2UoZWxlbWVudHMpLndpcmluZ0Rlc2NyaXB0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxNaWNybzE2TWljID0gR3JhcGhpY2FsTWljcm8xNk1pYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbE1pY3JvMTZNaWMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalMicro16Mic.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalMicro16Registers.js":
/*!******************************************************!*\
  !*** ./out/js/graphics/GraphicalMicro16Registers.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CombinedGraphicalElement_1 = __webpack_require__(/*! ./CombinedGraphicalElement */ \"./out/js/graphics/CombinedGraphicalElement.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalMicro16Registers extends CombinedGraphicalElement_1.CombinedGraphicalElement {\n    constructor(name) {\n        const wireDist = GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE;\n        const busDist = 10;\n        const decoderHeight = (16 + 1) * wireDist;\n        const regWidth = Math.floor(GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT));\n        const regHeight = Math.floor(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT / 2);\n        const regDist = 2 * GraphicalWire_1.GraphicalWire.DEFAULT_HEIGHT;\n        const displaySplitHeight = Math.floor(regHeight / 4);\n        const muxHeight = 16 * regHeight + 15 * regDist;\n        const muxWidth = Math.floor(GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT));\n        const sSplitsX = 18 * wireDist;\n        const regsX = sSplitsX + busDist;\n        const regsAfterX = regsX + regWidth;\n        const regsY = decoderHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE + 4 * wireDist;\n        const regSplitsX = regsAfterX + 2 * regWidth;\n        const sDecMuxX = regsX;\n        const sDecX = sDecMuxX + 2 * regWidth;\n        const aMuxX = regsX + regWidth + 2 * regWidth + 17 * busDist + 18 * wireDist;\n        const aMuxY = regsY;\n        const bDecY = aMuxY + muxHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const bMuxX = aMuxX;\n        const bMuxY = bDecY + decoderHeight + GraphicalOr_1.GraphicalOr.DEFAULT_ELEMENT_SPACE;\n        const totalHeight = bMuxY + muxHeight;\n        let elements = [];\n        let regEnableWires = [];\n        let aMuxEnableWires = [];\n        let bMuxEnableWires = [];\n        elements.push(`amux mux overrideHeight=${muxHeight} @${aMuxX}:${aMuxY} 0+15>>`);\n        elements.push(`bmux mux overrideHeight=${muxHeight} @${bMuxX}:${bMuxY} 0+15>>`);\n        for (let i = 0; i < 16; i++) {\n            elements.push(`reg_split${i} split @${regSplitsX + (16 - i) * busDist}:amux/i${i * 17 + 7} 0+15>amux/i${i * 17} 16+15>p:n~bmux/i${i * 17}`);\n            let readOnlyParams = \"\";\n            if (i <= 2) {\n                readOnlyParams = ` readOnly=true initHex=${[\"0000\", \"0001\", \"FFFF\"][i]}`;\n            }\n            elements.push(`reg${i} reg overrideHeight=${regHeight}${readOnlyParams} o7@${regsAfterX}:reg_split${i}/i0 0+15>display_split${i}`);\n            elements.push(`display_split${i} split overrideHeight=${displaySplitHeight} line=true displayValue=belowRight i7@reg${i}/o7+${2 * wireDist}:reg${i}/o7 0+15>reg_split${i}`);\n            if (i === 4) {\n                elements.push(`s_split${i} split @${sSplitsX}:reg${i}/i7 0+15>reg${i} 16+15>p:n~reg${i - 1}`);\n            }\n            else if (i > 4) {\n                elements.push(`s_split${i} split @${sSplitsX}:reg${i}/i7` + ((i < 15) ? \"\" : \" <0+15\") + ` 0+15>reg${i} 16+15>s_split${i - 1}`);\n            }\n            if (i > 2) {\n                regEnableWires.push(`${15 - i}>p-${(i + 2) * wireDist + busDist}:p~p:n~reg${i}/i16`);\n            }\n            aMuxEnableWires.push(`${15 - i}>p-${(i + 2) * wireDist}:p~p:n~amux/i${((i + 1) * 17) - 1}`);\n            bMuxEnableWires.push(`${15 - i}>p-${(i + 2) * wireDist}:p~p:n~bmux/i${((i + 1) * 17) - 1}`);\n        }\n        elements.push(`s_dec_mux mux numOutBits=16 numInChannels=1 mirrorConnectors=true overrideHeight=${decoderHeight} @${sDecMuxX}:0 16<16 ${regEnableWires.join(\" \")}`);\n        elements.push(`s_dec decoder mirrorConnectors=true overrideHeight=${decoderHeight} o7@${sDecX}:s_dec_mux/i7 <17+3 0+15>s_dec_mux`);\n        elements.push(`a_dec decoder mirrorConnectors=true overrideHeight=${decoderHeight} @${aMuxX}:0 <21+3 ${aMuxEnableWires.join(\" \")}`);\n        elements.push(`b_dec decoder mirrorConnectors=true overrideHeight=${decoderHeight} @${bMuxX}:${bDecY} <25+3 ${bMuxEnableWires.join(\" \")}`);\n        super(name, totalHeight, GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions);\n    }\n}\nexports.GraphicalMicro16Registers = GraphicalMicro16Registers;\n//# sourceMappingURL=GraphicalMicro16Registers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTWljcm8xNlJlZ2lzdGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxNaWNybzE2UmVnaXN0ZXJzLmpzP2E0YTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0NvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFtbWFyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9HcmFtbWFyUGFyc2VyXCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsTWljcm8xNlJlZ2lzdGVycyBleHRlbmRzIENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBjb25zdCB3aXJlRGlzdCA9IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRElTVEFOQ0U7XG4gICAgICAgIGNvbnN0IGJ1c0Rpc3QgPSAxMDtcbiAgICAgICAgY29uc3QgZGVjb2RlckhlaWdodCA9ICgxNiArIDEpICogd2lyZURpc3Q7XG4gICAgICAgIGNvbnN0IHJlZ1dpZHRoID0gTWF0aC5mbG9vcihHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldFdpZHRoKEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpKTtcbiAgICAgICAgY29uc3QgcmVnSGVpZ2h0ID0gTWF0aC5mbG9vcihHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUIC8gMik7XG4gICAgICAgIGNvbnN0IHJlZ0Rpc3QgPSAyICogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9IRUlHSFQ7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlTcGxpdEhlaWdodCA9IE1hdGguZmxvb3IocmVnSGVpZ2h0IC8gNCk7XG4gICAgICAgIGNvbnN0IG11eEhlaWdodCA9IDE2ICogcmVnSGVpZ2h0ICsgMTUgKiByZWdEaXN0O1xuICAgICAgICBjb25zdCBtdXhXaWR0aCA9IE1hdGguZmxvb3IoR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKSk7XG4gICAgICAgIGNvbnN0IHNTcGxpdHNYID0gMTggKiB3aXJlRGlzdDtcbiAgICAgICAgY29uc3QgcmVnc1ggPSBzU3BsaXRzWCArIGJ1c0Rpc3Q7XG4gICAgICAgIGNvbnN0IHJlZ3NBZnRlclggPSByZWdzWCArIHJlZ1dpZHRoO1xuICAgICAgICBjb25zdCByZWdzWSA9IGRlY29kZXJIZWlnaHQgKyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfRUxFTUVOVF9TUEFDRSArIDQgKiB3aXJlRGlzdDtcbiAgICAgICAgY29uc3QgcmVnU3BsaXRzWCA9IHJlZ3NBZnRlclggKyAyICogcmVnV2lkdGg7XG4gICAgICAgIGNvbnN0IHNEZWNNdXhYID0gcmVnc1g7XG4gICAgICAgIGNvbnN0IHNEZWNYID0gc0RlY011eFggKyAyICogcmVnV2lkdGg7XG4gICAgICAgIGNvbnN0IGFNdXhYID0gcmVnc1ggKyByZWdXaWR0aCArIDIgKiByZWdXaWR0aCArIDE3ICogYnVzRGlzdCArIDE4ICogd2lyZURpc3Q7XG4gICAgICAgIGNvbnN0IGFNdXhZID0gcmVnc1k7XG4gICAgICAgIGNvbnN0IGJEZWNZID0gYU11eFkgKyBtdXhIZWlnaHQgKyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfRUxFTUVOVF9TUEFDRTtcbiAgICAgICAgY29uc3QgYk11eFggPSBhTXV4WDtcbiAgICAgICAgY29uc3QgYk11eFkgPSBiRGVjWSArIGRlY29kZXJIZWlnaHQgKyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfRUxFTUVOVF9TUEFDRTtcbiAgICAgICAgY29uc3QgdG90YWxIZWlnaHQgPSBiTXV4WSArIG11eEhlaWdodDtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGxldCByZWdFbmFibGVXaXJlcyA9IFtdO1xuICAgICAgICBsZXQgYU11eEVuYWJsZVdpcmVzID0gW107XG4gICAgICAgIGxldCBiTXV4RW5hYmxlV2lyZXMgPSBbXTtcbiAgICAgICAgZWxlbWVudHMucHVzaChgYW11eCBtdXggb3ZlcnJpZGVIZWlnaHQ9JHttdXhIZWlnaHR9IEAke2FNdXhYfToke2FNdXhZfSAwKzE1Pj5gKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChgYm11eCBtdXggb3ZlcnJpZGVIZWlnaHQ9JHttdXhIZWlnaHR9IEAke2JNdXhYfToke2JNdXhZfSAwKzE1Pj5gKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGByZWdfc3BsaXQke2l9IHNwbGl0IEAke3JlZ1NwbGl0c1ggKyAoMTYgLSBpKSAqIGJ1c0Rpc3R9OmFtdXgvaSR7aSAqIDE3ICsgN30gMCsxNT5hbXV4L2kke2kgKiAxN30gMTYrMTU+cDpufmJtdXgvaSR7aSAqIDE3fWApO1xuICAgICAgICAgICAgbGV0IHJlYWRPbmx5UGFyYW1zID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChpIDw9IDIpIHtcbiAgICAgICAgICAgICAgICByZWFkT25seVBhcmFtcyA9IGAgcmVhZE9ubHk9dHJ1ZSBpbml0SGV4PSR7W1wiMDAwMFwiLCBcIjAwMDFcIiwgXCJGRkZGXCJdW2ldfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGByZWcke2l9IHJlZyBvdmVycmlkZUhlaWdodD0ke3JlZ0hlaWdodH0ke3JlYWRPbmx5UGFyYW1zfSBvN0Ake3JlZ3NBZnRlclh9OnJlZ19zcGxpdCR7aX0vaTAgMCsxNT5kaXNwbGF5X3NwbGl0JHtpfWApO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChgZGlzcGxheV9zcGxpdCR7aX0gc3BsaXQgb3ZlcnJpZGVIZWlnaHQ9JHtkaXNwbGF5U3BsaXRIZWlnaHR9IGxpbmU9dHJ1ZSBkaXNwbGF5VmFsdWU9YmVsb3dSaWdodCBpN0ByZWcke2l9L283KyR7MiAqIHdpcmVEaXN0fTpyZWcke2l9L283IDArMTU+cmVnX3NwbGl0JHtpfWApO1xuICAgICAgICAgICAgaWYgKGkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBzX3NwbGl0JHtpfSBzcGxpdCBAJHtzU3BsaXRzWH06cmVnJHtpfS9pNyAwKzE1PnJlZyR7aX0gMTYrMTU+cDpufnJlZyR7aSAtIDF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID4gNCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYHNfc3BsaXQke2l9IHNwbGl0IEAke3NTcGxpdHNYfTpyZWcke2l9L2k3YCArICgoaSA8IDE1KSA/IFwiXCIgOiBcIiA8MCsxNVwiKSArIGAgMCsxNT5yZWcke2l9IDE2KzE1PnNfc3BsaXQke2kgLSAxfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAyKSB7XG4gICAgICAgICAgICAgICAgcmVnRW5hYmxlV2lyZXMucHVzaChgJHsxNSAtIGl9PnAtJHsoaSArIDIpICogd2lyZURpc3QgKyBidXNEaXN0fTpwfnA6bn5yZWcke2l9L2kxNmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYU11eEVuYWJsZVdpcmVzLnB1c2goYCR7MTUgLSBpfT5wLSR7KGkgKyAyKSAqIHdpcmVEaXN0fTpwfnA6bn5hbXV4L2kkeygoaSArIDEpICogMTcpIC0gMX1gKTtcbiAgICAgICAgICAgIGJNdXhFbmFibGVXaXJlcy5wdXNoKGAkezE1IC0gaX0+cC0keyhpICsgMikgKiB3aXJlRGlzdH06cH5wOm5+Ym11eC9pJHsoKGkgKyAxKSAqIDE3KSAtIDF9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMucHVzaChgc19kZWNfbXV4IG11eCBudW1PdXRCaXRzPTE2IG51bUluQ2hhbm5lbHM9MSBtaXJyb3JDb25uZWN0b3JzPXRydWUgb3ZlcnJpZGVIZWlnaHQ9JHtkZWNvZGVySGVpZ2h0fSBAJHtzRGVjTXV4WH06MCAxNjwxNiAke3JlZ0VuYWJsZVdpcmVzLmpvaW4oXCIgXCIpfWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBzX2RlYyBkZWNvZGVyIG1pcnJvckNvbm5lY3RvcnM9dHJ1ZSBvdmVycmlkZUhlaWdodD0ke2RlY29kZXJIZWlnaHR9IG83QCR7c0RlY1h9OnNfZGVjX211eC9pNyA8MTcrMyAwKzE1PnNfZGVjX211eGApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBhX2RlYyBkZWNvZGVyIG1pcnJvckNvbm5lY3RvcnM9dHJ1ZSBvdmVycmlkZUhlaWdodD0ke2RlY29kZXJIZWlnaHR9IEAke2FNdXhYfTowIDwyMSszICR7YU11eEVuYWJsZVdpcmVzLmpvaW4oXCIgXCIpfWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBiX2RlYyBkZWNvZGVyIG1pcnJvckNvbm5lY3RvcnM9dHJ1ZSBvdmVycmlkZUhlaWdodD0ke2RlY29kZXJIZWlnaHR9IEAke2JNdXhYfToke2JEZWNZfSA8MjUrMyAke2JNdXhFbmFibGVXaXJlcy5qb2luKFwiIFwiKX1gKTtcbiAgICAgICAgc3VwZXIobmFtZSwgdG90YWxIZWlnaHQsIEdyYW1tYXJQYXJzZXJfMS5HcmFtbWFyUGFyc2VyLnBhcnNlKGVsZW1lbnRzKS53aXJpbmdEZXNjcmlwdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhcGhpY2FsTWljcm8xNlJlZ2lzdGVycyA9IEdyYXBoaWNhbE1pY3JvMTZSZWdpc3RlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljYWxNaWNybzE2UmVnaXN0ZXJzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalMicro16Registers.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalMicro16Store.js":
/*!**************************************************!*\
  !*** ./out/js/graphics/GraphicalMicro16Store.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Micro16Store_1 = __webpack_require__(/*! ../elements/Micro16Store */ \"./out/js/elements/Micro16Store.js\");\nconst StubGraphicalElement_1 = __webpack_require__(/*! ./StubGraphicalElement */ \"./out/js/graphics/StubGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalMultiplexer_1 = __webpack_require__(/*! ./GraphicalMultiplexer */ \"./out/js/graphics/GraphicalMultiplexer.js\");\nclass GraphicalMicro16Store extends StubGraphicalElement_1.StubGraphicalElement {\n    constructor(name, code) {\n        super(name);\n        this.code = code;\n    }\n    getDefaultHeight() {\n        return 4 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.getDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, 8, 32, false);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeElement(elementHeight, coordinates) {\n        return new Micro16Store_1.Micro16Store(this.getName(), this.code);\n    }\n    makeGraphics(elementHeight, coordinates) {\n        let scale = elementHeight / this.getDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"St\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    redraw(progress) {\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, GraphicalMultiplexer_1.GraphicalDecoder.COMPACT_COLOR);\n    }\n}\nexports.GraphicalMicro16Store = GraphicalMicro16Store;\n//# sourceMappingURL=GraphicalMicro16Store.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTWljcm8xNlN0b3JlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbE1pY3JvMTZTdG9yZS5qcz9mNzUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTWljcm8xNlN0b3JlXzEgPSByZXF1aXJlKFwiLi4vZWxlbWVudHMvTWljcm8xNlN0b3JlXCIpO1xuY29uc3QgU3R1YkdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL1N0dWJHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY29uc3QgR3JhcGhpY2FsTXVsdGlwbGV4ZXJfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE11bHRpcGxleGVyXCIpO1xuY2xhc3MgR3JhcGhpY2FsTWljcm8xNlN0b3JlIGV4dGVuZHMgU3R1YkdyYXBoaWNhbEVsZW1lbnRfMS5TdHViR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgY29kZSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIDQgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUO1xuICAgIH1cbiAgICBtYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIGxldCBzY2FsZSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdldERlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgoc2NhbGUgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKTtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldExpbmVXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICByZXR1cm4gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5tYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDgsIDMyLCBmYWxzZSk7XG4gICAgfVxuICAgIG1ha2VCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdO1xuICAgIH1cbiAgICBtYWtlRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IE1pY3JvMTZTdG9yZV8xLk1pY3JvMTZTdG9yZSh0aGlzLmdldE5hbWUoKSwgdGhpcy5jb2RlKTtcbiAgICB9XG4gICAgbWFrZUdyYXBoaWNzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGxldCBzY2FsZSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdldERlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUdyYXBoaWNzKHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCBcIlN0XCIsIHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgfVxuICAgIHJlZHJhdyhwcm9ncmVzcykge1xuICAgICAgICBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLnJlZHJhdyh0aGlzLmdyYXBoaWNzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5saW5lV2lkdGgsIEdyYXBoaWNhbE11bHRpcGxleGVyXzEuR3JhcGhpY2FsRGVjb2Rlci5DT01QQUNUX0NPTE9SKTtcbiAgICB9XG59XG5leHBvcnRzLkdyYXBoaWNhbE1pY3JvMTZTdG9yZSA9IEdyYXBoaWNhbE1pY3JvMTZTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbE1pY3JvMTZTdG9yZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalMicro16Store.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalMultiplexer.js":
/*!*************************************************!*\
  !*** ./out/js/graphics/GraphicalMultiplexer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nclass GraphicalMultiplexer extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, numInChannels, numOutBits, detailed = false, wireDist = GraphicalWire_1.GraphicalWire.DEFAULT_DISTANCE, overrideHeight, mirrorConnectors = false) {\n        super(name, GraphicalMultiplexer.inputChannelBase(numOutBits, numInChannels, wireDist) + numOutBits * wireDist, detailed);\n        this.numInChannels = numInChannels;\n        this.numOutBits = numOutBits;\n        this.wireDist = wireDist;\n        this.overrideHeight = overrideHeight;\n        this.mirrorConnectors = mirrorConnectors;\n        const elemDist = GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE;\n        let elements = [];\n        let width = GraphicalMultiplexer.outputBitBase(numInChannels, numOutBits, wireDist);\n        let outputSplitX = width;\n        for (let c = 0; c < numInChannels; c++) {\n            let baseY = GraphicalMultiplexer.inputChannelBase(numOutBits, c, wireDist);\n            let enableSplitY = baseY + numOutBits * wireDist;\n            let enableSplit = \"\";\n            let andY = baseY + (numOutBits + 1) * wireDist;\n            for (let i = 0; i < numOutBits; i++) {\n                let y = baseY + (numOutBits - i - 1) * wireDist;\n                let inputIndex = c * (numOutBits + 1) + i;\n                let and = `and_${c}_${i}`;\n                let andX = GraphicalMultiplexer.outputBitBase(numInChannels, i, wireDist) + 2 * elemDist;\n                let or = `or_${i}`;\n                let wireDelta = elemDist + c * wireDist;\n                elements.push(`${and} and @${andX}:${andY} >n:p~n-${wireDelta}:n~${or}`);\n                elements.push(`input_split${c}_${i} split @0:${y} <${inputIndex} >n:p~n-${elemDist}:n~${and}/i0`);\n                if (i <= 0) {\n                    let enableInputIndex = (c + 1) * (numOutBits + 1) - 1;\n                    enableSplit = `enable_split${c} split @0:${enableSplitY} <${enableInputIndex} >p:n~${and}/i1`;\n                }\n                else if ((i + 1) < numOutBits) {\n                    enableSplit += ` >enable_split${c}_${i}`;\n                    elements.push(enableSplit);\n                    enableSplit = `enable_split${c}_${i} split @${and}/i1-${2 * elemDist}:${enableSplitY} >p:n~${and}/i1`;\n                }\n                else {\n                    enableSplit += ` >n:p~n-${2 * elemDist}:n~${and}/i1`;\n                    elements.push(enableSplit);\n                }\n                if ((c + 1) >= numInChannels) {\n                    let outputSplit = `output_split${i}`;\n                    let outputSplitY = andY + GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT + (numOutBits - i - 1) * wireDist;\n                    elements.push(`${outputSplit} split @${outputSplitX}:${outputSplitY} 0>>`);\n                    let orX = andX + GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT) + 2 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE + (numInChannels - 1) * wireDist;\n                    elements.push(`${or} or @${orX}:${andY} >p+${elemDist}:p~p:n~${outputSplit}`);\n                }\n            }\n        }\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    static inputChannelBase(numOutBits, inputChannelIndex, wireDist) {\n        return inputChannelIndex * ((numOutBits + 2) * wireDist + GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    static outputBitBase(numInChannels, outputBitIndex, wireDist) {\n        return outputBitIndex * (2 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE + GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT) + 2 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE + Math.max(0, numInChannels - 1) * wireDist + GraphicalOr_1.GraphicalOr.getWidth(GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT) + 2 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE);\n    }\n    makeDefaultHeight() {\n        return this.overrideHeight !== undefined ? this.overrideHeight : (this.numInChannels * (this.numOutBits + 1) + 2) * this.wireDist;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.makeDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, this.numInChannels * (this.numOutBits + 1), this.numOutBits, this.mirrorConnectors);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeGraphics(elementHeight, coordinates) {\n        let scale = elementHeight / this.makeDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"MX\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    doRedraw(progress) {\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, GraphicalDecoder.COMPACT_COLOR);\n    }\n}\nexports.GraphicalMultiplexer = GraphicalMultiplexer;\nvar GraphicalDecoder;\n(function (GraphicalDecoder) {\n    GraphicalDecoder.COMPACT_COLOR = 0x000000;\n})(GraphicalDecoder = exports.GraphicalDecoder || (exports.GraphicalDecoder = {}));\n//# sourceMappingURL=GraphicalMultiplexer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTXVsdGlwbGV4ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTXVsdGlwbGV4ZXIuanM/YjVkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEdyYW1tYXJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9ncmFtbWFyL0dyYW1tYXJQYXJzZXJcIik7XG5jb25zdCBHcmFwaGljYWxPcl8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsT3JcIik7XG5jb25zdCBDb21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XzEgPSByZXF1aXJlKFwiLi9Db21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsV2lyZV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsV2lyZVwiKTtcbmNsYXNzIEdyYXBoaWNhbE11bHRpcGxleGVyIGV4dGVuZHMgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG51bUluQ2hhbm5lbHMsIG51bU91dEJpdHMsIGRldGFpbGVkID0gZmFsc2UsIHdpcmVEaXN0ID0gR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9ESVNUQU5DRSwgb3ZlcnJpZGVIZWlnaHQsIG1pcnJvckNvbm5lY3RvcnMgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihuYW1lLCBHcmFwaGljYWxNdWx0aXBsZXhlci5pbnB1dENoYW5uZWxCYXNlKG51bU91dEJpdHMsIG51bUluQ2hhbm5lbHMsIHdpcmVEaXN0KSArIG51bU91dEJpdHMgKiB3aXJlRGlzdCwgZGV0YWlsZWQpO1xuICAgICAgICB0aGlzLm51bUluQ2hhbm5lbHMgPSBudW1JbkNoYW5uZWxzO1xuICAgICAgICB0aGlzLm51bU91dEJpdHMgPSBudW1PdXRCaXRzO1xuICAgICAgICB0aGlzLndpcmVEaXN0ID0gd2lyZURpc3Q7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVIZWlnaHQgPSBvdmVycmlkZUhlaWdodDtcbiAgICAgICAgdGhpcy5taXJyb3JDb25uZWN0b3JzID0gbWlycm9yQ29ubmVjdG9ycztcbiAgICAgICAgY29uc3QgZWxlbURpc3QgPSBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0U7XG4gICAgICAgIGxldCBlbGVtZW50cyA9IFtdO1xuICAgICAgICBsZXQgd2lkdGggPSBHcmFwaGljYWxNdWx0aXBsZXhlci5vdXRwdXRCaXRCYXNlKG51bUluQ2hhbm5lbHMsIG51bU91dEJpdHMsIHdpcmVEaXN0KTtcbiAgICAgICAgbGV0IG91dHB1dFNwbGl0WCA9IHdpZHRoO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG51bUluQ2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgICAgbGV0IGJhc2VZID0gR3JhcGhpY2FsTXVsdGlwbGV4ZXIuaW5wdXRDaGFubmVsQmFzZShudW1PdXRCaXRzLCBjLCB3aXJlRGlzdCk7XG4gICAgICAgICAgICBsZXQgZW5hYmxlU3BsaXRZID0gYmFzZVkgKyBudW1PdXRCaXRzICogd2lyZURpc3Q7XG4gICAgICAgICAgICBsZXQgZW5hYmxlU3BsaXQgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGFuZFkgPSBiYXNlWSArIChudW1PdXRCaXRzICsgMSkgKiB3aXJlRGlzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT3V0Qml0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHkgPSBiYXNlWSArIChudW1PdXRCaXRzIC0gaSAtIDEpICogd2lyZURpc3Q7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0SW5kZXggPSBjICogKG51bU91dEJpdHMgKyAxKSArIGk7XG4gICAgICAgICAgICAgICAgbGV0IGFuZCA9IGBhbmRfJHtjfV8ke2l9YDtcbiAgICAgICAgICAgICAgICBsZXQgYW5kWCA9IEdyYXBoaWNhbE11bHRpcGxleGVyLm91dHB1dEJpdEJhc2UobnVtSW5DaGFubmVscywgaSwgd2lyZURpc3QpICsgMiAqIGVsZW1EaXN0O1xuICAgICAgICAgICAgICAgIGxldCBvciA9IGBvcl8ke2l9YDtcbiAgICAgICAgICAgICAgICBsZXQgd2lyZURlbHRhID0gZWxlbURpc3QgKyBjICogd2lyZURpc3Q7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChgJHthbmR9IGFuZCBAJHthbmRYfToke2FuZFl9ID5uOnB+bi0ke3dpcmVEZWx0YX06bn4ke29yfWApO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYGlucHV0X3NwbGl0JHtjfV8ke2l9IHNwbGl0IEAwOiR7eX0gPCR7aW5wdXRJbmRleH0gPm46cH5uLSR7ZWxlbURpc3R9Om5+JHthbmR9L2kwYCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5hYmxlSW5wdXRJbmRleCA9IChjICsgMSkgKiAobnVtT3V0Qml0cyArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlU3BsaXQgPSBgZW5hYmxlX3NwbGl0JHtjfSBzcGxpdCBAMDoke2VuYWJsZVNwbGl0WX0gPCR7ZW5hYmxlSW5wdXRJbmRleH0gPnA6bn4ke2FuZH0vaTFgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoaSArIDEpIDwgbnVtT3V0Qml0cykge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVTcGxpdCArPSBgID5lbmFibGVfc3BsaXQke2N9XyR7aX1gO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVuYWJsZVNwbGl0KTtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlU3BsaXQgPSBgZW5hYmxlX3NwbGl0JHtjfV8ke2l9IHNwbGl0IEAke2FuZH0vaTEtJHsyICogZWxlbURpc3R9OiR7ZW5hYmxlU3BsaXRZfSA+cDpufiR7YW5kfS9pMWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVTcGxpdCArPSBgID5uOnB+bi0kezIgKiBlbGVtRGlzdH06bn4ke2FuZH0vaTFgO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVuYWJsZVNwbGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChjICsgMSkgPj0gbnVtSW5DaGFubmVscykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0U3BsaXQgPSBgb3V0cHV0X3NwbGl0JHtpfWA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXRTcGxpdFkgPSBhbmRZICsgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCArIChudW1PdXRCaXRzIC0gaSAtIDEpICogd2lyZURpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYCR7b3V0cHV0U3BsaXR9IHNwbGl0IEAke291dHB1dFNwbGl0WH06JHtvdXRwdXRTcGxpdFl9IDA+PmApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3JYID0gYW5kWCArIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgoR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCkgKyAyICogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFICsgKG51bUluQ2hhbm5lbHMgLSAxKSAqIHdpcmVEaXN0O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGAke29yfSBvciBAJHtvclh9OiR7YW5kWX0gPnArJHtlbGVtRGlzdH06cH5wOm5+JHtvdXRwdXRTcGxpdH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aXJpbmdEZXNjcmlwdGlvbnMgPSBHcmFtbWFyUGFyc2VyXzEuR3JhbW1hclBhcnNlci5wYXJzZShlbGVtZW50cykud2lyaW5nRGVzY3JpcHRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgaW5wdXRDaGFubmVsQmFzZShudW1PdXRCaXRzLCBpbnB1dENoYW5uZWxJbmRleCwgd2lyZURpc3QpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0Q2hhbm5lbEluZGV4ICogKChudW1PdXRCaXRzICsgMikgKiB3aXJlRGlzdCArIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgIH1cbiAgICBzdGF0aWMgb3V0cHV0Qml0QmFzZShudW1JbkNoYW5uZWxzLCBvdXRwdXRCaXRJbmRleCwgd2lyZURpc3QpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dEJpdEluZGV4ICogKDIgKiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UgKyBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldFdpZHRoKEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpICsgMiAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSArIE1hdGgubWF4KDAsIG51bUluQ2hhbm5lbHMgLSAxKSAqIHdpcmVEaXN0ICsgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKSArIDIgKiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UpO1xuICAgIH1cbiAgICBtYWtlRGVmYXVsdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcnJpZGVIZWlnaHQgIT09IHVuZGVmaW5lZCA/IHRoaXMub3ZlcnJpZGVIZWlnaHQgOiAodGhpcy5udW1JbkNoYW5uZWxzICogKHRoaXMubnVtT3V0Qml0cyArIDEpICsgMikgKiB0aGlzLndpcmVEaXN0O1xuICAgIH1cbiAgICBtYWtlV2lyaW5nRGVzY3JpcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJpbmdEZXNjcmlwdGlvbnM7XG4gICAgfVxuICAgIG1ha2VDb25uZWN0b3JDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZWxlbWVudEhlaWdodDtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMubWFrZURlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgoc2NhbGUgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKTtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldExpbmVXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICByZXR1cm4gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5tYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMubnVtSW5DaGFubmVscyAqICh0aGlzLm51bU91dEJpdHMgKyAxKSwgdGhpcy5udW1PdXRCaXRzLCB0aGlzLm1pcnJvckNvbm5lY3RvcnMpO1xuICAgIH1cbiAgICBtYWtlQmFzZUNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlc1swXTtcbiAgICB9XG4gICAgbWFrZUdyYXBoaWNzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGxldCBzY2FsZSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLm1ha2VEZWZhdWx0SGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VHcmFwaGljcyh0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgXCJNWFwiLCBzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgIH1cbiAgICBvbkVsZW1lbnQoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICB9XG4gICAgZG9SZWRyYXcocHJvZ3Jlc3MpIHtcbiAgICAgICAgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5yZWRyYXcodGhpcy5ncmFwaGljcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMubGluZVdpZHRoLCBHcmFwaGljYWxEZWNvZGVyLkNPTVBBQ1RfQ09MT1IpO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhcGhpY2FsTXVsdGlwbGV4ZXIgPSBHcmFwaGljYWxNdWx0aXBsZXhlcjtcbnZhciBHcmFwaGljYWxEZWNvZGVyO1xuKGZ1bmN0aW9uIChHcmFwaGljYWxEZWNvZGVyKSB7XG4gICAgR3JhcGhpY2FsRGVjb2Rlci5DT01QQUNUX0NPTE9SID0gMHgwMDAwMDA7XG59KShHcmFwaGljYWxEZWNvZGVyID0gZXhwb3J0cy5HcmFwaGljYWxEZWNvZGVyIHx8IChleHBvcnRzLkdyYXBoaWNhbERlY29kZXIgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY2FsTXVsdGlwbGV4ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalMultiplexer.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalNor.js":
/*!*****************************************!*\
  !*** ./out/js/graphics/GraphicalNor.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Nor_1 = __webpack_require__(/*! ../elements/Nor */ \"./out/js/elements/Nor.js\");\nconst StubGraphicalElement_1 = __webpack_require__(/*! ./StubGraphicalElement */ \"./out/js/graphics/StubGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nclass GraphicalNor extends StubGraphicalElement_1.StubGraphicalElement {\n    constructor(name, numInputs, initialValue = false, defaultHeight = GraphicalNor.DEFAULT_HEIGHT, mirrorConnectors = false) {\n        super(name);\n        this.numInputs = numInputs;\n        this.initialValue = initialValue;\n        this.defaultHeight = defaultHeight;\n        this.mirrorConnectors = mirrorConnectors;\n    }\n    getDefaultHeight() {\n        return this.defaultHeight;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        let scale = elementHeight / this.getDefaultHeight();\n        this.height = elementHeight;\n        this.orWidth = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalNor.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalNor.DEFAULT_HEIGHT);\n        this.notRadius = scale * GraphicalNor.DEFAULT_HEIGHT / 12;\n        this.orX = this.mirrorConnectors ? 2 * this.notRadius : 0;\n        this.notCenterX = (this.mirrorConnectors ? 0 : this.orWidth) + this.notRadius;\n        this.notCenterY = this.height / 2;\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.orWidth + 2 * this.notRadius, this.height, this.numInputs, 1, this.mirrorConnectors);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeElement(elementHeight, coordinates) {\n        let element = new Nor_1.Nor(this.getName(), this.numInputs, this.initialValue, GraphicalNor.ADDITIONAL_DELAY);\n        return element;\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.outputValueReader = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(0)());\n        let scale = elementHeight / this.getDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.orWidth, undefined, scale * GraphicalNor.DEFAULT_HEIGHT, this.orX);\n    }\n    redraw(progress) {\n        let value = this.outputValueReader();\n        this.graphics.clear();\n        this.graphics.lineStyle(this.lineWidth, value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR, 1);\n        this.graphics.drawRect(this.orX, 0, this.orWidth, this.height);\n        this.graphics.drawCircle(this.notCenterX, this.notCenterY, this.notRadius);\n    }\n}\nexports.GraphicalNor = GraphicalNor;\n(function (GraphicalNor) {\n    GraphicalNor.DEFAULT_HEIGHT = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT;\n    GraphicalNor.DEFAULT_WIDTH = GraphicalOr_1.GraphicalOr.getWidth(GraphicalNor.DEFAULT_HEIGHT) + Math.floor(GraphicalNor.DEFAULT_HEIGHT / 6);\n    GraphicalNor.ADDITIONAL_DELAY = 0;\n})(GraphicalNor = exports.GraphicalNor || (exports.GraphicalNor = {}));\n//# sourceMappingURL=GraphicalNor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsTm9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbE5vci5qcz9jYzNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTm9yXzEgPSByZXF1aXJlKFwiLi4vZWxlbWVudHMvTm9yXCIpO1xuY29uc3QgU3R1YkdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL1N0dWJHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY29uc3QgR3JhcGhpY2FsV2lyZV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsV2lyZVwiKTtcbmNsYXNzIEdyYXBoaWNhbE5vciBleHRlbmRzIFN0dWJHcmFwaGljYWxFbGVtZW50XzEuU3R1YkdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG51bUlucHV0cywgaW5pdGlhbFZhbHVlID0gZmFsc2UsIGRlZmF1bHRIZWlnaHQgPSBHcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQsIG1pcnJvckNvbm5lY3RvcnMgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy5udW1JbnB1dHMgPSBudW1JbnB1dHM7XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRIZWlnaHQgPSBkZWZhdWx0SGVpZ2h0O1xuICAgICAgICB0aGlzLm1pcnJvckNvbm5lY3RvcnMgPSBtaXJyb3JDb25uZWN0b3JzO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0SGVpZ2h0O1xuICAgIH1cbiAgICBtYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCkge1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5nZXREZWZhdWx0SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZWxlbWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5vcldpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE5vci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRMaW5lV2lkdGgoc2NhbGUgKiBHcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICB0aGlzLm5vdFJhZGl1cyA9IHNjYWxlICogR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUIC8gMTI7XG4gICAgICAgIHRoaXMub3JYID0gdGhpcy5taXJyb3JDb25uZWN0b3JzID8gMiAqIHRoaXMubm90UmFkaXVzIDogMDtcbiAgICAgICAgdGhpcy5ub3RDZW50ZXJYID0gKHRoaXMubWlycm9yQ29ubmVjdG9ycyA/IDAgOiB0aGlzLm9yV2lkdGgpICsgdGhpcy5ub3RSYWRpdXM7XG4gICAgICAgIHRoaXMubm90Q2VudGVyWSA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKHRoaXMub3JXaWR0aCArIDIgKiB0aGlzLm5vdFJhZGl1cywgdGhpcy5oZWlnaHQsIHRoaXMubnVtSW5wdXRzLCAxLCB0aGlzLm1pcnJvckNvbm5lY3RvcnMpO1xuICAgIH1cbiAgICBtYWtlQmFzZUNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlc1swXTtcbiAgICB9XG4gICAgbWFrZUVsZW1lbnQoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBuZXcgTm9yXzEuTm9yKHRoaXMuZ2V0TmFtZSgpLCB0aGlzLm51bUlucHV0cywgdGhpcy5pbml0aWFsVmFsdWUsIEdyYXBoaWNhbE5vci5BRERJVElPTkFMX0RFTEFZKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIG1ha2VHcmFwaGljcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcywgZGF0YVNvdXJjZSkge1xuICAgICAgICB0aGlzLm91dHB1dFZhbHVlUmVhZGVyID0gZGF0YVNvdXJjZS5nZXRBZGRyZXNzVmFsdWVSZWFkZXIodGhpcy5lbGVtZW50LmdldE91dHB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVyKDApKCkpO1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5nZXREZWZhdWx0SGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VHcmFwaGljcyh0aGlzLmhlaWdodCwgdGhpcy5vcldpZHRoLCB1bmRlZmluZWQsIHNjYWxlICogR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hULCB0aGlzLm9yWCk7XG4gICAgfVxuICAgIHJlZHJhdyhwcm9ncmVzcykge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLm91dHB1dFZhbHVlUmVhZGVyKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lU3R5bGUodGhpcy5saW5lV2lkdGgsIHZhbHVlID8gR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuSElHSF9DT0xPUiA6IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkxPV19DT0xPUiwgMSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QodGhpcy5vclgsIDAsIHRoaXMub3JXaWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXdDaXJjbGUodGhpcy5ub3RDZW50ZXJYLCB0aGlzLm5vdENlbnRlclksIHRoaXMubm90UmFkaXVzKTtcbiAgICB9XG59XG5leHBvcnRzLkdyYXBoaWNhbE5vciA9IEdyYXBoaWNhbE5vcjtcbihmdW5jdGlvbiAoR3JhcGhpY2FsTm9yKSB7XG4gICAgR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVDtcbiAgICBHcmFwaGljYWxOb3IuREVGQVVMVF9XSURUSCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0V2lkdGgoR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUKSArIE1hdGguZmxvb3IoR3JhcGhpY2FsTm9yLkRFRkFVTFRfSEVJR0hUIC8gNik7XG4gICAgR3JhcGhpY2FsTm9yLkFERElUSU9OQUxfREVMQVkgPSAwO1xufSkoR3JhcGhpY2FsTm9yID0gZXhwb3J0cy5HcmFwaGljYWxOb3IgfHwgKGV4cG9ydHMuR3JhcGhpY2FsTm9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbE5vci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalNor.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalOr.js":
/*!****************************************!*\
  !*** ./out/js/graphics/GraphicalOr.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalNor_1 = __webpack_require__(/*! ./GraphicalNor */ \"./out/js/graphics/GraphicalNor.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nclass GraphicalOr extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, numInputs, detailed = false, defaultHeight = GraphicalOr.DEFAULT_HEIGHT, mirrorConnectors = false, initialValue = false) {\n        super(name, GraphicalNor_1.GraphicalNor.DEFAULT_HEIGHT, detailed);\n        this.numInputs = numInputs;\n        this.defaultHeight = defaultHeight;\n        this.mirrorConnectors = mirrorConnectors;\n        this.initialValue = initialValue;\n    }\n    static getWidth(height) {\n        return Math.floor(3 * height / 4);\n    }\n    static getLineWidth(height) {\n        return Math.ceil(height / 24);\n    }\n    static makeConnectorCoordinates(width, height, numInputs, numOutputs = 1, mirrorConnectors = false) {\n        let inputCoordinates = new Array(numInputs);\n        for (let i = 0; i < inputCoordinates.length; i++) {\n            inputCoordinates[i] = {\n                x: mirrorConnectors ? width : 0,\n                y: (i + 1) * height / (inputCoordinates.length + 1)\n            };\n        }\n        let outputCoordinates = new Array(numOutputs);\n        for (let i = 0; i < outputCoordinates.length; i++) {\n            outputCoordinates[i] = {\n                x: mirrorConnectors ? 0 : width,\n                y: (i + 1) * height / (outputCoordinates.length + 1)\n            };\n        }\n        return {\n            input: inputCoordinates,\n            output: outputCoordinates\n        };\n    }\n    static makeGraphics(height, width, desc = \"≥1\", textSizeReferenceHeight = undefined, textLeftOffset = 0) {\n        let graphics = new PIXI.Graphics();\n        if (desc) {\n            if (textSizeReferenceHeight === undefined) {\n                textSizeReferenceHeight = height;\n            }\n            let text = new PIXI.Text(desc, {\n                fontSize: 2 * textSizeReferenceHeight / 5,\n                fontFamily: \"Arial\",\n                fill: GraphicalOr.TEXT_COLOR\n            });\n            text.anchor.set(0.5, 0.5);\n            text.x = width / 2 + textLeftOffset;\n            text.y = height / 2;\n            graphics.addChild(text);\n        }\n        return graphics;\n    }\n    static redraw(graphics, width, height, lineWidth, color) {\n        graphics.clear();\n        graphics.lineStyle(lineWidth, color, 1);\n        graphics.drawRect(0, 0, width, height);\n    }\n    makeDefaultHeight() {\n        return this.defaultHeight;\n    }\n    makeWiringDescriptions() {\n        let nor1Inputs = new Array(this.numInputs);\n        for (let i = 0; i < nor1Inputs.length; i++) {\n            nor1Inputs[i] = {\n                name: \"outside\",\n                outputIndex: i\n            };\n        }\n        return [\n            {\n                name: \"nor1\",\n                element: new GraphicalNor_1.GraphicalNor(\"nor1\", this.numInputs, !this.initialValue),\n                height: \"auto\",\n                inputs: nor1Inputs,\n                externalOutputs: [],\n                coordinates: [\n                    {\n                        x: 0,\n                        y: 0\n                    }\n                ]\n            }, {\n                name: \"nor2\",\n                element: new GraphicalNor_1.GraphicalNor(\"nor2\", 1, this.initialValue),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"wire\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [0],\n                coordinates: [\n                    {\n                        x: {\n                            delta: 20,\n                            from: {\n                                name: \"nor1\",\n                                connector: \"output\",\n                                index: 0\n                            }\n                        },\n                        y: 0\n                    }\n                ]\n            }, {\n                name: \"wire\",\n                element: new GraphicalWire_1.GraphicalWire(\"wire\", !this.initialValue),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"nor1\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [],\n                coordinates: [\n                    {\n                        name: \"nor1\",\n                        connector: \"output\",\n                        index: 0\n                    },\n                    {\n                        name: \"nor2\",\n                        connector: \"input\",\n                        index: 0\n                    }\n                ]\n            }\n        ];\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.makeDefaultHeight();\n        this.width = GraphicalOr.getWidth(scale * GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr.getLineWidth(scale * GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr.makeConnectorCoordinates(this.width, this.height, this.numInputs, 1, this.mirrorConnectors);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.outputValueReader = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(0)());\n        let scale = elementHeight / this.makeDefaultHeight();\n        return GraphicalOr.makeGraphics(this.height, this.width, undefined, scale * GraphicalOr.DEFAULT_HEIGHT);\n    }\n    doRedraw(progress) {\n        let value = this.outputValueReader();\n        GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR);\n    }\n}\nexports.GraphicalOr = GraphicalOr;\n(function (GraphicalOr) {\n    GraphicalOr.DEFAULT_HEIGHT = 36;\n    GraphicalOr.DEFAULT_ELEMENT_SPACE = 4;\n    GraphicalOr.TEXT_COLOR = 0x000000;\n})(GraphicalOr = exports.GraphicalOr || (exports.GraphicalOr = {}));\n//# sourceMappingURL=GraphicalOr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsT3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsT3IuanM/ZDQ0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0NvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRcIik7XG5jb25zdCBHcmFwaGljYWxOb3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE5vclwiKTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jbGFzcyBHcmFwaGljYWxPciBleHRlbmRzIENvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMS5Db21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBudW1JbnB1dHMsIGRldGFpbGVkID0gZmFsc2UsIGRlZmF1bHRIZWlnaHQgPSBHcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCwgbWlycm9yQ29ubmVjdG9ycyA9IGZhbHNlLCBpbml0aWFsVmFsdWUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihuYW1lLCBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IuREVGQVVMVF9IRUlHSFQsIGRldGFpbGVkKTtcbiAgICAgICAgdGhpcy5udW1JbnB1dHMgPSBudW1JbnB1dHM7XG4gICAgICAgIHRoaXMuZGVmYXVsdEhlaWdodCA9IGRlZmF1bHRIZWlnaHQ7XG4gICAgICAgIHRoaXMubWlycm9yQ29ubmVjdG9ycyA9IG1pcnJvckNvbm5lY3RvcnM7XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0V2lkdGgoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKDMgKiBoZWlnaHQgLyA0KTtcbiAgICB9XG4gICAgc3RhdGljIGdldExpbmVXaWR0aChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChoZWlnaHQgLyAyNCk7XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXMod2lkdGgsIGhlaWdodCwgbnVtSW5wdXRzLCBudW1PdXRwdXRzID0gMSwgbWlycm9yQ29ubmVjdG9ycyA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpbnB1dENvb3JkaW5hdGVzID0gbmV3IEFycmF5KG51bUlucHV0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5wdXRDb29yZGluYXRlc1tpXSA9IHtcbiAgICAgICAgICAgICAgICB4OiBtaXJyb3JDb25uZWN0b3JzID8gd2lkdGggOiAwLFxuICAgICAgICAgICAgICAgIHk6IChpICsgMSkgKiBoZWlnaHQgLyAoaW5wdXRDb29yZGluYXRlcy5sZW5ndGggKyAxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkobnVtT3V0cHV0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dENvb3JkaW5hdGVzW2ldID0ge1xuICAgICAgICAgICAgICAgIHg6IG1pcnJvckNvbm5lY3RvcnMgPyAwIDogd2lkdGgsXG4gICAgICAgICAgICAgICAgeTogKGkgKyAxKSAqIGhlaWdodCAvIChvdXRwdXRDb29yZGluYXRlcy5sZW5ndGggKyAxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dENvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlR3JhcGhpY3MoaGVpZ2h0LCB3aWR0aCwgZGVzYyA9IFwi4omlMVwiLCB0ZXh0U2l6ZVJlZmVyZW5jZUhlaWdodCA9IHVuZGVmaW5lZCwgdGV4dExlZnRPZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBncmFwaGljcyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgICBpZiAodGV4dFNpemVSZWZlcmVuY2VIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRleHRTaXplUmVmZXJlbmNlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRleHQgPSBuZXcgUElYSS5UZXh0KGRlc2MsIHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMiAqIHRleHRTaXplUmVmZXJlbmNlSGVpZ2h0IC8gNSxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gICAgICAgICAgICAgICAgZmlsbDogR3JhcGhpY2FsT3IuVEVYVF9DT0xPUlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0ZXh0LmFuY2hvci5zZXQoMC41LCAwLjUpO1xuICAgICAgICAgICAgdGV4dC54ID0gd2lkdGggLyAyICsgdGV4dExlZnRPZmZzZXQ7XG4gICAgICAgICAgICB0ZXh0LnkgPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgZ3JhcGhpY3MuYWRkQ2hpbGQodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoaWNzO1xuICAgIH1cbiAgICBzdGF0aWMgcmVkcmF3KGdyYXBoaWNzLCB3aWR0aCwgaGVpZ2h0LCBsaW5lV2lkdGgsIGNvbG9yKSB7XG4gICAgICAgIGdyYXBoaWNzLmNsZWFyKCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZShsaW5lV2lkdGgsIGNvbG9yLCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIG1ha2VEZWZhdWx0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0SGVpZ2h0O1xuICAgIH1cbiAgICBtYWtlV2lyaW5nRGVzY3JpcHRpb25zKCkge1xuICAgICAgICBsZXQgbm9yMUlucHV0cyA9IG5ldyBBcnJheSh0aGlzLm51bUlucHV0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9yMUlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbm9yMUlucHV0c1tpXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm91dHNpZGVcIixcbiAgICAgICAgICAgICAgICBvdXRwdXRJbmRleDogaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwibm9yMVwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IoXCJub3IxXCIsIHRoaXMubnVtSW5wdXRzLCAhdGhpcy5pbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBub3IxSW5wdXRzLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm5vcjJcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yKFwibm9yMlwiLCAxLCB0aGlzLmluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ3aXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRJbmRleDogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFswXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IDIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJub3IxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogXCJvdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwid2lyZVwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZShcIndpcmVcIiwgIXRoaXMuaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm5vcjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJub3IxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3I6IFwib3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm5vcjJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50SGVpZ2h0O1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5tYWtlRGVmYXVsdEhlaWdodCgpO1xuICAgICAgICB0aGlzLndpZHRoID0gR3JhcGhpY2FsT3IuZ2V0V2lkdGgoc2NhbGUgKiBHcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gR3JhcGhpY2FsT3IuZ2V0TGluZVdpZHRoKHNjYWxlICogR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICByZXR1cm4gR3JhcGhpY2FsT3IubWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLm51bUlucHV0cywgMSwgdGhpcy5taXJyb3JDb25uZWN0b3JzKTtcbiAgICB9XG4gICAgbWFrZUJhc2VDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF07XG4gICAgfVxuICAgIG9uRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRWYWx1ZVJlYWRlciA9IGRhdGFTb3VyY2UuZ2V0QWRkcmVzc1ZhbHVlUmVhZGVyKHRoaXMuZWxlbWVudC5nZXRPdXRwdXRWYWx1ZUFkZHJlc3NQcm92aWRlcigwKSgpKTtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMubWFrZURlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yLm1ha2VHcmFwaGljcyh0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdW5kZWZpbmVkLCBzY2FsZSAqIEdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKTtcbiAgICB9XG4gICAgZG9SZWRyYXcocHJvZ3Jlc3MpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5vdXRwdXRWYWx1ZVJlYWRlcigpO1xuICAgICAgICBHcmFwaGljYWxPci5yZWRyYXcodGhpcy5ncmFwaGljcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMubGluZVdpZHRoLCB2YWx1ZSA/IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkhJR0hfQ09MT1IgOiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5MT1dfQ09MT1IpO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhcGhpY2FsT3IgPSBHcmFwaGljYWxPcjtcbihmdW5jdGlvbiAoR3JhcGhpY2FsT3IpIHtcbiAgICBHcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCA9IDM2O1xuICAgIEdyYXBoaWNhbE9yLkRFRkFVTFRfRUxFTUVOVF9TUEFDRSA9IDQ7XG4gICAgR3JhcGhpY2FsT3IuVEVYVF9DT0xPUiA9IDB4MDAwMDAwO1xufSkoR3JhcGhpY2FsT3IgPSBleHBvcnRzLkdyYXBoaWNhbE9yIHx8IChleHBvcnRzLkdyYXBoaWNhbE9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbE9yLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalOr.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalRSFlipFlop.js":
/*!************************************************!*\
  !*** ./out/js/graphics/GraphicalRSFlipFlop.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CombinedGraphicalElement_1 = __webpack_require__(/*! ./CombinedGraphicalElement */ \"./out/js/graphics/CombinedGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalNor_1 = __webpack_require__(/*! ./GraphicalNor */ \"./out/js/graphics/GraphicalNor.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GraphicalSplit_1 = __webpack_require__(/*! ./GraphicalSplit */ \"./out/js/graphics/GraphicalSplit.js\");\nclass GraphicalRSFlipFlop extends CombinedGraphicalElement_1.CombinedGraphicalElement {\n    constructor(name, initialValue = false) {\n        super(name, 180, [\n            {\n                name: \"R_nor\",\n                element: new GraphicalNor_1.GraphicalNor(\"R_nor\", 2, initialValue),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"outside\",\n                        outputIndex: 0\n                    },\n                    {\n                        name: \"S_to_R_loop\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [],\n                coordinates: [\n                    {\n                        x: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                        y: 0\n                    }\n                ]\n            },\n            {\n                name: \"R_out_split\",\n                element: new GraphicalSplit_1.GraphicalSplit(\"R_out_split\", 2, 1),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"R_nor_out_wire\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [1],\n                coordinates: [\n                    {\n                        x: {\n                            delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                            from: {\n                                name: \"R_nor\",\n                                connector: \"output\",\n                                index: 0\n                            },\n                        },\n                        y: {\n                            name: \"R_nor\",\n                            connector: \"output\",\n                            index: 0\n                        }\n                    }\n                ]\n            },\n            {\n                name: \"S_nor\",\n                element: new GraphicalNor_1.GraphicalNor(\"S_nor\", 2, !initialValue),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"R_to_S_loop\",\n                        outputIndex: 0\n                    },\n                    {\n                        name: \"outside\",\n                        outputIndex: 1\n                    }\n                ],\n                externalOutputs: [],\n                coordinates: [\n                    {\n                        x: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                        y: 2 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT\n                    }\n                ]\n            },\n            {\n                name: \"S_out_split\",\n                element: new GraphicalSplit_1.GraphicalSplit(\"S_out_split\", 2, 1),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"S_nor_out_wire\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [1],\n                coordinates: [\n                    {\n                        x: {\n                            delta: GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE,\n                            from: {\n                                name: \"S_nor\",\n                                connector: \"output\",\n                                index: 0\n                            },\n                        },\n                        y: {\n                            name: \"S_nor\",\n                            connector: \"output\",\n                            index: 0\n                        }\n                    }\n                ]\n            },\n            {\n                name: \"R_nor_out_wire\",\n                element: new GraphicalWire_1.GraphicalWire(\"R_nor_out_wire\", initialValue),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"R_nor\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [],\n                coordinates: [\n                    {\n                        name: \"R_nor\",\n                        connector: \"output\",\n                        index: 0\n                    },\n                    {\n                        name: \"R_out_split\",\n                        connector: \"input\",\n                        index: 0\n                    }\n                ]\n            },\n            {\n                name: \"S_nor_out_wire\",\n                element: new GraphicalWire_1.GraphicalWire(\"S_nor_out_wire0\", !initialValue),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"S_nor\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [],\n                coordinates: [\n                    {\n                        name: \"S_nor\",\n                        connector: \"output\",\n                        index: 0\n                    },\n                    {\n                        name: \"S_out_split\",\n                        connector: \"input\",\n                        index: 0\n                    }\n                ]\n            },\n            {\n                name: \"R_to_S_loop\",\n                element: new GraphicalWire_1.GraphicalWire(\"R_to_S_loop\", initialValue),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"R_out_split\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [],\n                coordinates: [\n                    {\n                        name: \"R_out_split\",\n                        connector: \"output\",\n                        index: 0\n                    },\n                    {\n                        x: \"prev\",\n                        y: GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT\n                    },\n                    {\n                        x: \"next\",\n                        y: 2 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT\n                    },\n                    {\n                        x: 0,\n                        y: \"next\"\n                    },\n                    {\n                        name: \"S_nor\",\n                        connector: \"input\",\n                        index: 0\n                    }\n                ]\n            },\n            {\n                name: \"S_to_R_loop\",\n                element: new GraphicalWire_1.GraphicalWire(\"S_to_R_loop\", !initialValue),\n                height: \"auto\",\n                inputs: [\n                    {\n                        name: \"S_out_split\",\n                        outputIndex: 0\n                    }\n                ],\n                externalOutputs: [],\n                coordinates: [\n                    {\n                        name: \"S_out_split\",\n                        connector: \"output\",\n                        index: 0\n                    },\n                    {\n                        x: \"prev\",\n                        y: 2 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT\n                    },\n                    {\n                        x: \"next\",\n                        y: GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT\n                    },\n                    {\n                        x: 0,\n                        y: \"next\"\n                    },\n                    {\n                        name: \"R_nor\",\n                        connector: \"input\",\n                        index: 1\n                    }\n                ]\n            }\n        ]);\n    }\n}\nexports.GraphicalRSFlipFlop = GraphicalRSFlipFlop;\n//# sourceMappingURL=GraphicalRSFlipFlop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsUlNGbGlwRmxvcC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxSU0ZsaXBGbG9wLmpzPzUxZjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL0NvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbE9yXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxPclwiKTtcbmNvbnN0IEdyYXBoaWNhbE5vcl8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsTm9yXCIpO1xuY29uc3QgR3JhcGhpY2FsV2lyZV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsV2lyZVwiKTtcbmNvbnN0IEdyYXBoaWNhbFNwbGl0XzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxTcGxpdFwiKTtcbmNsYXNzIEdyYXBoaWNhbFJTRmxpcEZsb3AgZXh0ZW5kcyBDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnRfMS5Db21iaW5lZEdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluaXRpYWxWYWx1ZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIDE4MCwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiUl9ub3JcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsTm9yXzEuR3JhcGhpY2FsTm9yKFwiUl9ub3JcIiwgMiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm91dHNpZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU190b19SX2xvb3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlJfb3V0X3NwbGl0XCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbFNwbGl0XzEuR3JhcGhpY2FsU3BsaXQoXCJSX291dF9zcGxpdFwiLCAyLCAxKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJfbm9yX291dF93aXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRJbmRleDogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFsxXSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUl9ub3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yOiBcIm91dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUl9ub3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3I6IFwib3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJTX25vclwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxOb3JfMS5HcmFwaGljYWxOb3IoXCJTX25vclwiLCAyLCAhaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJfdG9fU19sb29wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRJbmRleDogMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm91dHNpZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiAxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9FTEVNRU5UX0RJU1RBTkNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMiAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJTX291dF9zcGxpdFwiLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBHcmFwaGljYWxTcGxpdF8xLkdyYXBoaWNhbFNwbGl0KFwiU19vdXRfc3BsaXRcIiwgMiwgMSksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTX25vcl9vdXRfd2lyZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0SW5kZXg6IDBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxPdXRwdXRzOiBbMV0sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNfbm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogXCJvdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNfbm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yOiBcIm91dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiUl9ub3Jfb3V0X3dpcmVcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJSX25vcl9vdXRfd2lyZVwiLCBpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUl9ub3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJSX25vclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yOiBcIm91dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJSX291dF9zcGxpdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yOiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlNfbm9yX291dF93aXJlXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlKFwiU19ub3Jfb3V0X3dpcmUwXCIsICFpbml0aWFsVmFsdWUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU19ub3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dEluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsT3V0cHV0czogW10sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTX25vclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yOiBcIm91dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTX291dF9zcGxpdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yOiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlJfdG9fU19sb29wXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbmV3IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlKFwiUl90b19TX2xvb3BcIiwgaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJfb3V0X3NwbGl0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRJbmRleDogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUl9vdXRfc3BsaXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogXCJvdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IFwicHJldlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBcIm5leHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDIgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBcIm5leHRcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNfbm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3I6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiU190b19SX2xvb3BcIixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUoXCJTX3RvX1JfbG9vcFwiLCAhaW5pdGlhbFZhbHVlKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNfb3V0X3NwbGl0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRJbmRleDogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU19vdXRfc3BsaXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogXCJvdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IFwicHJldlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMiAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogXCJuZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBcIm5leHRcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJfbm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3I6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhcGhpY2FsUlNGbGlwRmxvcCA9IEdyYXBoaWNhbFJTRmxpcEZsb3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljYWxSU0ZsaXBGbG9wLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalRSFlipFlop.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalRegister.js":
/*!**********************************************!*\
  !*** ./out/js/graphics/GraphicalRegister.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalDFlipFlop_1 = __webpack_require__(/*! ./GraphicalDFlipFlop */ \"./out/js/graphics/GraphicalDFlipFlop.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalRegister extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, numInBits, detailed = false, defaultHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT, mirrorConnectors = false, readOnly = false, initHex) {\n        super(name, numInBits * (GraphicalDFlipFlop_1.GraphicalDFlipFlop.DEFAULT_HEIGHT + 2 * GraphicalWire_1.GraphicalWire.DEFAULT_HEIGHT), detailed);\n        this.numInBits = numInBits;\n        this.defaultHeight = defaultHeight;\n        this.mirrorConnectors = mirrorConnectors;\n        this.readOnly = readOnly;\n        let initValues = new Array(numInBits);\n        initValues.fill(false);\n        if (initHex) {\n            let initialValue = parseInt(initHex, 16);\n            for (let i = 0; i < numInBits; i++) {\n                initValues[i] = !!(initialValue & 1);\n                initialValue >>= 1;\n            }\n        }\n        let elements = [];\n        for (let i = 0; i < numInBits; i++) {\n            let y = i * (GraphicalDFlipFlop_1.GraphicalDFlipFlop.DEFAULT_HEIGHT + 2 * GraphicalWire_1.GraphicalWire.DEFAULT_HEIGHT);\n            elements.push(`dff${i} dff init=${initValues[i]} @20:${y}` + (readOnly ? \"\" : ` 0<${i}`) + ((numInBits <= 1 && !readOnly) ? \" 1<1\" : \"\") + ` 0>>`);\n            if (readOnly) {\n                elements.push(`data_split${i} split init=false @10:dff${i}/i0 >dff${i}/i0`);\n            }\n            if (i > 0) {\n                elements.push(`split${i} split init=false @0:dff${i}/i1` + ((i >= (numInBits - 1) && !readOnly) ? ` <${numInBits}` : \"\") + ` >dff${i}` + ((i > 1) ? ` >split${i - 1}` : ` >p:n~dff0/i1`));\n            }\n        }\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    makeDefaultHeight() {\n        return this.defaultHeight;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.makeDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, this.numInBits + (this.readOnly ? 0 : 1), this.numInBits, this.mirrorConnectors);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeGraphics(elementHeight, coordinates) {\n        let scale = elementHeight / this.makeDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"RG\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    doRedraw(progress) {\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, GraphicalDecoder.COMPACT_COLOR);\n    }\n}\nexports.GraphicalRegister = GraphicalRegister;\nvar GraphicalDecoder;\n(function (GraphicalDecoder) {\n    GraphicalDecoder.COMPACT_COLOR = 0x000000;\n})(GraphicalDecoder = exports.GraphicalDecoder || (exports.GraphicalDecoder = {}));\n//# sourceMappingURL=GraphicalRegister.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsUmVnaXN0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsUmVnaXN0ZXIuanM/ZTVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFtbWFyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9HcmFtbWFyUGFyc2VyXCIpO1xuY29uc3QgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xID0gcmVxdWlyZShcIi4vQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbERGbGlwRmxvcF8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsREZsaXBGbG9wXCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsUmVnaXN0ZXIgZXh0ZW5kcyBDb21wYWN0Q29tYmluZWRHcmFwaGljYWxFbGVtZW50XzEuQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgbnVtSW5CaXRzLCBkZXRhaWxlZCA9IGZhbHNlLCBkZWZhdWx0SGVpZ2h0ID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCwgbWlycm9yQ29ubmVjdG9ycyA9IGZhbHNlLCByZWFkT25seSA9IGZhbHNlLCBpbml0SGV4KSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIG51bUluQml0cyAqIChHcmFwaGljYWxERmxpcEZsb3BfMS5HcmFwaGljYWxERmxpcEZsb3AuREVGQVVMVF9IRUlHSFQgKyAyICogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9IRUlHSFQpLCBkZXRhaWxlZCk7XG4gICAgICAgIHRoaXMubnVtSW5CaXRzID0gbnVtSW5CaXRzO1xuICAgICAgICB0aGlzLmRlZmF1bHRIZWlnaHQgPSBkZWZhdWx0SGVpZ2h0O1xuICAgICAgICB0aGlzLm1pcnJvckNvbm5lY3RvcnMgPSBtaXJyb3JDb25uZWN0b3JzO1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgIGxldCBpbml0VmFsdWVzID0gbmV3IEFycmF5KG51bUluQml0cyk7XG4gICAgICAgIGluaXRWYWx1ZXMuZmlsbChmYWxzZSk7XG4gICAgICAgIGlmIChpbml0SGV4KSB7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbFZhbHVlID0gcGFyc2VJbnQoaW5pdEhleCwgMTYpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbkJpdHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGluaXRWYWx1ZXNbaV0gPSAhIShpbml0aWFsVmFsdWUgJiAxKTtcbiAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWUgPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5CaXRzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB5ID0gaSAqIChHcmFwaGljYWxERmxpcEZsb3BfMS5HcmFwaGljYWxERmxpcEZsb3AuREVGQVVMVF9IRUlHSFQgKyAyICogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChgZGZmJHtpfSBkZmYgaW5pdD0ke2luaXRWYWx1ZXNbaV19IEAyMDoke3l9YCArIChyZWFkT25seSA/IFwiXCIgOiBgIDA8JHtpfWApICsgKChudW1JbkJpdHMgPD0gMSAmJiAhcmVhZE9ubHkpID8gXCIgMTwxXCIgOiBcIlwiKSArIGAgMD4+YCk7XG4gICAgICAgICAgICBpZiAocmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBkYXRhX3NwbGl0JHtpfSBzcGxpdCBpbml0PWZhbHNlIEAxMDpkZmYke2l9L2kwID5kZmYke2l9L2kwYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGBzcGxpdCR7aX0gc3BsaXQgaW5pdD1mYWxzZSBAMDpkZmYke2l9L2kxYCArICgoaSA+PSAobnVtSW5CaXRzIC0gMSkgJiYgIXJlYWRPbmx5KSA/IGAgPCR7bnVtSW5CaXRzfWAgOiBcIlwiKSArIGAgPmRmZiR7aX1gICsgKChpID4gMSkgPyBgID5zcGxpdCR7aSAtIDF9YCA6IGAgPnA6bn5kZmYwL2kxYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lyaW5nRGVzY3JpcHRpb25zID0gR3JhbW1hclBhcnNlcl8xLkdyYW1tYXJQYXJzZXIucGFyc2UoZWxlbWVudHMpLndpcmluZ0Rlc2NyaXB0aW9ucztcbiAgICB9XG4gICAgbWFrZURlZmF1bHRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRIZWlnaHQ7XG4gICAgfVxuICAgIG1ha2VXaXJpbmdEZXNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmluZ0Rlc2NyaXB0aW9ucztcbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50SGVpZ2h0O1xuICAgICAgICBsZXQgc2NhbGUgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5tYWtlRGVmYXVsdEhlaWdodCgpO1xuICAgICAgICB0aGlzLndpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRXaWR0aChzY2FsZSAqIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuREVGQVVMVF9IRUlHSFQpO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IuZ2V0TGluZVdpZHRoKHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VDb25uZWN0b3JDb29yZGluYXRlcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5udW1JbkJpdHMgKyAodGhpcy5yZWFkT25seSA/IDAgOiAxKSwgdGhpcy5udW1JbkJpdHMsIHRoaXMubWlycm9yQ29ubmVjdG9ycyk7XG4gICAgfVxuICAgIG1ha2VCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdO1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMubWFrZURlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUdyYXBoaWNzKHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCBcIlJHXCIsIHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgfVxuICAgIG9uRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgIH1cbiAgICBkb1JlZHJhdyhwcm9ncmVzcykge1xuICAgICAgICBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLnJlZHJhdyh0aGlzLmdyYXBoaWNzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5saW5lV2lkdGgsIEdyYXBoaWNhbERlY29kZXIuQ09NUEFDVF9DT0xPUik7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxSZWdpc3RlciA9IEdyYXBoaWNhbFJlZ2lzdGVyO1xudmFyIEdyYXBoaWNhbERlY29kZXI7XG4oZnVuY3Rpb24gKEdyYXBoaWNhbERlY29kZXIpIHtcbiAgICBHcmFwaGljYWxEZWNvZGVyLkNPTVBBQ1RfQ09MT1IgPSAweDAwMDAwMDtcbn0pKEdyYXBoaWNhbERlY29kZXIgPSBleHBvcnRzLkdyYXBoaWNhbERlY29kZXIgfHwgKGV4cG9ydHMuR3JhcGhpY2FsRGVjb2RlciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljYWxSZWdpc3Rlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalRegister.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalSinkTerminal.js":
/*!**************************************************!*\
  !*** ./out/js/graphics/GraphicalSinkTerminal.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SinkTerminal_1 = __webpack_require__(/*! ../elements/SinkTerminal */ \"./out/js/elements/SinkTerminal.js\");\nconst StubGraphicalElement_1 = __webpack_require__(/*! ./StubGraphicalElement */ \"./out/js/graphics/StubGraphicalElement.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nclass GraphicalSinkTerminal extends StubGraphicalElement_1.StubGraphicalElement {\n    constructor(name) {\n        super(name);\n    }\n    getDefaultHeight() {\n        return 20;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.radius = elementHeight / 2;\n        return {\n            input: [\n                {\n                    x: 0,\n                    y: 0\n                }\n            ],\n            output: []\n        };\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeElement(elementHeight, coordinates) {\n        return new SinkTerminal_1.SinkTerminal(this.getName(), (value) => {\n            this.value = value;\n        });\n    }\n    makeGraphics(elementHeight, coordinates) {\n        return new PIXI.Graphics();\n    }\n    redraw(progress) {\n        this.graphics.clear();\n        this.graphics.beginFill(this.value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR, 1);\n        this.graphics.drawCircle(0, 0, this.radius);\n    }\n}\nexports.GraphicalSinkTerminal = GraphicalSinkTerminal;\n//# sourceMappingURL=GraphicalSinkTerminal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsU2lua1Rlcm1pbmFsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbFNpbmtUZXJtaW5hbC5qcz84NjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2lua1Rlcm1pbmFsXzEgPSByZXF1aXJlKFwiLi4vZWxlbWVudHMvU2lua1Rlcm1pbmFsXCIpO1xuY29uc3QgU3R1YkdyYXBoaWNhbEVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL1N0dWJHcmFwaGljYWxFbGVtZW50XCIpO1xuY29uc3QgR3JhcGhpY2FsV2lyZV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY2FsV2lyZVwiKTtcbmNsYXNzIEdyYXBoaWNhbFNpbmtUZXJtaW5hbCBleHRlbmRzIFN0dWJHcmFwaGljYWxFbGVtZW50XzEuU3R1YkdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIobmFtZSk7XG4gICAgfVxuICAgIGdldERlZmF1bHRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiAyMDtcbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSBlbGVtZW50SGVpZ2h0IC8gMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG91dHB1dDogW11cbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZUJhc2VDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF07XG4gICAgfVxuICAgIG1ha2VFbGVtZW50KGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lua1Rlcm1pbmFsXzEuU2lua1Rlcm1pbmFsKHRoaXMuZ2V0TmFtZSgpLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VHcmFwaGljcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IFBJWEkuR3JhcGhpY3MoKTtcbiAgICB9XG4gICAgcmVkcmF3KHByb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwodGhpcy52YWx1ZSA/IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkhJR0hfQ09MT1IgOiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5MT1dfQ09MT1IsIDEpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXdDaXJjbGUoMCwgMCwgdGhpcy5yYWRpdXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhcGhpY2FsU2lua1Rlcm1pbmFsID0gR3JhcGhpY2FsU2lua1Rlcm1pbmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY2FsU2lua1Rlcm1pbmFsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalSinkTerminal.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalSourceTerminal.js":
/*!****************************************************!*\
  !*** ./out/js/graphics/GraphicalSourceTerminal.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SourceTerminal_1 = __webpack_require__(/*! ../elements/SourceTerminal */ \"./out/js/elements/SourceTerminal.js\");\nconst StubGraphicalElement_1 = __webpack_require__(/*! ./StubGraphicalElement */ \"./out/js/graphics/StubGraphicalElement.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nclass GraphicalSourceTerminal extends StubGraphicalElement_1.StubGraphicalElement {\n    constructor(name, value) {\n        super(name);\n        this.value = value;\n    }\n    getDefaultHeight() {\n        return 20;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.radius = elementHeight / 2;\n        return {\n            input: [],\n            output: [\n                {\n                    x: 0,\n                    y: 0\n                }\n            ]\n        };\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeElement(elementHeight, coordinates) {\n        return new SourceTerminal_1.SourceTerminal(this.getName(), () => this.value);\n    }\n    makeGraphics(elementHeight, coordinates) {\n        let graphics = new PIXI.Graphics();\n        graphics.interactive = true;\n        graphics.on(\"pointertap\", () => {\n            this.value = !this.value;\n        });\n        return graphics;\n    }\n    redraw(progress) {\n        this.graphics.clear();\n        this.graphics.beginFill(this.value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR, 1);\n        this.graphics.drawCircle(0, 0, this.radius);\n    }\n}\nexports.GraphicalSourceTerminal = GraphicalSourceTerminal;\n//# sourceMappingURL=GraphicalSourceTerminal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsU291cmNlVGVybWluYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsU291cmNlVGVybWluYWwuanM/Yjg5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNvdXJjZVRlcm1pbmFsXzEgPSByZXF1aXJlKFwiLi4vZWxlbWVudHMvU291cmNlVGVybWluYWxcIik7XG5jb25zdCBTdHViR3JhcGhpY2FsRWxlbWVudF8xID0gcmVxdWlyZShcIi4vU3R1YkdyYXBoaWNhbEVsZW1lbnRcIik7XG5jb25zdCBHcmFwaGljYWxXaXJlXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxXaXJlXCIpO1xuY2xhc3MgR3JhcGhpY2FsU291cmNlVGVybWluYWwgZXh0ZW5kcyBTdHViR3JhcGhpY2FsRWxlbWVudF8xLlN0dWJHcmFwaGljYWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gMjA7XG4gICAgfVxuICAgIG1ha2VDb25uZWN0b3JDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmFkaXVzID0gZWxlbWVudEhlaWdodCAvIDI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogW10sXG4gICAgICAgICAgICBvdXRwdXQ6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1ha2VCYXNlQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdO1xuICAgIH1cbiAgICBtYWtlRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZVRlcm1pbmFsXzEuU291cmNlVGVybWluYWwodGhpcy5nZXROYW1lKCksICgpID0+IHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgbGV0IGdyYXBoaWNzID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcbiAgICAgICAgZ3JhcGhpY3MuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICBncmFwaGljcy5vbihcInBvaW50ZXJ0YXBcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyYXBoaWNzO1xuICAgIH1cbiAgICByZWRyYXcocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmJlZ2luRmlsbCh0aGlzLnZhbHVlID8gR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuSElHSF9DT0xPUiA6IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkxPV19DT0xPUiwgMSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd0NpcmNsZSgwLCAwLCB0aGlzLnJhZGl1cyk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxTb3VyY2VUZXJtaW5hbCA9IEdyYXBoaWNhbFNvdXJjZVRlcm1pbmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY2FsU291cmNlVGVybWluYWwuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalSourceTerminal.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalSplit.js":
/*!*******************************************!*\
  !*** ./out/js/graphics/GraphicalSplit.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Split_1 = __webpack_require__(/*! ../elements/Split */ \"./out/js/elements/Split.js\");\nconst StubGraphicalElement_1 = __webpack_require__(/*! ./StubGraphicalElement */ \"./out/js/graphics/StubGraphicalElement.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nclass GraphicalSplit extends StubGraphicalElement_1.StubGraphicalElement {\n    constructor(name, numOutChannels, numInBits, drawLine = false, defaultHeight, initialValue = false, displayValue) {\n        super(name);\n        this.numOutChannels = numOutChannels;\n        this.numInBits = numInBits;\n        this.drawLine = drawLine;\n        this.initialValue = initialValue;\n        this.displayValue = displayValue;\n        this.valueReaders = new Array(Math.max(this.numInBits, 1));\n        if (defaultHeight === undefined) {\n            defaultHeight = drawLine ? GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT : Math.ceil(GraphicalSplit.DEFAULT_HEIGHT * GraphicalWire_1.GraphicalWire.getHeightMultiplicator(Math.max(this.numInBits, 1)));\n        }\n        this.defaultHeight = defaultHeight;\n    }\n    getDefaultHeight() {\n        return this.defaultHeight;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        if (this.drawLine) {\n            return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(0, elementHeight, this.numInBits, (Math.max(this.numOutChannels, 1) * Math.max(this.numInBits, 1)));\n        }\n        else {\n            let inputConnectorCoordinates = [];\n            for (let i = 0; i < this.numInBits; i++) {\n                inputConnectorCoordinates.push({\n                    x: 0,\n                    y: 0\n                });\n            }\n            let outputConnectorCoordinates = [];\n            for (let i = 0; i < (Math.max(this.numOutChannels, 1) * Math.max(this.numInBits, 1)); i++) {\n                outputConnectorCoordinates.push({\n                    x: 0,\n                    y: 0\n                });\n            }\n            return {\n                input: inputConnectorCoordinates,\n                output: outputConnectorCoordinates\n            };\n        }\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    makeElement(elementHeight, coordinates) {\n        let element = new Split_1.Split(this.getName(), this.numOutChannels, this.numInBits, this.initialValue);\n        return element;\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.radius = elementHeight / 2;\n        let scale = elementHeight / this.getDefaultHeight();\n        this.lineWidth = scale * GraphicalWire_1.GraphicalWire.DEFAULT_HEIGHT;\n        this.lineHeight = elementHeight;\n        for (let i = 0; i < this.valueReaders.length; i++) {\n            this.valueReaders[i] = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(i)());\n        }\n        let graphics = new PIXI.Graphics();\n        if (this.displayValue) {\n            let numHexDigits = Math.ceil(Math.max(this.numInBits, 1) / 4);\n            let text = new PIXI.Text(\"0\".repeat(numHexDigits), {\n                fontSize: scale * 2 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT / 5,\n                fontFamily: \"Courier New\",\n                fill: GraphicalOr_1.GraphicalOr.TEXT_COLOR\n            });\n            text.anchor.set(this.displayValue.endsWith(\"Left\") ? 1 : 0, this.displayValue.startsWith(\"above\") ? 1 : 0);\n            text.x = this.displayValue.endsWith(\"Left\") ? (this.drawLine ? 0 : -this.radius) : (this.drawLine ? this.lineWidth : this.radius);\n            text.y = this.displayValue.startsWith(\"above\") ? (this.drawLine ? 0 : -this.radius) : (this.drawLine ? this.lineHeight : this.radius);\n            graphics.addChild(text);\n            this.text = text;\n        }\n        return graphics;\n    }\n    getOutputValueText() {\n        const hexDigits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n        let digitStrings = new Array(Math.ceil(this.valueReaders.length / 4));\n        let currentDigitIndex = 0;\n        let currentHexDigitValue = 0;\n        for (let i = this.valueReaders.length - 1; i >= 0; i--) {\n            currentHexDigitValue <<= 1;\n            currentHexDigitValue |= this.valueReaders[i]() ? 1 : 0;\n            if ((i % 4) === 0) {\n                digitStrings[currentDigitIndex] = hexDigits[currentHexDigitValue];\n                currentDigitIndex++;\n                currentHexDigitValue = 0;\n            }\n        }\n        return digitStrings.join(\"\");\n    }\n    redraw(progress) {\n        this.graphics.clear();\n        let color = GraphicalWire_1.GraphicalWire.getLineColor(GraphicalWire_1.GraphicalWire.getDrawableOutputValueFromReaders(this.valueReaders));\n        if (this.drawLine) {\n            this.graphics.lineStyle(this.lineWidth, color, 1);\n            this.graphics.moveTo(0, 0);\n            this.graphics.lineTo(0, this.lineHeight);\n        }\n        else {\n            this.graphics.beginFill(color, 1);\n            this.graphics.drawCircle(0, 0, this.radius);\n        }\n        if (this.text) {\n            let valueText = this.getOutputValueText();\n            if (this.text.text !== valueText) {\n                this.text.text = valueText;\n            }\n        }\n    }\n}\nexports.GraphicalSplit = GraphicalSplit;\n(function (GraphicalSplit) {\n    GraphicalSplit.DEFAULT_HEIGHT = 5;\n})(GraphicalSplit = exports.GraphicalSplit || (exports.GraphicalSplit = {}));\n//# sourceMappingURL=GraphicalSplit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsU3BsaXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsU3BsaXQuanM/NDdhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNwbGl0XzEgPSByZXF1aXJlKFwiLi4vZWxlbWVudHMvU3BsaXRcIik7XG5jb25zdCBTdHViR3JhcGhpY2FsRWxlbWVudF8xID0gcmVxdWlyZShcIi4vU3R1YkdyYXBoaWNhbEVsZW1lbnRcIik7XG5jb25zdCBHcmFwaGljYWxXaXJlXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxXaXJlXCIpO1xuY29uc3QgR3JhcGhpY2FsT3JfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbE9yXCIpO1xuY2xhc3MgR3JhcGhpY2FsU3BsaXQgZXh0ZW5kcyBTdHViR3JhcGhpY2FsRWxlbWVudF8xLlN0dWJHcmFwaGljYWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBudW1PdXRDaGFubmVscywgbnVtSW5CaXRzLCBkcmF3TGluZSA9IGZhbHNlLCBkZWZhdWx0SGVpZ2h0LCBpbml0aWFsVmFsdWUgPSBmYWxzZSwgZGlzcGxheVZhbHVlKSB7XG4gICAgICAgIHN1cGVyKG5hbWUpO1xuICAgICAgICB0aGlzLm51bU91dENoYW5uZWxzID0gbnVtT3V0Q2hhbm5lbHM7XG4gICAgICAgIHRoaXMubnVtSW5CaXRzID0gbnVtSW5CaXRzO1xuICAgICAgICB0aGlzLmRyYXdMaW5lID0gZHJhd0xpbmU7XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZVJlYWRlcnMgPSBuZXcgQXJyYXkoTWF0aC5tYXgodGhpcy5udW1JbkJpdHMsIDEpKTtcbiAgICAgICAgaWYgKGRlZmF1bHRIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVmYXVsdEhlaWdodCA9IGRyYXdMaW5lID8gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCA6IE1hdGguY2VpbChHcmFwaGljYWxTcGxpdC5ERUZBVUxUX0hFSUdIVCAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLmdldEhlaWdodE11bHRpcGxpY2F0b3IoTWF0aC5tYXgodGhpcy5udW1JbkJpdHMsIDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0SGVpZ2h0ID0gZGVmYXVsdEhlaWdodDtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEhlaWdodDtcbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhd0xpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLm1ha2VDb25uZWN0b3JDb29yZGluYXRlcygwLCBlbGVtZW50SGVpZ2h0LCB0aGlzLm51bUluQml0cywgKE1hdGgubWF4KHRoaXMubnVtT3V0Q2hhbm5lbHMsIDEpICogTWF0aC5tYXgodGhpcy5udW1JbkJpdHMsIDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRDb25uZWN0b3JDb29yZGluYXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUluQml0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRDb25uZWN0b3JDb29yZGluYXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG91dHB1dENvbm5lY3RvckNvb3JkaW5hdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChNYXRoLm1heCh0aGlzLm51bU91dENoYW5uZWxzLCAxKSAqIE1hdGgubWF4KHRoaXMubnVtSW5CaXRzLCAxKSk7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dENvbm5lY3RvckNvb3JkaW5hdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbm5lY3RvckNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgIG91dHB1dDogb3V0cHV0Q29ubmVjdG9yQ29vcmRpbmF0ZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFrZUJhc2VDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF07XG4gICAgfVxuICAgIG1ha2VFbGVtZW50KGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGxldCBlbGVtZW50ID0gbmV3IFNwbGl0XzEuU3BsaXQodGhpcy5nZXROYW1lKCksIHRoaXMubnVtT3V0Q2hhbm5lbHMsIHRoaXMubnVtSW5CaXRzLCB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSBlbGVtZW50SGVpZ2h0IC8gMjtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMuZ2V0RGVmYXVsdEhlaWdodCgpO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IHNjYWxlICogR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuREVGQVVMVF9IRUlHSFQ7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZVJlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVSZWFkZXJzW2ldID0gZGF0YVNvdXJjZS5nZXRBZGRyZXNzVmFsdWVSZWFkZXIodGhpcy5lbGVtZW50LmdldE91dHB1dFZhbHVlQWRkcmVzc1Byb3ZpZGVyKGkpKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBncmFwaGljcyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXlWYWx1ZSkge1xuICAgICAgICAgICAgbGV0IG51bUhleERpZ2l0cyA9IE1hdGguY2VpbChNYXRoLm1heCh0aGlzLm51bUluQml0cywgMSkgLyA0KTtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gbmV3IFBJWEkuVGV4dChcIjBcIi5yZXBlYXQobnVtSGV4RGlnaXRzKSwge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBzY2FsZSAqIDIgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUIC8gNSxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIkNvdXJpZXIgTmV3XCIsXG4gICAgICAgICAgICAgICAgZmlsbDogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5URVhUX0NPTE9SXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRleHQuYW5jaG9yLnNldCh0aGlzLmRpc3BsYXlWYWx1ZS5lbmRzV2l0aChcIkxlZnRcIikgPyAxIDogMCwgdGhpcy5kaXNwbGF5VmFsdWUuc3RhcnRzV2l0aChcImFib3ZlXCIpID8gMSA6IDApO1xuICAgICAgICAgICAgdGV4dC54ID0gdGhpcy5kaXNwbGF5VmFsdWUuZW5kc1dpdGgoXCJMZWZ0XCIpID8gKHRoaXMuZHJhd0xpbmUgPyAwIDogLXRoaXMucmFkaXVzKSA6ICh0aGlzLmRyYXdMaW5lID8gdGhpcy5saW5lV2lkdGggOiB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICB0ZXh0LnkgPSB0aGlzLmRpc3BsYXlWYWx1ZS5zdGFydHNXaXRoKFwiYWJvdmVcIikgPyAodGhpcy5kcmF3TGluZSA/IDAgOiAtdGhpcy5yYWRpdXMpIDogKHRoaXMuZHJhd0xpbmUgPyB0aGlzLmxpbmVIZWlnaHQgOiB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICBncmFwaGljcy5hZGRDaGlsZCh0ZXh0KTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXBoaWNzO1xuICAgIH1cbiAgICBnZXRPdXRwdXRWYWx1ZVRleHQoKSB7XG4gICAgICAgIGNvbnN0IGhleERpZ2l0cyA9IFtcIjBcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCJBXCIsIFwiQlwiLCBcIkNcIiwgXCJEXCIsIFwiRVwiLCBcIkZcIl07XG4gICAgICAgIGxldCBkaWdpdFN0cmluZ3MgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMudmFsdWVSZWFkZXJzLmxlbmd0aCAvIDQpKTtcbiAgICAgICAgbGV0IGN1cnJlbnREaWdpdEluZGV4ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRIZXhEaWdpdFZhbHVlID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMudmFsdWVSZWFkZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjdXJyZW50SGV4RGlnaXRWYWx1ZSA8PD0gMTtcbiAgICAgICAgICAgIGN1cnJlbnRIZXhEaWdpdFZhbHVlIHw9IHRoaXMudmFsdWVSZWFkZXJzW2ldKCkgPyAxIDogMDtcbiAgICAgICAgICAgIGlmICgoaSAlIDQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlnaXRTdHJpbmdzW2N1cnJlbnREaWdpdEluZGV4XSA9IGhleERpZ2l0c1tjdXJyZW50SGV4RGlnaXRWYWx1ZV07XG4gICAgICAgICAgICAgICAgY3VycmVudERpZ2l0SW5kZXgrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50SGV4RGlnaXRWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZ2l0U3RyaW5ncy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZWRyYXcocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5jbGVhcigpO1xuICAgICAgICBsZXQgY29sb3IgPSBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5nZXRMaW5lQ29sb3IoR3JhcGhpY2FsV2lyZV8xLkdyYXBoaWNhbFdpcmUuZ2V0RHJhd2FibGVPdXRwdXRWYWx1ZUZyb21SZWFkZXJzKHRoaXMudmFsdWVSZWFkZXJzKSk7XG4gICAgICAgIGlmICh0aGlzLmRyYXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSh0aGlzLmxpbmVXaWR0aCwgY29sb3IsIDEpO1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVUbygwLCB0aGlzLmxpbmVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoY29sb3IsIDEpO1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3Q2lyY2xlKDAsIDAsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50ZXh0KSB7XG4gICAgICAgICAgICBsZXQgdmFsdWVUZXh0ID0gdGhpcy5nZXRPdXRwdXRWYWx1ZVRleHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHQudGV4dCAhPT0gdmFsdWVUZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0LnRleHQgPSB2YWx1ZVRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkdyYXBoaWNhbFNwbGl0ID0gR3JhcGhpY2FsU3BsaXQ7XG4oZnVuY3Rpb24gKEdyYXBoaWNhbFNwbGl0KSB7XG4gICAgR3JhcGhpY2FsU3BsaXQuREVGQVVMVF9IRUlHSFQgPSA1O1xufSkoR3JhcGhpY2FsU3BsaXQgPSBleHBvcnRzLkdyYXBoaWNhbFNwbGl0IHx8IChleHBvcnRzLkdyYXBoaWNhbFNwbGl0ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbFNwbGl0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalSplit.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalWire.js":
/*!******************************************!*\
  !*** ./out/js/graphics/GraphicalWire.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Wire_1 = __webpack_require__(/*! ../elements/Wire */ \"./out/js/elements/Wire.js\");\nconst StubGraphicalElement_1 = __webpack_require__(/*! ./StubGraphicalElement */ \"./out/js/graphics/StubGraphicalElement.js\");\nconst highlightBufferRows = false;\nclass GraphicalWire extends StubGraphicalElement_1.StubGraphicalElement {\n    constructor(name, initialValue = false, num = 1) {\n        super(name);\n        this.initialValue = initialValue;\n        this.num = num;\n        this.lines = [];\n    }\n    static getHeightMultiplicator(numBits) {\n        return 1 + Math.sqrt(Math.log2(numBits));\n    }\n    static getDrawableOutputValueFromReaders(readers) {\n        let sum = 0;\n        for (let i = 0; i < readers.length; i++) {\n            sum += readers[i]() ? 1 : 0;\n        }\n        return sum / readers.length;\n    }\n    static getLineColor(value) {\n        return 0x10000 * Math.floor(GraphicalWire.LOW_R + value * (GraphicalWire.HIGH_R - GraphicalWire.LOW_R))\n            + 0x100 * Math.floor(GraphicalWire.LOW_G + value * (GraphicalWire.HIGH_G - GraphicalWire.LOW_G))\n            + Math.floor(GraphicalWire.LOW_B + value * (GraphicalWire.HIGH_B - GraphicalWire.LOW_B));\n    }\n    getDefaultHeight() {\n        return Math.ceil(GraphicalWire.DEFAULT_HEIGHT * GraphicalWire.getHeightMultiplicator(this.num));\n    }\n    makeConnectorCoordinates(elementHeight) {\n        return undefined;\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    makeElement(elementHeight, coordinates) {\n        if (!this.lines || this.lines.length) {\n            this.lines = [];\n        }\n        let totalDistance = 0;\n        for (let i = coordinates.length - 1; i > 0; i--) {\n            let from = coordinates[i];\n            let to = coordinates[i - 1];\n            let xDelta = to.x - from.x;\n            let yDelta = to.y - from.y;\n            let localDistance = Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2));\n            let fromDistance = totalDistance;\n            totalDistance += localDistance;\n            this.lines.push({\n                from: from,\n                xDelta: xDelta,\n                yDelta: yDelta,\n                fromProgress: fromDistance,\n                toProgress: totalDistance,\n                coversProgress: localDistance\n            });\n        }\n        for (let line of this.lines) {\n            line.fromProgress /= totalDistance;\n            line.toProgress /= totalDistance;\n            line.coversProgress /= totalDistance;\n        }\n        let delay = (GraphicalWire.DELAY_PER_PIXEL > 0) ? Math.max(Math.floor(GraphicalWire.DELAY_PER_PIXEL * totalDistance), 1) : 0;\n        let element = new Wire_1.Wire(this.getName(), delay, this.initialValue, this.num);\n        return element;\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.lineWidth = elementHeight;\n        this.dataSource = dataSource;\n        if (this.element.getDelay()) {\n            this.delayBufferValueReaders = new Array(this.element.getNumOutputs());\n            for (let i = 0; i < this.delayBufferValueReaders.length; i++) {\n                this.delayBufferValueReaders[i] = dataSource.getAddressValueReader(this.element.getDelayBufferAddressProvider(i)());\n            }\n        }\n        this.outputValueReaders = new Array(this.element.getNumOutputs());\n        for (let i = 0; i < this.outputValueReaders.length; i++) {\n            this.outputValueReaders[i] = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(i)());\n        }\n        return new PIXI.Graphics();\n    }\n    getDrawableOutputValue() {\n        let sum = 0;\n        for (let i = 0; i < this.outputValueReaders.length; i++) {\n            sum += this.outputValueReaders[i]() ? 1 : 0;\n        }\n        return sum / this.outputValueReaders.length;\n    }\n    getDrawableDelayBufferValue(index) {\n        let sum = 0;\n        for (let i = 0; i < this.delayBufferValueReaders.length; i++) {\n            sum += this.delayBufferValueReaders[i](index) ? 1 : 0;\n        }\n        return sum / this.delayBufferValueReaders.length;\n    }\n    redraw(progress) {\n        let currentLineIndex = 0;\n        let currentLine = this.lines[currentLineIndex];\n        this.graphics.clear();\n        this.graphics.moveTo(currentLine.from.x, currentLine.from.y);\n        let delay = this.element.getDelay();\n        let currentValue = this.getDrawableOutputValue();\n        for (let i = 0; i < delay; i++) {\n            let bufferRowProgress = (1 - progress);\n            let overallLineProgress = (i + bufferRowProgress) / delay;\n            let value = this.getDrawableDelayBufferValue(i);\n            if (value !== currentValue || highlightBufferRows) {\n                if (highlightBufferRows) {\n                    const bright = ((i % 2) !== 0);\n                    this.graphics.lineStyle(this.lineWidth, currentValue > 0 ? (bright ? GraphicalWire.HIGH_BRIGHT_COLOR : GraphicalWire.HIGH_COLOR) : (bright ? GraphicalWire.LOW_BRIGHT_COLOR : GraphicalWire.LOW_COLOR), 1);\n                }\n                else {\n                    this.graphics.lineStyle(this.lineWidth, GraphicalWire.getLineColor(currentValue), 1);\n                }\n                while (overallLineProgress > currentLine.toProgress) {\n                    currentLineIndex++;\n                    currentLine = this.lines[currentLineIndex];\n                    this.graphics.lineTo(currentLine.from.x, currentLine.from.y);\n                }\n                let localLineProgress = (overallLineProgress - currentLine.fromProgress) / currentLine.coversProgress;\n                let stopX = currentLine.from.x + (currentLine.xDelta * localLineProgress);\n                let stopY = currentLine.from.y + (currentLine.yDelta * localLineProgress);\n                this.graphics.lineTo(stopX, stopY);\n            }\n            currentValue = value;\n        }\n        if (highlightBufferRows) {\n            this.graphics.lineStyle(this.lineWidth, currentValue > 0 ? GraphicalWire.HIGH_DARK_COLOR : GraphicalWire.LOW_DARK_COLOR, 1);\n        }\n        else {\n            this.graphics.lineStyle(this.lineWidth, GraphicalWire.getLineColor(currentValue), 1);\n        }\n        do {\n            currentLine = this.lines[currentLineIndex];\n            this.graphics.lineTo(currentLine.from.x + currentLine.xDelta, currentLine.from.y + currentLine.yDelta);\n        } while (++currentLineIndex < this.lines.length);\n    }\n}\nexports.GraphicalWire = GraphicalWire;\n(function (GraphicalWire) {\n    GraphicalWire.DEFAULT_DELAY_PER_WINDOW_HEIGHT = 100;\n    GraphicalWire.DELAY_PER_PIXEL = 0;\n    GraphicalWire.DEFAULT_HEIGHT = 2;\n    GraphicalWire.DEFAULT_DISTANCE = 3;\n    GraphicalWire.DEFAULT_BUS_DISTANCE = 10;\n    GraphicalWire.DEFAULT_ELEMENT_DISTANCE = 20;\n    GraphicalWire.HIGH_R = 0x00;\n    GraphicalWire.HIGH_G = 0xD8;\n    GraphicalWire.HIGH_B = 0x0A;\n    GraphicalWire.HIGH_COLOR = (GraphicalWire.HIGH_R << 16) | (GraphicalWire.HIGH_G << 8) | GraphicalWire.HIGH_B;\n    GraphicalWire.HIGH_DARK_COLOR = 0x008800;\n    GraphicalWire.HIGH_BRIGHT_COLOR = 0x88FF88;\n    GraphicalWire.LOW_R = 0x84;\n    GraphicalWire.LOW_G = 0x00;\n    GraphicalWire.LOW_B = 0x00;\n    GraphicalWire.LOW_COLOR = (GraphicalWire.LOW_R << 16) | (GraphicalWire.LOW_G << 8) | GraphicalWire.LOW_B;\n    GraphicalWire.LOW_DARK_COLOR = 0x880000;\n    GraphicalWire.LOW_BRIGHT_COLOR = 0xFF8888;\n})(GraphicalWire = exports.GraphicalWire || (exports.GraphicalWire = {}));\n//# sourceMappingURL=GraphicalWire.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsV2lyZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL291dC9qcy9ncmFwaGljcy9HcmFwaGljYWxXaXJlLmpzP2RkMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBXaXJlXzEgPSByZXF1aXJlKFwiLi4vZWxlbWVudHMvV2lyZVwiKTtcbmNvbnN0IFN0dWJHcmFwaGljYWxFbGVtZW50XzEgPSByZXF1aXJlKFwiLi9TdHViR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IGhpZ2hsaWdodEJ1ZmZlclJvd3MgPSBmYWxzZTtcbmNsYXNzIEdyYXBoaWNhbFdpcmUgZXh0ZW5kcyBTdHViR3JhcGhpY2FsRWxlbWVudF8xLlN0dWJHcmFwaGljYWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBpbml0aWFsVmFsdWUgPSBmYWxzZSwgbnVtID0gMSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIHRoaXMubnVtID0gbnVtO1xuICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBnZXRIZWlnaHRNdWx0aXBsaWNhdG9yKG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIDEgKyBNYXRoLnNxcnQoTWF0aC5sb2cyKG51bUJpdHMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldERyYXdhYmxlT3V0cHV0VmFsdWVGcm9tUmVhZGVycyhyZWFkZXJzKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSByZWFkZXJzW2ldKCkgPyAxIDogMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtIC8gcmVhZGVycy5sZW5ndGg7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRMaW5lQ29sb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIDB4MTAwMDAgKiBNYXRoLmZsb29yKEdyYXBoaWNhbFdpcmUuTE9XX1IgKyB2YWx1ZSAqIChHcmFwaGljYWxXaXJlLkhJR0hfUiAtIEdyYXBoaWNhbFdpcmUuTE9XX1IpKVxuICAgICAgICAgICAgKyAweDEwMCAqIE1hdGguZmxvb3IoR3JhcGhpY2FsV2lyZS5MT1dfRyArIHZhbHVlICogKEdyYXBoaWNhbFdpcmUuSElHSF9HIC0gR3JhcGhpY2FsV2lyZS5MT1dfRykpXG4gICAgICAgICAgICArIE1hdGguZmxvb3IoR3JhcGhpY2FsV2lyZS5MT1dfQiArIHZhbHVlICogKEdyYXBoaWNhbFdpcmUuSElHSF9CIC0gR3JhcGhpY2FsV2lyZS5MT1dfQikpO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKEdyYXBoaWNhbFdpcmUuREVGQVVMVF9IRUlHSFQgKiBHcmFwaGljYWxXaXJlLmdldEhlaWdodE11bHRpcGxpY2F0b3IodGhpcy5udW0pKTtcbiAgICB9XG4gICAgbWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbWFrZUJhc2VDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbWFrZUVsZW1lbnQoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVzIHx8IHRoaXMubGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsRGlzdGFuY2UgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgICAgIGxldCB0byA9IGNvb3JkaW5hdGVzW2kgLSAxXTtcbiAgICAgICAgICAgIGxldCB4RGVsdGEgPSB0by54IC0gZnJvbS54O1xuICAgICAgICAgICAgbGV0IHlEZWx0YSA9IHRvLnkgLSBmcm9tLnk7XG4gICAgICAgICAgICBsZXQgbG9jYWxEaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4RGVsdGEsIDIpICsgTWF0aC5wb3coeURlbHRhLCAyKSk7XG4gICAgICAgICAgICBsZXQgZnJvbURpc3RhbmNlID0gdG90YWxEaXN0YW5jZTtcbiAgICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gbG9jYWxEaXN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMubGluZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICB4RGVsdGE6IHhEZWx0YSxcbiAgICAgICAgICAgICAgICB5RGVsdGE6IHlEZWx0YSxcbiAgICAgICAgICAgICAgICBmcm9tUHJvZ3Jlc3M6IGZyb21EaXN0YW5jZSxcbiAgICAgICAgICAgICAgICB0b1Byb2dyZXNzOiB0b3RhbERpc3RhbmNlLFxuICAgICAgICAgICAgICAgIGNvdmVyc1Byb2dyZXNzOiBsb2NhbERpc3RhbmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMubGluZXMpIHtcbiAgICAgICAgICAgIGxpbmUuZnJvbVByb2dyZXNzIC89IHRvdGFsRGlzdGFuY2U7XG4gICAgICAgICAgICBsaW5lLnRvUHJvZ3Jlc3MgLz0gdG90YWxEaXN0YW5jZTtcbiAgICAgICAgICAgIGxpbmUuY292ZXJzUHJvZ3Jlc3MgLz0gdG90YWxEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVsYXkgPSAoR3JhcGhpY2FsV2lyZS5ERUxBWV9QRVJfUElYRUwgPiAwKSA/IE1hdGgubWF4KE1hdGguZmxvb3IoR3JhcGhpY2FsV2lyZS5ERUxBWV9QRVJfUElYRUwgKiB0b3RhbERpc3RhbmNlKSwgMSkgOiAwO1xuICAgICAgICBsZXQgZWxlbWVudCA9IG5ldyBXaXJlXzEuV2lyZSh0aGlzLmdldE5hbWUoKSwgZGVsYXksIHRoaXMuaW5pdGlhbFZhbHVlLCB0aGlzLm51bSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSBlbGVtZW50SGVpZ2h0O1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50LmdldERlbGF5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlCdWZmZXJWYWx1ZVJlYWRlcnMgPSBuZXcgQXJyYXkodGhpcy5lbGVtZW50LmdldE51bU91dHB1dHMoKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVsYXlCdWZmZXJWYWx1ZVJlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5QnVmZmVyVmFsdWVSZWFkZXJzW2ldID0gZGF0YVNvdXJjZS5nZXRBZGRyZXNzVmFsdWVSZWFkZXIodGhpcy5lbGVtZW50LmdldERlbGF5QnVmZmVyQWRkcmVzc1Byb3ZpZGVyKGkpKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0VmFsdWVSZWFkZXJzID0gbmV3IEFycmF5KHRoaXMuZWxlbWVudC5nZXROdW1PdXRwdXRzKCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0cHV0VmFsdWVSZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFZhbHVlUmVhZGVyc1tpXSA9IGRhdGFTb3VyY2UuZ2V0QWRkcmVzc1ZhbHVlUmVhZGVyKHRoaXMuZWxlbWVudC5nZXRPdXRwdXRWYWx1ZUFkZHJlc3NQcm92aWRlcihpKSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBJWEkuR3JhcGhpY3MoKTtcbiAgICB9XG4gICAgZ2V0RHJhd2FibGVPdXRwdXRWYWx1ZSgpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRWYWx1ZVJlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLm91dHB1dFZhbHVlUmVhZGVyc1tpXSgpID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bSAvIHRoaXMub3V0cHV0VmFsdWVSZWFkZXJzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0RHJhd2FibGVEZWxheUJ1ZmZlclZhbHVlKGluZGV4KSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVsYXlCdWZmZXJWYWx1ZVJlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLmRlbGF5QnVmZmVyVmFsdWVSZWFkZXJzW2ldKGluZGV4KSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0gLyB0aGlzLmRlbGF5QnVmZmVyVmFsdWVSZWFkZXJzLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkcmF3KHByb2dyZXNzKSB7XG4gICAgICAgIGxldCBjdXJyZW50TGluZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRMaW5lID0gdGhpcy5saW5lc1tjdXJyZW50TGluZUluZGV4XTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyhjdXJyZW50TGluZS5mcm9tLngsIGN1cnJlbnRMaW5lLmZyb20ueSk7XG4gICAgICAgIGxldCBkZWxheSA9IHRoaXMuZWxlbWVudC5nZXREZWxheSgpO1xuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gdGhpcy5nZXREcmF3YWJsZU91dHB1dFZhbHVlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsYXk7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ1ZmZlclJvd1Byb2dyZXNzID0gKDEgLSBwcm9ncmVzcyk7XG4gICAgICAgICAgICBsZXQgb3ZlcmFsbExpbmVQcm9ncmVzcyA9IChpICsgYnVmZmVyUm93UHJvZ3Jlc3MpIC8gZGVsYXk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldERyYXdhYmxlRGVsYXlCdWZmZXJWYWx1ZShpKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gY3VycmVudFZhbHVlIHx8IGhpZ2hsaWdodEJ1ZmZlclJvd3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0QnVmZmVyUm93cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBicmlnaHQgPSAoKGkgJSAyKSAhPT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKHRoaXMubGluZVdpZHRoLCBjdXJyZW50VmFsdWUgPiAwID8gKGJyaWdodCA/IEdyYXBoaWNhbFdpcmUuSElHSF9CUklHSFRfQ09MT1IgOiBHcmFwaGljYWxXaXJlLkhJR0hfQ09MT1IpIDogKGJyaWdodCA/IEdyYXBoaWNhbFdpcmUuTE9XX0JSSUdIVF9DT0xPUiA6IEdyYXBoaWNhbFdpcmUuTE9XX0NPTE9SKSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSh0aGlzLmxpbmVXaWR0aCwgR3JhcGhpY2FsV2lyZS5nZXRMaW5lQ29sb3IoY3VycmVudFZhbHVlKSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChvdmVyYWxsTGluZVByb2dyZXNzID4gY3VycmVudExpbmUudG9Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gdGhpcy5saW5lc1tjdXJyZW50TGluZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oY3VycmVudExpbmUuZnJvbS54LCBjdXJyZW50TGluZS5mcm9tLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbG9jYWxMaW5lUHJvZ3Jlc3MgPSAob3ZlcmFsbExpbmVQcm9ncmVzcyAtIGN1cnJlbnRMaW5lLmZyb21Qcm9ncmVzcykgLyBjdXJyZW50TGluZS5jb3ZlcnNQcm9ncmVzcztcbiAgICAgICAgICAgICAgICBsZXQgc3RvcFggPSBjdXJyZW50TGluZS5mcm9tLnggKyAoY3VycmVudExpbmUueERlbHRhICogbG9jYWxMaW5lUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIGxldCBzdG9wWSA9IGN1cnJlbnRMaW5lLmZyb20ueSArIChjdXJyZW50TGluZS55RGVsdGEgKiBsb2NhbExpbmVQcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oc3RvcFgsIHN0b3BZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdobGlnaHRCdWZmZXJSb3dzKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSh0aGlzLmxpbmVXaWR0aCwgY3VycmVudFZhbHVlID4gMCA/IEdyYXBoaWNhbFdpcmUuSElHSF9EQVJLX0NPTE9SIDogR3JhcGhpY2FsV2lyZS5MT1dfREFSS19DT0xPUiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSh0aGlzLmxpbmVXaWR0aCwgR3JhcGhpY2FsV2lyZS5nZXRMaW5lQ29sb3IoY3VycmVudFZhbHVlKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VycmVudExpbmUgPSB0aGlzLmxpbmVzW2N1cnJlbnRMaW5lSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oY3VycmVudExpbmUuZnJvbS54ICsgY3VycmVudExpbmUueERlbHRhLCBjdXJyZW50TGluZS5mcm9tLnkgKyBjdXJyZW50TGluZS55RGVsdGEpO1xuICAgICAgICB9IHdoaWxlICgrK2N1cnJlbnRMaW5lSW5kZXggPCB0aGlzLmxpbmVzLmxlbmd0aCk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljYWxXaXJlID0gR3JhcGhpY2FsV2lyZTtcbihmdW5jdGlvbiAoR3JhcGhpY2FsV2lyZSkge1xuICAgIEdyYXBoaWNhbFdpcmUuREVGQVVMVF9ERUxBWV9QRVJfV0lORE9XX0hFSUdIVCA9IDEwMDtcbiAgICBHcmFwaGljYWxXaXJlLkRFTEFZX1BFUl9QSVhFTCA9IDA7XG4gICAgR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0hFSUdIVCA9IDI7XG4gICAgR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0RJU1RBTkNFID0gMztcbiAgICBHcmFwaGljYWxXaXJlLkRFRkFVTFRfQlVTX0RJU1RBTkNFID0gMTA7XG4gICAgR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0UgPSAyMDtcbiAgICBHcmFwaGljYWxXaXJlLkhJR0hfUiA9IDB4MDA7XG4gICAgR3JhcGhpY2FsV2lyZS5ISUdIX0cgPSAweEQ4O1xuICAgIEdyYXBoaWNhbFdpcmUuSElHSF9CID0gMHgwQTtcbiAgICBHcmFwaGljYWxXaXJlLkhJR0hfQ09MT1IgPSAoR3JhcGhpY2FsV2lyZS5ISUdIX1IgPDwgMTYpIHwgKEdyYXBoaWNhbFdpcmUuSElHSF9HIDw8IDgpIHwgR3JhcGhpY2FsV2lyZS5ISUdIX0I7XG4gICAgR3JhcGhpY2FsV2lyZS5ISUdIX0RBUktfQ09MT1IgPSAweDAwODgwMDtcbiAgICBHcmFwaGljYWxXaXJlLkhJR0hfQlJJR0hUX0NPTE9SID0gMHg4OEZGODg7XG4gICAgR3JhcGhpY2FsV2lyZS5MT1dfUiA9IDB4ODQ7XG4gICAgR3JhcGhpY2FsV2lyZS5MT1dfRyA9IDB4MDA7XG4gICAgR3JhcGhpY2FsV2lyZS5MT1dfQiA9IDB4MDA7XG4gICAgR3JhcGhpY2FsV2lyZS5MT1dfQ09MT1IgPSAoR3JhcGhpY2FsV2lyZS5MT1dfUiA8PCAxNikgfCAoR3JhcGhpY2FsV2lyZS5MT1dfRyA8PCA4KSB8IEdyYXBoaWNhbFdpcmUuTE9XX0I7XG4gICAgR3JhcGhpY2FsV2lyZS5MT1dfREFSS19DT0xPUiA9IDB4ODgwMDAwO1xuICAgIEdyYXBoaWNhbFdpcmUuTE9XX0JSSUdIVF9DT0xPUiA9IDB4RkY4ODg4O1xufSkoR3JhcGhpY2FsV2lyZSA9IGV4cG9ydHMuR3JhcGhpY2FsV2lyZSB8fCAoZXhwb3J0cy5HcmFwaGljYWxXaXJlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNhbFdpcmUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalWire.js\n");

/***/ }),

/***/ "./out/js/graphics/GraphicalXor.js":
/*!*****************************************!*\
  !*** ./out/js/graphics/GraphicalXor.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CompactCombinedGraphicalElement_1 = __webpack_require__(/*! ./CompactCombinedGraphicalElement */ \"./out/js/graphics/CompactCombinedGraphicalElement.js\");\nconst GraphicalOr_1 = __webpack_require__(/*! ./GraphicalOr */ \"./out/js/graphics/GraphicalOr.js\");\nconst GraphicalWire_1 = __webpack_require__(/*! ./GraphicalWire */ \"./out/js/graphics/GraphicalWire.js\");\nconst GrammarParser_1 = __webpack_require__(/*! ../grammar/GrammarParser */ \"./out/js/grammar/GrammarParser.js\");\nclass GraphicalXor extends CompactCombinedGraphicalElement_1.CompactCombinedGraphicalElement {\n    constructor(name, detailed = false, defaultHeight = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT) {\n        super(name, 2 * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT + 3 * GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE, detailed);\n        this.defaultHeight = defaultHeight;\n        let elements = [];\n        const elemDist = GraphicalWire_1.GraphicalWire.DEFAULT_ELEMENT_DISTANCE;\n        const lY = GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT + 3 * elemDist;\n        elements.push(`a_split split @0:${lY - 2 * elemDist} <0 >p:n~a_nor >a_nb_nor/i1-${elemDist}:p~p:n~a_nb_nor/i1`);\n        elements.push(`b_split split @${elemDist}:${lY - 1 * elemDist} <1 >p:n~b_nor >na_b_nor/i0-${elemDist}:p~p:n~na_b_nor/i0`);\n        elements.push(`b_nor nor @${2 * elemDist}:0 >p+${elemDist}:p~p:n~a_nb_nor/i0`);\n        elements.push(`a_nor nor @${2 * elemDist}:${lY} >p+${elemDist}:p~p:n~na_b_nor/i1`);\n        elements.push(`a_nb_nor nor @b_nor/o0+${3 * elemDist}:0 >p+${2 * elemDist}:p~p:n~nor/i0`);\n        elements.push(`na_b_nor nor @a_nor/o0+${3 * elemDist}:${lY} >p+${1 * elemDist}:p~p:n~nor/i1`);\n        elements.push(`nor nor @a_nb_nor/o0+${3 * elemDist}:${lY} >not`);\n        elements.push(`not nor @nor/o0+${elemDist}:${lY} 0>>`);\n        this.wiringDescriptions = GrammarParser_1.GrammarParser.parse(elements).wiringDescriptions;\n    }\n    makeDefaultHeight() {\n        return this.defaultHeight;\n    }\n    makeWiringDescriptions() {\n        return this.wiringDescriptions;\n    }\n    makeConnectorCoordinates(elementHeight) {\n        this.height = elementHeight;\n        let scale = elementHeight / this.makeDefaultHeight();\n        this.width = GraphicalOr_1.GraphicalOr.getWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        this.lineWidth = GraphicalOr_1.GraphicalOr.getLineWidth(scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n        return GraphicalOr_1.GraphicalOr.makeConnectorCoordinates(this.width, this.height, 2, 1);\n    }\n    makeBaseCoordinates(elementHeight, coordinates) {\n        return coordinates[0];\n    }\n    onElement(elementHeight, coordinates) {\n    }\n    makeGraphics(elementHeight, coordinates, dataSource) {\n        this.outputValueReader = dataSource.getAddressValueReader(this.element.getOutputValueAddressProvider(0)());\n        let scale = elementHeight / this.makeDefaultHeight();\n        return GraphicalOr_1.GraphicalOr.makeGraphics(this.height, this.width, \"=1\", scale * GraphicalOr_1.GraphicalOr.DEFAULT_HEIGHT);\n    }\n    doRedraw(progress) {\n        let value = this.outputValueReader();\n        GraphicalOr_1.GraphicalOr.redraw(this.graphics, this.width, this.height, this.lineWidth, value ? GraphicalWire_1.GraphicalWire.HIGH_COLOR : GraphicalWire_1.GraphicalWire.LOW_COLOR);\n    }\n}\nexports.GraphicalXor = GraphicalXor;\n//# sourceMappingURL=GraphicalXor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvR3JhcGhpY2FsWG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vb3V0L2pzL2dyYXBoaWNzL0dyYXBoaWNhbFhvci5qcz9kODYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xID0gcmVxdWlyZShcIi4vQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudFwiKTtcbmNvbnN0IEdyYXBoaWNhbE9yXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljYWxPclwiKTtcbmNvbnN0IEdyYXBoaWNhbFdpcmVfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNhbFdpcmVcIik7XG5jb25zdCBHcmFtbWFyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9HcmFtbWFyUGFyc2VyXCIpO1xuY2xhc3MgR3JhcGhpY2FsWG9yIGV4dGVuZHMgQ29tcGFjdENvbWJpbmVkR3JhcGhpY2FsRWxlbWVudF8xLkNvbXBhY3RDb21iaW5lZEdyYXBoaWNhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRldGFpbGVkID0gZmFsc2UsIGRlZmF1bHRIZWlnaHQgPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIDIgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUICsgMyAqIEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkRFRkFVTFRfRUxFTUVOVF9ESVNUQU5DRSwgZGV0YWlsZWQpO1xuICAgICAgICB0aGlzLmRlZmF1bHRIZWlnaHQgPSBkZWZhdWx0SGVpZ2h0O1xuICAgICAgICBsZXQgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgZWxlbURpc3QgPSBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5ERUZBVUxUX0VMRU1FTlRfRElTVEFOQ0U7XG4gICAgICAgIGNvbnN0IGxZID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCArIDMgKiBlbGVtRGlzdDtcbiAgICAgICAgZWxlbWVudHMucHVzaChgYV9zcGxpdCBzcGxpdCBAMDoke2xZIC0gMiAqIGVsZW1EaXN0fSA8MCA+cDpufmFfbm9yID5hX25iX25vci9pMS0ke2VsZW1EaXN0fTpwfnA6bn5hX25iX25vci9pMWApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBiX3NwbGl0IHNwbGl0IEAke2VsZW1EaXN0fToke2xZIC0gMSAqIGVsZW1EaXN0fSA8MSA+cDpufmJfbm9yID5uYV9iX25vci9pMC0ke2VsZW1EaXN0fTpwfnA6bn5uYV9iX25vci9pMGApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBiX25vciBub3IgQCR7MiAqIGVsZW1EaXN0fTowID5wKyR7ZWxlbURpc3R9OnB+cDpufmFfbmJfbm9yL2kwYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGFfbm9yIG5vciBAJHsyICogZWxlbURpc3R9OiR7bFl9ID5wKyR7ZWxlbURpc3R9OnB+cDpufm5hX2Jfbm9yL2kxYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYGFfbmJfbm9yIG5vciBAYl9ub3IvbzArJHszICogZWxlbURpc3R9OjAgPnArJHsyICogZWxlbURpc3R9OnB+cDpufm5vci9pMGApO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGBuYV9iX25vciBub3IgQGFfbm9yL28wKyR7MyAqIGVsZW1EaXN0fToke2xZfSA+cCskezEgKiBlbGVtRGlzdH06cH5wOm5+bm9yL2kxYCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYG5vciBub3IgQGFfbmJfbm9yL28wKyR7MyAqIGVsZW1EaXN0fToke2xZfSA+bm90YCk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goYG5vdCBub3IgQG5vci9vMCske2VsZW1EaXN0fToke2xZfSAwPj5gKTtcbiAgICAgICAgdGhpcy53aXJpbmdEZXNjcmlwdGlvbnMgPSBHcmFtbWFyUGFyc2VyXzEuR3JhbW1hclBhcnNlci5wYXJzZShlbGVtZW50cykud2lyaW5nRGVzY3JpcHRpb25zO1xuICAgIH1cbiAgICBtYWtlRGVmYXVsdEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEhlaWdodDtcbiAgICB9XG4gICAgbWFrZVdpcmluZ0Rlc2NyaXB0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyaW5nRGVzY3JpcHRpb25zO1xuICAgIH1cbiAgICBtYWtlQ29ubmVjdG9yQ29vcmRpbmF0ZXMoZWxlbWVudEhlaWdodCkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIGxldCBzY2FsZSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLm1ha2VEZWZhdWx0SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMud2lkdGggPSBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLmdldFdpZHRoKHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5nZXRMaW5lV2lkdGgoc2NhbGUgKiBHcmFwaGljYWxPcl8xLkdyYXBoaWNhbE9yLkRFRkFVTFRfSEVJR0hUKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAyLCAxKTtcbiAgICB9XG4gICAgbWFrZUJhc2VDb29yZGluYXRlcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF07XG4gICAgfVxuICAgIG9uRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcykge1xuICAgIH1cbiAgICBtYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMsIGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRWYWx1ZVJlYWRlciA9IGRhdGFTb3VyY2UuZ2V0QWRkcmVzc1ZhbHVlUmVhZGVyKHRoaXMuZWxlbWVudC5nZXRPdXRwdXRWYWx1ZUFkZHJlc3NQcm92aWRlcigwKSgpKTtcbiAgICAgICAgbGV0IHNjYWxlID0gZWxlbWVudEhlaWdodCAvIHRoaXMubWFrZURlZmF1bHRIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNhbE9yXzEuR3JhcGhpY2FsT3IubWFrZUdyYXBoaWNzKHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCBcIj0xXCIsIHNjYWxlICogR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5ERUZBVUxUX0hFSUdIVCk7XG4gICAgfVxuICAgIGRvUmVkcmF3KHByb2dyZXNzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMub3V0cHV0VmFsdWVSZWFkZXIoKTtcbiAgICAgICAgR3JhcGhpY2FsT3JfMS5HcmFwaGljYWxPci5yZWRyYXcodGhpcy5ncmFwaGljcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMubGluZVdpZHRoLCB2YWx1ZSA/IEdyYXBoaWNhbFdpcmVfMS5HcmFwaGljYWxXaXJlLkhJR0hfQ09MT1IgOiBHcmFwaGljYWxXaXJlXzEuR3JhcGhpY2FsV2lyZS5MT1dfQ09MT1IpO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhcGhpY2FsWG9yID0gR3JhcGhpY2FsWG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY2FsWG9yLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./out/js/graphics/GraphicalXor.js\n");

/***/ }),

/***/ "./out/js/graphics/StubGraphicalElement.js":
/*!*************************************************!*\
  !*** ./out/js/graphics/StubGraphicalElement.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass StubGraphicalElement {\n    constructor(name) {\n        this.name = name;\n    }\n    getName() {\n        return this.name;\n    }\n    prefixName(prefix) {\n        this.name = prefix + this.name;\n    }\n    initConnectorCoordinates(elementHeight) {\n        this.connectorCoordinates = this.makeConnectorCoordinates(elementHeight);\n    }\n    initBaseCoordinates(elementHeight, coordinates) {\n        this.baseCoordinates = this.makeBaseCoordinates(elementHeight, coordinates);\n    }\n    initElement(elementHeight, coordinates) {\n        this.element = this.makeElement(elementHeight, coordinates);\n    }\n    initGraphics(elementHeight, coordinates, dataSource) {\n        this.graphics = this.makeGraphics(elementHeight, coordinates, dataSource);\n    }\n}\nexports.StubGraphicalElement = StubGraphicalElement;\n//# sourceMappingURL=StubGraphicalElement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9vdXQvanMvZ3JhcGhpY3MvU3R1YkdyYXBoaWNhbEVsZW1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9vdXQvanMvZ3JhcGhpY3MvU3R1YkdyYXBoaWNhbEVsZW1lbnQuanM/MmJkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFN0dWJHcmFwaGljYWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICAgIHByZWZpeE5hbWUocHJlZml4KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IHByZWZpeCArIHRoaXMubmFtZTtcbiAgICB9XG4gICAgaW5pdENvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0b3JDb29yZGluYXRlcyA9IHRoaXMubWFrZUNvbm5lY3RvckNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQpO1xuICAgIH1cbiAgICBpbml0QmFzZUNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMuYmFzZUNvb3JkaW5hdGVzID0gdGhpcy5tYWtlQmFzZUNvb3JkaW5hdGVzKGVsZW1lbnRIZWlnaHQsIGNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgaW5pdEVsZW1lbnQoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5tYWtlRWxlbWVudChlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcyk7XG4gICAgfVxuICAgIGluaXRHcmFwaGljcyhlbGVtZW50SGVpZ2h0LCBjb29yZGluYXRlcywgZGF0YVNvdXJjZSkge1xuICAgICAgICB0aGlzLmdyYXBoaWNzID0gdGhpcy5tYWtlR3JhcGhpY3MoZWxlbWVudEhlaWdodCwgY29vcmRpbmF0ZXMsIGRhdGFTb3VyY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3R1YkdyYXBoaWNhbEVsZW1lbnQgPSBTdHViR3JhcGhpY2FsRWxlbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0dWJHcmFwaGljYWxFbGVtZW50LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./out/js/graphics/StubGraphicalElement.js\n");

/***/ })

/******/ });